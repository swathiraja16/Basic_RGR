#!/usr/bin/env node
/**
 * Relay v1.7.0
 *
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 * @format
	 */

	'use strict';

	var _asyncToGenerator2 = __webpack_require__(33);

	var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

	var _defineProperty3 = _interopRequireDefault(__webpack_require__(144));

	var _toConsumableArray3 = _interopRequireDefault(__webpack_require__(10));

	let run = (() => {
	  var _ref2 = (0, _asyncToGenerator3.default)(function* (options) {
	    var _parserConfigs;

	    var schemaPath = __webpack_require__(6).resolve(process.cwd(), options.schema);
	    if (!__webpack_require__(11).existsSync(schemaPath)) {
	      throw new Error('--schema path does not exist: ' + schemaPath + '.');
	    }
	    var srcDir = __webpack_require__(6).resolve(process.cwd(), options.src);
	    if (!__webpack_require__(11).existsSync(srcDir)) {
	      throw new Error('--source path does not exist: ' + srcDir + '.');
	    }
	    if (options.watch && !options.watchman) {
	      throw new Error('Watchman is required to watch for changes.');
	    }
	    if (options.watch && !hasWatchmanRootFile(srcDir)) {
	      throw new Error(('\n--watch requires that the src directory have a valid watchman "root" file.\n\nRoot files can include:\n- A .git/ Git folder\n- A .hg/ Mercurial folder\n- A .watchmanconfig file\n\nEnsure that one such file exists in ' + srcDir + ' or its parents.\n    ').trim());
	    }
	    if (options.verbose && options.quiet) {
	      throw new Error("I can't be quiet and verbose at the same time");
	    }

	    var reporter = new (__webpack_require__(1).ConsoleReporter)({
	      verbose: options.verbose,
	      quiet: options.quiet
	    });

	    var useWatchman = options.watchman && (yield __webpack_require__(1).WatchmanClient.isAvailable());

	    var schema = getSchema(schemaPath);

	    var languagePlugin = getLanguagePlugin(options.language);

	    var inputExtensions = options.extensions || languagePlugin.inputExtensions;
	    var outputExtension = languagePlugin.outputExtension;

	    var sourceParserName = inputExtensions.join('/');
	    var sourceWriterName = outputExtension;

	    var sourceModuleParser = __webpack_require__(74)(languagePlugin.findGraphQLTags);

	    var providedArtifactDirectory = options.artifactDirectory;
	    var artifactDirectory = providedArtifactDirectory != null ? __webpack_require__(6).resolve(process.cwd(), providedArtifactDirectory) : null;

	    var generatedDirectoryName = artifactDirectory || '__generated__';

	    var sourceSearchOptions = {
	      extensions: inputExtensions,
	      include: options.include,
	      exclude: ['**/*.graphql.*'].concat((0, _toConsumableArray3['default'])(options.exclude)) // Do not include artifacts
	    };
	    var graphqlSearchOptions = {
	      extensions: ['graphql'],
	      include: options.include,
	      exclude: [__webpack_require__(6).relative(srcDir, schemaPath)].concat(options.exclude)
	    };

	    var parserConfigs = (_parserConfigs = {}, (0, _defineProperty3['default'])(_parserConfigs, sourceParserName, {
	      baseDir: srcDir,
	      getFileFilter: sourceModuleParser.getFileFilter,
	      getParser: sourceModuleParser.getParser,
	      getSchema: function getSchema() {
	        return schema;
	      },
	      watchmanExpression: useWatchman ? buildWatchExpression(sourceSearchOptions) : null,
	      filepaths: useWatchman ? null : getFilepathsFromGlob(srcDir, sourceSearchOptions)
	    }), (0, _defineProperty3['default'])(_parserConfigs, 'graphql', {
	      baseDir: srcDir,
	      getParser: __webpack_require__(1).DotGraphQLParser.getParser,
	      getSchema: function getSchema() {
	        return schema;
	      },
	      watchmanExpression: useWatchman ? buildWatchExpression(graphqlSearchOptions) : null,
	      filepaths: useWatchman ? null : getFilepathsFromGlob(srcDir, graphqlSearchOptions)
	    }), _parserConfigs);
	    var writerConfigs = (0, _defineProperty3['default'])({}, sourceWriterName, {
	      getWriter: getRelayFileWriter(srcDir, languagePlugin, options.noFutureProofEnums, artifactDirectory),
	      isGeneratedFile: function isGeneratedFile(filePath) {
	        return filePath.endsWith('.graphql.' + outputExtension) && filePath.includes(generatedDirectoryName);
	      },
	      parser: sourceParserName,
	      baseParsers: ['graphql']
	    });
	    var codegenRunner = new (__webpack_require__(1).CodegenRunner)({
	      reporter: reporter,
	      parserConfigs: parserConfigs,
	      writerConfigs: writerConfigs,
	      onlyValidate: options.validate,
	      // TODO: allow passing in a flag or detect?
	      sourceControl: null
	    });
	    if (!options.validate && !options.watch && options.watchman) {
	      // eslint-disable-next-line no-console
	      console.log('HINT: pass --watch to keep watching for changes.');
	    }
	    var result = options.watch ? yield codegenRunner.watchAll() : yield codegenRunner.compileAll();

	    if (result === 'ERROR') {
	      process.exit(100);
	    }
	    if (options.validate && result !== 'NO_CHANGES') {
	      process.exit(101);
	    }
	  });

	  return function run(_x) {
	    return _ref2.apply(this, arguments);
	  };
	})();

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	__webpack_require__(143);

	function buildWatchExpression(options) {
	  return ['allof', ['type', 'f'], ['anyof'].concat((0, _toConsumableArray3['default'])(options.extensions.map(function (ext) {
	    return ['suffix', ext];
	  }))), ['anyof'].concat((0, _toConsumableArray3['default'])(options.include.map(function (include) {
	    return ['match', include, 'wholename'];
	  })))].concat((0, _toConsumableArray3['default'])(options.exclude.map(function (exclude) {
	    return ['not', ['match', exclude, 'wholename']];
	  })));
	}

	function getFilepathsFromGlob(baseDir, options) {
	  var extensions = options.extensions,
	      include = options.include,
	      exclude = options.exclude;

	  var patterns = include.map(function (inc) {
	    return inc + '/*.+(' + extensions.join('|') + ')';
	  });

	  var glob = __webpack_require__(148);
	  return glob.sync(patterns, {
	    cwd: baseDir,
	    ignore: exclude
	  });
	}

	/**
	 * Unless the requested plugin is the builtin `javascript` one, import a
	 * language plugin as either a CommonJS or ES2015 module.
	 *
	 * When importing, first check if it’s a path to an existing file, otherwise
	 * assume it’s a package and prepend the plugin namespace prefix.
	 *
	 * Make sure to always use Node's `require` function, which otherwise would get
	 * replaced with `__webpack_require__` when bundled using webpack, by using
	 * `eval` to get it at runtime.
	 */
	function getLanguagePlugin(language) {
	  if (language === 'javascript') {
	    return __webpack_require__(72)();
	  } else {
	    var pluginPath = __webpack_require__(6).resolve(process.cwd(), language);
	    var requirePath = __webpack_require__(11).existsSync(pluginPath) ? pluginPath : 'relay-compiler-language-' + language;
	    try {
	      // eslint-disable-next-line no-eval
	      var languagePlugin = eval('require')(requirePath);
	      if (languagePlugin['default']) {
	        languagePlugin = languagePlugin['default'];
	      }
	      if (typeof languagePlugin === 'function') {
	        return languagePlugin();
	      } else {
	        throw new Error('Expected plugin to export a function.');
	      }
	    } catch (err) {
	      var e = new Error('Unable to load language plugin ' + requirePath + ': ' + err.message);
	      e.stack = err.stack;
	      throw e;
	    }
	  }
	}

	function getRelayFileWriter(baseDir, languagePlugin, noFutureProofEnums, outputDir) {
	  return function (_ref) {
	    var onlyValidate = _ref.onlyValidate,
	        schema = _ref.schema,
	        documents = _ref.documents,
	        baseDocuments = _ref.baseDocuments,
	        sourceControl = _ref.sourceControl,
	        reporter = _ref.reporter;
	    return new (__webpack_require__(68))({
	      config: {
	        baseDir: baseDir,
	        compilerTransforms: {
	          commonTransforms: __webpack_require__(17).commonTransforms,
	          codegenTransforms: __webpack_require__(17).codegenTransforms,
	          fragmentTransforms: __webpack_require__(17).fragmentTransforms,
	          printTransforms: __webpack_require__(17).printTransforms,
	          queryTransforms: __webpack_require__(17).queryTransforms
	        },
	        customScalars: {},
	        formatModule: languagePlugin.formatModule,
	        inputFieldWhiteListForFlow: [],
	        schemaExtensions: __webpack_require__(17).schemaExtensions,
	        useHaste: false,
	        noFutureProofEnums: noFutureProofEnums,
	        extension: languagePlugin.outputExtension,
	        typeGenerator: languagePlugin.typeGenerator,
	        outputDir: outputDir
	      },
	      onlyValidate: onlyValidate,
	      schema: schema,
	      baseDocuments: baseDocuments,
	      documents: documents,
	      reporter: reporter,
	      sourceControl: sourceControl
	    });
	  };
	}

	function getSchema(schemaPath) {
	  try {
	    var source = __webpack_require__(11).readFileSync(schemaPath, 'utf8');
	    if (__webpack_require__(6).extname(schemaPath) === '.json') {
	      source = __webpack_require__(3).printSchema(__webpack_require__(3).buildClientSchema(JSON.parse(source).data));
	    }
	    source = '\n  directive @include(if: Boolean) on FRAGMENT_SPREAD | FIELD\n  directive @skip(if: Boolean) on FRAGMENT_SPREAD | FIELD\n\n  ' + source + '\n  ';
	    return __webpack_require__(3).buildASTSchema(__webpack_require__(3).parse(source), { assumeValid: true });
	  } catch (error) {
	    throw new Error(('\nError loading schema. Expected the schema to be a .graphql or a .json\nfile, describing your GraphQL server\'s API. Error detail:\n\n' + error.stack + '\n    ').trim());
	  }
	}

	// Ensure that a watchman "root" file exists in the given directory
	// or a parent so that it can be watched
	var WATCHMAN_ROOT_FILES = ['.git', '.hg', '.watchmanconfig'];
	function hasWatchmanRootFile(testPath) {
	  while (__webpack_require__(6).dirname(testPath) !== testPath) {
	    if (WATCHMAN_ROOT_FILES.some(function (file) {
	      return __webpack_require__(11).existsSync(__webpack_require__(6).join(testPath, file));
	    })) {
	      return true;
	    }
	    testPath = __webpack_require__(6).dirname(testPath);
	  }
	  return false;
	}

	// Collect args
	var argv = __webpack_require__(160).usage('Create Relay generated files\n\n' + '$0 --schema <path> --src <path> [--watch]').options({
	  schema: {
	    describe: 'Path to schema.graphql or schema.json',
	    demandOption: true,
	    type: 'string'
	  },
	  src: {
	    describe: 'Root directory of application code',
	    demandOption: true,
	    type: 'string'
	  },
	  include: {
	    array: true,
	    'default': ['**'],
	    describe: 'Directories to include under src',
	    type: 'string'
	  },
	  exclude: {
	    array: true,
	    'default': ['**/node_modules/**', '**/__mocks__/**', '**/__tests__/**', '**/__generated__/**'],
	    describe: 'Directories to ignore under src',
	    type: 'string'
	  },
	  extensions: {
	    array: true,
	    describe: 'File extensions to compile (defaults to extensions provided by the ' + 'language plugin)',
	    type: 'string'
	  },
	  verbose: {
	    describe: 'More verbose logging',
	    type: 'boolean'
	  },
	  quiet: {
	    describe: 'No output to stdout',
	    type: 'boolean'
	  },
	  watchman: {
	    describe: 'Use watchman when not in watch mode',
	    type: 'boolean',
	    'default': true
	  },
	  watch: {
	    describe: 'If specified, watches files and regenerates on changes',
	    type: 'boolean'
	  },
	  validate: {
	    describe: 'Looks for pending changes and exits with non-zero code instead of ' + 'writing to disk',
	    type: 'boolean',
	    'default': false
	  },
	  noFutureProofEnums: {
	    describe: 'This option controls whether or not a catch-all entry is added to enum type definitions ' + 'for values that may be added in the future. Enabling this means you will have to update ' + 'your application whenever the GraphQL server schema adds new enum values to prevent it ' + 'from breaking.',
	    'default': false
	  },
	  language: {
	    describe: 'The name of the language plugin used for input files and artifacts',
	    type: 'string',
	    'default': 'javascript'
	  },
	  artifactDirectory: {
	    describe: 'A specific directory to output all artifacts to. When enabling this ' + 'the babel plugin needs `artifactDirectory` set as well.',
	    type: 'string',
	    'default': null
	  }
	}).help().argv;

	// Run script with args
	// $FlowFixMe: Invalid types for yargs. Please fix this when touching this code.
	run(argv)['catch'](function (error) {
	  console.error(String(error.stack || error));
	  process.exit(1);
	});

/***/ }),
/* 1 */
/***/ (function(module, exports) {

	module.exports = require("graphql-compiler");

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var _exportNames = {
	  react: true,
	  assertNode: true,
	  createTypeAnnotationBasedOnTypeof: true,
	  createUnionTypeAnnotation: true,
	  cloneNode: true,
	  clone: true,
	  cloneDeep: true,
	  cloneWithoutLoc: true,
	  addComment: true,
	  addComments: true,
	  inheritInnerComments: true,
	  inheritLeadingComments: true,
	  inheritsComments: true,
	  inheritTrailingComments: true,
	  removeComments: true,
	  ensureBlock: true,
	  toBindingIdentifierName: true,
	  toBlock: true,
	  toComputedKey: true,
	  toExpression: true,
	  toIdentifier: true,
	  toKeyAlias: true,
	  toSequenceExpression: true,
	  toStatement: true,
	  valueToNode: true,
	  appendToMemberExpression: true,
	  inherits: true,
	  prependToMemberExpression: true,
	  removeProperties: true,
	  removePropertiesDeep: true,
	  removeTypeDuplicates: true,
	  getBindingIdentifiers: true,
	  getOuterBindingIdentifiers: true,
	  traverse: true,
	  traverseFast: true,
	  shallowEqual: true,
	  is: true,
	  isBinding: true,
	  isBlockScoped: true,
	  isImmutable: true,
	  isLet: true,
	  isNode: true,
	  isNodesEquivalent: true,
	  isReferenced: true,
	  isScope: true,
	  isSpecifierDefault: true,
	  isType: true,
	  isValidES3Identifier: true,
	  isValidIdentifier: true,
	  isVar: true,
	  matchesPattern: true,
	  validate: true,
	  buildMatchMemberExpression: true
	};
	Object.defineProperty(exports, "assertNode", {
	  enumerable: true,
	  get: function () {
	    return _assertNode.default;
	  }
	});
	Object.defineProperty(exports, "createTypeAnnotationBasedOnTypeof", {
	  enumerable: true,
	  get: function () {
	    return _createTypeAnnotationBasedOnTypeof.default;
	  }
	});
	Object.defineProperty(exports, "createUnionTypeAnnotation", {
	  enumerable: true,
	  get: function () {
	    return _createUnionTypeAnnotation.default;
	  }
	});
	Object.defineProperty(exports, "cloneNode", {
	  enumerable: true,
	  get: function () {
	    return _cloneNode.default;
	  }
	});
	Object.defineProperty(exports, "clone", {
	  enumerable: true,
	  get: function () {
	    return _clone.default;
	  }
	});
	Object.defineProperty(exports, "cloneDeep", {
	  enumerable: true,
	  get: function () {
	    return _cloneDeep.default;
	  }
	});
	Object.defineProperty(exports, "cloneWithoutLoc", {
	  enumerable: true,
	  get: function () {
	    return _cloneWithoutLoc.default;
	  }
	});
	Object.defineProperty(exports, "addComment", {
	  enumerable: true,
	  get: function () {
	    return _addComment.default;
	  }
	});
	Object.defineProperty(exports, "addComments", {
	  enumerable: true,
	  get: function () {
	    return _addComments.default;
	  }
	});
	Object.defineProperty(exports, "inheritInnerComments", {
	  enumerable: true,
	  get: function () {
	    return _inheritInnerComments.default;
	  }
	});
	Object.defineProperty(exports, "inheritLeadingComments", {
	  enumerable: true,
	  get: function () {
	    return _inheritLeadingComments.default;
	  }
	});
	Object.defineProperty(exports, "inheritsComments", {
	  enumerable: true,
	  get: function () {
	    return _inheritsComments.default;
	  }
	});
	Object.defineProperty(exports, "inheritTrailingComments", {
	  enumerable: true,
	  get: function () {
	    return _inheritTrailingComments.default;
	  }
	});
	Object.defineProperty(exports, "removeComments", {
	  enumerable: true,
	  get: function () {
	    return _removeComments.default;
	  }
	});
	Object.defineProperty(exports, "ensureBlock", {
	  enumerable: true,
	  get: function () {
	    return _ensureBlock.default;
	  }
	});
	Object.defineProperty(exports, "toBindingIdentifierName", {
	  enumerable: true,
	  get: function () {
	    return _toBindingIdentifierName.default;
	  }
	});
	Object.defineProperty(exports, "toBlock", {
	  enumerable: true,
	  get: function () {
	    return _toBlock.default;
	  }
	});
	Object.defineProperty(exports, "toComputedKey", {
	  enumerable: true,
	  get: function () {
	    return _toComputedKey.default;
	  }
	});
	Object.defineProperty(exports, "toExpression", {
	  enumerable: true,
	  get: function () {
	    return _toExpression.default;
	  }
	});
	Object.defineProperty(exports, "toIdentifier", {
	  enumerable: true,
	  get: function () {
	    return _toIdentifier.default;
	  }
	});
	Object.defineProperty(exports, "toKeyAlias", {
	  enumerable: true,
	  get: function () {
	    return _toKeyAlias.default;
	  }
	});
	Object.defineProperty(exports, "toSequenceExpression", {
	  enumerable: true,
	  get: function () {
	    return _toSequenceExpression.default;
	  }
	});
	Object.defineProperty(exports, "toStatement", {
	  enumerable: true,
	  get: function () {
	    return _toStatement.default;
	  }
	});
	Object.defineProperty(exports, "valueToNode", {
	  enumerable: true,
	  get: function () {
	    return _valueToNode.default;
	  }
	});
	Object.defineProperty(exports, "appendToMemberExpression", {
	  enumerable: true,
	  get: function () {
	    return _appendToMemberExpression.default;
	  }
	});
	Object.defineProperty(exports, "inherits", {
	  enumerable: true,
	  get: function () {
	    return _inherits.default;
	  }
	});
	Object.defineProperty(exports, "prependToMemberExpression", {
	  enumerable: true,
	  get: function () {
	    return _prependToMemberExpression.default;
	  }
	});
	Object.defineProperty(exports, "removeProperties", {
	  enumerable: true,
	  get: function () {
	    return _removeProperties.default;
	  }
	});
	Object.defineProperty(exports, "removePropertiesDeep", {
	  enumerable: true,
	  get: function () {
	    return _removePropertiesDeep.default;
	  }
	});
	Object.defineProperty(exports, "removeTypeDuplicates", {
	  enumerable: true,
	  get: function () {
	    return _removeTypeDuplicates.default;
	  }
	});
	Object.defineProperty(exports, "getBindingIdentifiers", {
	  enumerable: true,
	  get: function () {
	    return _getBindingIdentifiers.default;
	  }
	});
	Object.defineProperty(exports, "getOuterBindingIdentifiers", {
	  enumerable: true,
	  get: function () {
	    return _getOuterBindingIdentifiers.default;
	  }
	});
	Object.defineProperty(exports, "traverse", {
	  enumerable: true,
	  get: function () {
	    return _traverse.default;
	  }
	});
	Object.defineProperty(exports, "traverseFast", {
	  enumerable: true,
	  get: function () {
	    return _traverseFast.default;
	  }
	});
	Object.defineProperty(exports, "shallowEqual", {
	  enumerable: true,
	  get: function () {
	    return _shallowEqual.default;
	  }
	});
	Object.defineProperty(exports, "is", {
	  enumerable: true,
	  get: function () {
	    return _is.default;
	  }
	});
	Object.defineProperty(exports, "isBinding", {
	  enumerable: true,
	  get: function () {
	    return _isBinding.default;
	  }
	});
	Object.defineProperty(exports, "isBlockScoped", {
	  enumerable: true,
	  get: function () {
	    return _isBlockScoped.default;
	  }
	});
	Object.defineProperty(exports, "isImmutable", {
	  enumerable: true,
	  get: function () {
	    return _isImmutable.default;
	  }
	});
	Object.defineProperty(exports, "isLet", {
	  enumerable: true,
	  get: function () {
	    return _isLet.default;
	  }
	});
	Object.defineProperty(exports, "isNode", {
	  enumerable: true,
	  get: function () {
	    return _isNode.default;
	  }
	});
	Object.defineProperty(exports, "isNodesEquivalent", {
	  enumerable: true,
	  get: function () {
	    return _isNodesEquivalent.default;
	  }
	});
	Object.defineProperty(exports, "isReferenced", {
	  enumerable: true,
	  get: function () {
	    return _isReferenced.default;
	  }
	});
	Object.defineProperty(exports, "isScope", {
	  enumerable: true,
	  get: function () {
	    return _isScope.default;
	  }
	});
	Object.defineProperty(exports, "isSpecifierDefault", {
	  enumerable: true,
	  get: function () {
	    return _isSpecifierDefault.default;
	  }
	});
	Object.defineProperty(exports, "isType", {
	  enumerable: true,
	  get: function () {
	    return _isType.default;
	  }
	});
	Object.defineProperty(exports, "isValidES3Identifier", {
	  enumerable: true,
	  get: function () {
	    return _isValidES3Identifier.default;
	  }
	});
	Object.defineProperty(exports, "isValidIdentifier", {
	  enumerable: true,
	  get: function () {
	    return _isValidIdentifier.default;
	  }
	});
	Object.defineProperty(exports, "isVar", {
	  enumerable: true,
	  get: function () {
	    return _isVar.default;
	  }
	});
	Object.defineProperty(exports, "matchesPattern", {
	  enumerable: true,
	  get: function () {
	    return _matchesPattern.default;
	  }
	});
	Object.defineProperty(exports, "validate", {
	  enumerable: true,
	  get: function () {
	    return _validate.default;
	  }
	});
	Object.defineProperty(exports, "buildMatchMemberExpression", {
	  enumerable: true,
	  get: function () {
	    return _buildMatchMemberExpression.default;
	  }
	});
	exports.react = void 0;

	var _isReactComponent = _interopRequireDefault(__webpack_require__(142));

	var _isCompatTag = _interopRequireDefault(__webpack_require__(141));

	var _buildChildren = _interopRequireDefault(__webpack_require__(106));

	var _assertNode = _interopRequireDefault(__webpack_require__(101));

	var _generated = __webpack_require__(102);

	Object.keys(_generated).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function () {
	      return _generated[key];
	    }
	  });
	});

	var _createTypeAnnotationBasedOnTypeof = _interopRequireDefault(__webpack_require__(104));

	var _createUnionTypeAnnotation = _interopRequireDefault(__webpack_require__(105));

	var _generated2 = __webpack_require__(12);

	Object.keys(_generated2).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function () {
	      return _generated2[key];
	    }
	  });
	});

	var _cloneNode = _interopRequireDefault(__webpack_require__(19));

	var _clone = _interopRequireDefault(__webpack_require__(44));

	var _cloneDeep = _interopRequireDefault(__webpack_require__(107));

	var _cloneWithoutLoc = _interopRequireDefault(__webpack_require__(108));

	var _addComment = _interopRequireDefault(__webpack_require__(109));

	var _addComments = _interopRequireDefault(__webpack_require__(45));

	var _inheritInnerComments = _interopRequireDefault(__webpack_require__(46));

	var _inheritLeadingComments = _interopRequireDefault(__webpack_require__(47));

	var _inheritsComments = _interopRequireDefault(__webpack_require__(49));

	var _inheritTrailingComments = _interopRequireDefault(__webpack_require__(48));

	var _removeComments = _interopRequireDefault(__webpack_require__(110));

	var _generated3 = __webpack_require__(111);

	Object.keys(_generated3).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function () {
	      return _generated3[key];
	    }
	  });
	});

	var _constants = __webpack_require__(16);

	Object.keys(_constants).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function () {
	      return _constants[key];
	    }
	  });
	});

	var _ensureBlock = _interopRequireDefault(__webpack_require__(112));

	var _toBindingIdentifierName = _interopRequireDefault(__webpack_require__(114));

	var _toBlock = _interopRequireDefault(__webpack_require__(50));

	var _toComputedKey = _interopRequireDefault(__webpack_require__(115));

	var _toExpression = _interopRequireDefault(__webpack_require__(116));

	var _toIdentifier = _interopRequireDefault(__webpack_require__(51));

	var _toKeyAlias = _interopRequireDefault(__webpack_require__(117));

	var _toSequenceExpression = _interopRequireDefault(__webpack_require__(118));

	var _toStatement = _interopRequireDefault(__webpack_require__(119));

	var _valueToNode = _interopRequireDefault(__webpack_require__(120));

	var _definitions = __webpack_require__(14);

	Object.keys(_definitions).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function () {
	      return _definitions[key];
	    }
	  });
	});

	var _appendToMemberExpression = _interopRequireDefault(__webpack_require__(126));

	var _inherits = _interopRequireDefault(__webpack_require__(127));

	var _prependToMemberExpression = _interopRequireDefault(__webpack_require__(128));

	var _removeProperties = _interopRequireDefault(__webpack_require__(53));

	var _removePropertiesDeep = _interopRequireDefault(__webpack_require__(54));

	var _removeTypeDuplicates = _interopRequireDefault(__webpack_require__(52));

	var _getBindingIdentifiers = _interopRequireDefault(__webpack_require__(21));

	var _getOuterBindingIdentifiers = _interopRequireDefault(__webpack_require__(129));

	var _traverse = _interopRequireDefault(__webpack_require__(130));

	var _traverseFast = _interopRequireDefault(__webpack_require__(55));

	var _shallowEqual = _interopRequireDefault(__webpack_require__(30));

	var _is = _interopRequireDefault(__webpack_require__(31));

	var _isBinding = _interopRequireDefault(__webpack_require__(132));

	var _isBlockScoped = _interopRequireDefault(__webpack_require__(133));

	var _isImmutable = _interopRequireDefault(__webpack_require__(134));

	var _isLet = _interopRequireDefault(__webpack_require__(57));

	var _isNode = _interopRequireDefault(__webpack_require__(58));

	var _isNodesEquivalent = _interopRequireDefault(__webpack_require__(135));

	var _isReferenced = _interopRequireDefault(__webpack_require__(136));

	var _isScope = _interopRequireDefault(__webpack_require__(137));

	var _isSpecifierDefault = _interopRequireDefault(__webpack_require__(138));

	var _isType = _interopRequireDefault(__webpack_require__(32));

	var _isValidES3Identifier = _interopRequireDefault(__webpack_require__(139));

	var _isValidIdentifier = _interopRequireDefault(__webpack_require__(20));

	var _isVar = _interopRequireDefault(__webpack_require__(140));

	var _matchesPattern = _interopRequireDefault(__webpack_require__(59));

	var _validate = _interopRequireDefault(__webpack_require__(60));

	var _buildMatchMemberExpression = _interopRequireDefault(__webpack_require__(56));

	var _generated4 = __webpack_require__(8);

	Object.keys(_generated4).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function () {
	      return _generated4[key];
	    }
	  });
	});

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	const react = {
	  isReactComponent: _isReactComponent.default,
	  isCompatTag: _isCompatTag.default,
	  buildChildren: _buildChildren.default
	};
	exports.react = react;

/***/ }),
/* 3 */
/***/ (function(module, exports) {

	module.exports = require("graphql");

/***/ }),
/* 4 */
/***/ (function(module, exports) {

	module.exports = require("fbjs/lib/invariant");

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 *  strict
	 * @format
	 */

	'use strict';

	/**
	 * type NAME = any;
	 */
	function anyTypeAlias(name) {
	  return __webpack_require__(2).typeAlias(__webpack_require__(2).identifier(name), null, __webpack_require__(2).anyTypeAnnotation());
	}

	/**
	 * {|
	 *   PROPS
	 * |}
	 */
	function exactObjectTypeAnnotation(props) {
	  var typeAnnotation = __webpack_require__(2).objectTypeAnnotation(props);
	  typeAnnotation.exact = true;
	  return typeAnnotation;
	}

	/**
	 * export type NAME = TYPE
	 */
	function exportType(name, type) {
	  return __webpack_require__(2).exportNamedDeclaration(__webpack_require__(2).typeAlias(__webpack_require__(2).identifier(name), null, type), [], null);
	}

	/**
	 * import type {NAMES[0], NAMES[1], ...} from 'MODULE';
	 */
	function importTypes(names, module) {
	  var importDeclaration = __webpack_require__(2).importDeclaration(names.map(function (name) {
	    return __webpack_require__(2).importSpecifier(__webpack_require__(2).identifier(name), __webpack_require__(2).identifier(name));
	  }), __webpack_require__(2).stringLiteral(module));
	  importDeclaration.importKind = 'type';
	  return importDeclaration;
	}

	/**
	 * Create an intersection type if needed.
	 *
	 * TYPES[0] & TYPES[1] & ...
	 */
	function intersectionTypeAnnotation(types) {
	  !(types.length > 0) ?  true ? __webpack_require__(4)(false, 'RelayFlowBabelFactories: cannot create an intersection of 0 types') : require('fbjs/lib/invariant')(false) : void 0;
	  return types.length === 1 ? types[0] : __webpack_require__(2).intersectionTypeAnnotation(types);
	}

	function lineComments() {
	  for (var _len = arguments.length, lines = Array(_len), _key = 0; _key < _len; _key++) {
	    lines[_key] = arguments[_key];
	  }

	  /* $FlowFixMe(>=0.70.0) This comment suppresses an error found when
	   * Flow v0.70 was deployed. To see the error delete this comment and
	   * run Flow. */
	  return lines.map(function (line) {
	    return { type: 'CommentLine', value: ' ' + line };
	  });
	}

	/**
	 * $ReadOnlyArray<TYPE>
	 */
	function readOnlyArrayOfType(thing) {
	  return __webpack_require__(2).genericTypeAnnotation(__webpack_require__(2).identifier('$ReadOnlyArray'), __webpack_require__(2).typeParameterInstantiation([thing]));
	}

	/**
	 * +KEY: VALUE
	 */
	function readOnlyObjectTypeProperty(key, value) {
	  var prop = __webpack_require__(2).objectTypeProperty(__webpack_require__(2).identifier(key), value);
	  prop.variance = __webpack_require__(2).variance('plus');
	  return prop;
	}

	function stringLiteralTypeAnnotation(value) {
	  return __webpack_require__(2).stringLiteralTypeAnnotation(value);
	}

	/**
	 * Create a union type if needed.
	 *
	 * TYPES[0] | TYPES[1] | ...
	 */
	function unionTypeAnnotation(types) {
	  !(types.length > 0) ?  true ? __webpack_require__(4)(false, 'RelayFlowBabelFactories: cannot create a union of 0 types') : require('fbjs/lib/invariant')(false) : void 0;
	  return types.length === 1 ? types[0] : __webpack_require__(2).unionTypeAnnotation(types);
	}

	module.exports = {
	  anyTypeAlias: anyTypeAlias,
	  exactObjectTypeAnnotation: exactObjectTypeAnnotation,
	  exportType: exportType,
	  importTypes: importTypes,
	  intersectionTypeAnnotation: intersectionTypeAnnotation,
	  lineComments: lineComments,
	  readOnlyArrayOfType: readOnlyArrayOfType,
	  readOnlyObjectTypeProperty: readOnlyObjectTypeProperty,
	  stringLiteralTypeAnnotation: stringLiteralTypeAnnotation,
	  unionTypeAnnotation: unionTypeAnnotation
	};

/***/ }),
/* 6 */
/***/ (function(module, exports) {

	module.exports = require("path");

/***/ }),
/* 7 */
/***/ (function(module, exports) {

	module.exports = require("relay-runtime");

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.isArrayExpression = isArrayExpression;
	exports.isAssignmentExpression = isAssignmentExpression;
	exports.isBinaryExpression = isBinaryExpression;
	exports.isInterpreterDirective = isInterpreterDirective;
	exports.isDirective = isDirective;
	exports.isDirectiveLiteral = isDirectiveLiteral;
	exports.isBlockStatement = isBlockStatement;
	exports.isBreakStatement = isBreakStatement;
	exports.isCallExpression = isCallExpression;
	exports.isCatchClause = isCatchClause;
	exports.isConditionalExpression = isConditionalExpression;
	exports.isContinueStatement = isContinueStatement;
	exports.isDebuggerStatement = isDebuggerStatement;
	exports.isDoWhileStatement = isDoWhileStatement;
	exports.isEmptyStatement = isEmptyStatement;
	exports.isExpressionStatement = isExpressionStatement;
	exports.isFile = isFile;
	exports.isForInStatement = isForInStatement;
	exports.isForStatement = isForStatement;
	exports.isFunctionDeclaration = isFunctionDeclaration;
	exports.isFunctionExpression = isFunctionExpression;
	exports.isIdentifier = isIdentifier;
	exports.isIfStatement = isIfStatement;
	exports.isLabeledStatement = isLabeledStatement;
	exports.isStringLiteral = isStringLiteral;
	exports.isNumericLiteral = isNumericLiteral;
	exports.isNullLiteral = isNullLiteral;
	exports.isBooleanLiteral = isBooleanLiteral;
	exports.isRegExpLiteral = isRegExpLiteral;
	exports.isLogicalExpression = isLogicalExpression;
	exports.isMemberExpression = isMemberExpression;
	exports.isNewExpression = isNewExpression;
	exports.isProgram = isProgram;
	exports.isObjectExpression = isObjectExpression;
	exports.isObjectMethod = isObjectMethod;
	exports.isObjectProperty = isObjectProperty;
	exports.isRestElement = isRestElement;
	exports.isReturnStatement = isReturnStatement;
	exports.isSequenceExpression = isSequenceExpression;
	exports.isSwitchCase = isSwitchCase;
	exports.isSwitchStatement = isSwitchStatement;
	exports.isThisExpression = isThisExpression;
	exports.isThrowStatement = isThrowStatement;
	exports.isTryStatement = isTryStatement;
	exports.isUnaryExpression = isUnaryExpression;
	exports.isUpdateExpression = isUpdateExpression;
	exports.isVariableDeclaration = isVariableDeclaration;
	exports.isVariableDeclarator = isVariableDeclarator;
	exports.isWhileStatement = isWhileStatement;
	exports.isWithStatement = isWithStatement;
	exports.isAssignmentPattern = isAssignmentPattern;
	exports.isArrayPattern = isArrayPattern;
	exports.isArrowFunctionExpression = isArrowFunctionExpression;
	exports.isClassBody = isClassBody;
	exports.isClassDeclaration = isClassDeclaration;
	exports.isClassExpression = isClassExpression;
	exports.isExportAllDeclaration = isExportAllDeclaration;
	exports.isExportDefaultDeclaration = isExportDefaultDeclaration;
	exports.isExportNamedDeclaration = isExportNamedDeclaration;
	exports.isExportSpecifier = isExportSpecifier;
	exports.isForOfStatement = isForOfStatement;
	exports.isImportDeclaration = isImportDeclaration;
	exports.isImportDefaultSpecifier = isImportDefaultSpecifier;
	exports.isImportNamespaceSpecifier = isImportNamespaceSpecifier;
	exports.isImportSpecifier = isImportSpecifier;
	exports.isMetaProperty = isMetaProperty;
	exports.isClassMethod = isClassMethod;
	exports.isObjectPattern = isObjectPattern;
	exports.isSpreadElement = isSpreadElement;
	exports.isSuper = isSuper;
	exports.isTaggedTemplateExpression = isTaggedTemplateExpression;
	exports.isTemplateElement = isTemplateElement;
	exports.isTemplateLiteral = isTemplateLiteral;
	exports.isYieldExpression = isYieldExpression;
	exports.isAnyTypeAnnotation = isAnyTypeAnnotation;
	exports.isArrayTypeAnnotation = isArrayTypeAnnotation;
	exports.isBooleanTypeAnnotation = isBooleanTypeAnnotation;
	exports.isBooleanLiteralTypeAnnotation = isBooleanLiteralTypeAnnotation;
	exports.isNullLiteralTypeAnnotation = isNullLiteralTypeAnnotation;
	exports.isClassImplements = isClassImplements;
	exports.isDeclareClass = isDeclareClass;
	exports.isDeclareFunction = isDeclareFunction;
	exports.isDeclareInterface = isDeclareInterface;
	exports.isDeclareModule = isDeclareModule;
	exports.isDeclareModuleExports = isDeclareModuleExports;
	exports.isDeclareTypeAlias = isDeclareTypeAlias;
	exports.isDeclareOpaqueType = isDeclareOpaqueType;
	exports.isDeclareVariable = isDeclareVariable;
	exports.isDeclareExportDeclaration = isDeclareExportDeclaration;
	exports.isDeclareExportAllDeclaration = isDeclareExportAllDeclaration;
	exports.isDeclaredPredicate = isDeclaredPredicate;
	exports.isExistsTypeAnnotation = isExistsTypeAnnotation;
	exports.isFunctionTypeAnnotation = isFunctionTypeAnnotation;
	exports.isFunctionTypeParam = isFunctionTypeParam;
	exports.isGenericTypeAnnotation = isGenericTypeAnnotation;
	exports.isInferredPredicate = isInferredPredicate;
	exports.isInterfaceExtends = isInterfaceExtends;
	exports.isInterfaceDeclaration = isInterfaceDeclaration;
	exports.isInterfaceTypeAnnotation = isInterfaceTypeAnnotation;
	exports.isIntersectionTypeAnnotation = isIntersectionTypeAnnotation;
	exports.isMixedTypeAnnotation = isMixedTypeAnnotation;
	exports.isEmptyTypeAnnotation = isEmptyTypeAnnotation;
	exports.isNullableTypeAnnotation = isNullableTypeAnnotation;
	exports.isNumberLiteralTypeAnnotation = isNumberLiteralTypeAnnotation;
	exports.isNumberTypeAnnotation = isNumberTypeAnnotation;
	exports.isObjectTypeAnnotation = isObjectTypeAnnotation;
	exports.isObjectTypeInternalSlot = isObjectTypeInternalSlot;
	exports.isObjectTypeCallProperty = isObjectTypeCallProperty;
	exports.isObjectTypeIndexer = isObjectTypeIndexer;
	exports.isObjectTypeProperty = isObjectTypeProperty;
	exports.isObjectTypeSpreadProperty = isObjectTypeSpreadProperty;
	exports.isOpaqueType = isOpaqueType;
	exports.isQualifiedTypeIdentifier = isQualifiedTypeIdentifier;
	exports.isStringLiteralTypeAnnotation = isStringLiteralTypeAnnotation;
	exports.isStringTypeAnnotation = isStringTypeAnnotation;
	exports.isThisTypeAnnotation = isThisTypeAnnotation;
	exports.isTupleTypeAnnotation = isTupleTypeAnnotation;
	exports.isTypeofTypeAnnotation = isTypeofTypeAnnotation;
	exports.isTypeAlias = isTypeAlias;
	exports.isTypeAnnotation = isTypeAnnotation;
	exports.isTypeCastExpression = isTypeCastExpression;
	exports.isTypeParameter = isTypeParameter;
	exports.isTypeParameterDeclaration = isTypeParameterDeclaration;
	exports.isTypeParameterInstantiation = isTypeParameterInstantiation;
	exports.isUnionTypeAnnotation = isUnionTypeAnnotation;
	exports.isVariance = isVariance;
	exports.isVoidTypeAnnotation = isVoidTypeAnnotation;
	exports.isJSXAttribute = isJSXAttribute;
	exports.isJSXClosingElement = isJSXClosingElement;
	exports.isJSXElement = isJSXElement;
	exports.isJSXEmptyExpression = isJSXEmptyExpression;
	exports.isJSXExpressionContainer = isJSXExpressionContainer;
	exports.isJSXSpreadChild = isJSXSpreadChild;
	exports.isJSXIdentifier = isJSXIdentifier;
	exports.isJSXMemberExpression = isJSXMemberExpression;
	exports.isJSXNamespacedName = isJSXNamespacedName;
	exports.isJSXOpeningElement = isJSXOpeningElement;
	exports.isJSXSpreadAttribute = isJSXSpreadAttribute;
	exports.isJSXText = isJSXText;
	exports.isJSXFragment = isJSXFragment;
	exports.isJSXOpeningFragment = isJSXOpeningFragment;
	exports.isJSXClosingFragment = isJSXClosingFragment;
	exports.isNoop = isNoop;
	exports.isParenthesizedExpression = isParenthesizedExpression;
	exports.isAwaitExpression = isAwaitExpression;
	exports.isBindExpression = isBindExpression;
	exports.isClassProperty = isClassProperty;
	exports.isOptionalMemberExpression = isOptionalMemberExpression;
	exports.isOptionalCallExpression = isOptionalCallExpression;
	exports.isClassPrivateProperty = isClassPrivateProperty;
	exports.isImport = isImport;
	exports.isDecorator = isDecorator;
	exports.isDoExpression = isDoExpression;
	exports.isExportDefaultSpecifier = isExportDefaultSpecifier;
	exports.isExportNamespaceSpecifier = isExportNamespaceSpecifier;
	exports.isPrivateName = isPrivateName;
	exports.isBigIntLiteral = isBigIntLiteral;
	exports.isTSParameterProperty = isTSParameterProperty;
	exports.isTSDeclareFunction = isTSDeclareFunction;
	exports.isTSDeclareMethod = isTSDeclareMethod;
	exports.isTSQualifiedName = isTSQualifiedName;
	exports.isTSCallSignatureDeclaration = isTSCallSignatureDeclaration;
	exports.isTSConstructSignatureDeclaration = isTSConstructSignatureDeclaration;
	exports.isTSPropertySignature = isTSPropertySignature;
	exports.isTSMethodSignature = isTSMethodSignature;
	exports.isTSIndexSignature = isTSIndexSignature;
	exports.isTSAnyKeyword = isTSAnyKeyword;
	exports.isTSNumberKeyword = isTSNumberKeyword;
	exports.isTSObjectKeyword = isTSObjectKeyword;
	exports.isTSBooleanKeyword = isTSBooleanKeyword;
	exports.isTSStringKeyword = isTSStringKeyword;
	exports.isTSSymbolKeyword = isTSSymbolKeyword;
	exports.isTSVoidKeyword = isTSVoidKeyword;
	exports.isTSUndefinedKeyword = isTSUndefinedKeyword;
	exports.isTSNullKeyword = isTSNullKeyword;
	exports.isTSNeverKeyword = isTSNeverKeyword;
	exports.isTSThisType = isTSThisType;
	exports.isTSFunctionType = isTSFunctionType;
	exports.isTSConstructorType = isTSConstructorType;
	exports.isTSTypeReference = isTSTypeReference;
	exports.isTSTypePredicate = isTSTypePredicate;
	exports.isTSTypeQuery = isTSTypeQuery;
	exports.isTSTypeLiteral = isTSTypeLiteral;
	exports.isTSArrayType = isTSArrayType;
	exports.isTSTupleType = isTSTupleType;
	exports.isTSUnionType = isTSUnionType;
	exports.isTSIntersectionType = isTSIntersectionType;
	exports.isTSConditionalType = isTSConditionalType;
	exports.isTSInferType = isTSInferType;
	exports.isTSParenthesizedType = isTSParenthesizedType;
	exports.isTSTypeOperator = isTSTypeOperator;
	exports.isTSIndexedAccessType = isTSIndexedAccessType;
	exports.isTSMappedType = isTSMappedType;
	exports.isTSLiteralType = isTSLiteralType;
	exports.isTSExpressionWithTypeArguments = isTSExpressionWithTypeArguments;
	exports.isTSInterfaceDeclaration = isTSInterfaceDeclaration;
	exports.isTSInterfaceBody = isTSInterfaceBody;
	exports.isTSTypeAliasDeclaration = isTSTypeAliasDeclaration;
	exports.isTSAsExpression = isTSAsExpression;
	exports.isTSTypeAssertion = isTSTypeAssertion;
	exports.isTSEnumDeclaration = isTSEnumDeclaration;
	exports.isTSEnumMember = isTSEnumMember;
	exports.isTSModuleDeclaration = isTSModuleDeclaration;
	exports.isTSModuleBlock = isTSModuleBlock;
	exports.isTSImportEqualsDeclaration = isTSImportEqualsDeclaration;
	exports.isTSExternalModuleReference = isTSExternalModuleReference;
	exports.isTSNonNullExpression = isTSNonNullExpression;
	exports.isTSExportAssignment = isTSExportAssignment;
	exports.isTSNamespaceExportDeclaration = isTSNamespaceExportDeclaration;
	exports.isTSTypeAnnotation = isTSTypeAnnotation;
	exports.isTSTypeParameterInstantiation = isTSTypeParameterInstantiation;
	exports.isTSTypeParameterDeclaration = isTSTypeParameterDeclaration;
	exports.isTSTypeParameter = isTSTypeParameter;
	exports.isExpression = isExpression;
	exports.isBinary = isBinary;
	exports.isScopable = isScopable;
	exports.isBlockParent = isBlockParent;
	exports.isBlock = isBlock;
	exports.isStatement = isStatement;
	exports.isTerminatorless = isTerminatorless;
	exports.isCompletionStatement = isCompletionStatement;
	exports.isConditional = isConditional;
	exports.isLoop = isLoop;
	exports.isWhile = isWhile;
	exports.isExpressionWrapper = isExpressionWrapper;
	exports.isFor = isFor;
	exports.isForXStatement = isForXStatement;
	exports.isFunction = isFunction;
	exports.isFunctionParent = isFunctionParent;
	exports.isPureish = isPureish;
	exports.isDeclaration = isDeclaration;
	exports.isPatternLike = isPatternLike;
	exports.isLVal = isLVal;
	exports.isTSEntityName = isTSEntityName;
	exports.isLiteral = isLiteral;
	exports.isImmutable = isImmutable;
	exports.isUserWhitespacable = isUserWhitespacable;
	exports.isMethod = isMethod;
	exports.isObjectMember = isObjectMember;
	exports.isProperty = isProperty;
	exports.isUnaryLike = isUnaryLike;
	exports.isPattern = isPattern;
	exports.isClass = isClass;
	exports.isModuleDeclaration = isModuleDeclaration;
	exports.isExportDeclaration = isExportDeclaration;
	exports.isModuleSpecifier = isModuleSpecifier;
	exports.isFlow = isFlow;
	exports.isFlowType = isFlowType;
	exports.isFlowBaseAnnotation = isFlowBaseAnnotation;
	exports.isFlowDeclaration = isFlowDeclaration;
	exports.isFlowPredicate = isFlowPredicate;
	exports.isJSX = isJSX;
	exports.isPrivate = isPrivate;
	exports.isTSTypeElement = isTSTypeElement;
	exports.isTSType = isTSType;
	exports.isNumberLiteral = isNumberLiteral;
	exports.isRegexLiteral = isRegexLiteral;
	exports.isRestProperty = isRestProperty;
	exports.isSpreadProperty = isSpreadProperty;

	var _shallowEqual = _interopRequireDefault(__webpack_require__(30));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function isArrayExpression(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "ArrayExpression") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isAssignmentExpression(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "AssignmentExpression") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isBinaryExpression(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "BinaryExpression") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isInterpreterDirective(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "InterpreterDirective") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isDirective(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "Directive") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isDirectiveLiteral(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "DirectiveLiteral") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isBlockStatement(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "BlockStatement") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isBreakStatement(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "BreakStatement") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isCallExpression(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "CallExpression") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isCatchClause(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "CatchClause") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isConditionalExpression(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "ConditionalExpression") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isContinueStatement(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "ContinueStatement") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isDebuggerStatement(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "DebuggerStatement") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isDoWhileStatement(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "DoWhileStatement") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isEmptyStatement(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "EmptyStatement") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isExpressionStatement(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "ExpressionStatement") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isFile(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "File") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isForInStatement(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "ForInStatement") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isForStatement(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "ForStatement") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isFunctionDeclaration(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "FunctionDeclaration") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isFunctionExpression(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "FunctionExpression") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isIdentifier(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "Identifier") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isIfStatement(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "IfStatement") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isLabeledStatement(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "LabeledStatement") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isStringLiteral(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "StringLiteral") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isNumericLiteral(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "NumericLiteral") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isNullLiteral(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "NullLiteral") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isBooleanLiteral(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "BooleanLiteral") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isRegExpLiteral(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "RegExpLiteral") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isLogicalExpression(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "LogicalExpression") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isMemberExpression(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "MemberExpression") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isNewExpression(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "NewExpression") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isProgram(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "Program") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isObjectExpression(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "ObjectExpression") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isObjectMethod(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "ObjectMethod") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isObjectProperty(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "ObjectProperty") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isRestElement(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "RestElement") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isReturnStatement(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "ReturnStatement") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isSequenceExpression(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "SequenceExpression") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isSwitchCase(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "SwitchCase") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isSwitchStatement(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "SwitchStatement") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isThisExpression(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "ThisExpression") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isThrowStatement(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "ThrowStatement") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isTryStatement(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "TryStatement") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isUnaryExpression(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "UnaryExpression") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isUpdateExpression(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "UpdateExpression") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isVariableDeclaration(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "VariableDeclaration") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isVariableDeclarator(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "VariableDeclarator") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isWhileStatement(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "WhileStatement") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isWithStatement(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "WithStatement") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isAssignmentPattern(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "AssignmentPattern") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isArrayPattern(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "ArrayPattern") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isArrowFunctionExpression(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "ArrowFunctionExpression") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isClassBody(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "ClassBody") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isClassDeclaration(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "ClassDeclaration") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isClassExpression(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "ClassExpression") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isExportAllDeclaration(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "ExportAllDeclaration") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isExportDefaultDeclaration(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "ExportDefaultDeclaration") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isExportNamedDeclaration(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "ExportNamedDeclaration") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isExportSpecifier(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "ExportSpecifier") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isForOfStatement(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "ForOfStatement") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isImportDeclaration(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "ImportDeclaration") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isImportDefaultSpecifier(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "ImportDefaultSpecifier") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isImportNamespaceSpecifier(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "ImportNamespaceSpecifier") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isImportSpecifier(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "ImportSpecifier") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isMetaProperty(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "MetaProperty") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isClassMethod(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "ClassMethod") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isObjectPattern(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "ObjectPattern") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isSpreadElement(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "SpreadElement") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isSuper(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "Super") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isTaggedTemplateExpression(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "TaggedTemplateExpression") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isTemplateElement(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "TemplateElement") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isTemplateLiteral(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "TemplateLiteral") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isYieldExpression(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "YieldExpression") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isAnyTypeAnnotation(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "AnyTypeAnnotation") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isArrayTypeAnnotation(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "ArrayTypeAnnotation") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isBooleanTypeAnnotation(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "BooleanTypeAnnotation") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isBooleanLiteralTypeAnnotation(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "BooleanLiteralTypeAnnotation") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isNullLiteralTypeAnnotation(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "NullLiteralTypeAnnotation") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isClassImplements(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "ClassImplements") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isDeclareClass(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "DeclareClass") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isDeclareFunction(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "DeclareFunction") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isDeclareInterface(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "DeclareInterface") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isDeclareModule(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "DeclareModule") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isDeclareModuleExports(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "DeclareModuleExports") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isDeclareTypeAlias(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "DeclareTypeAlias") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isDeclareOpaqueType(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "DeclareOpaqueType") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isDeclareVariable(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "DeclareVariable") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isDeclareExportDeclaration(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "DeclareExportDeclaration") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isDeclareExportAllDeclaration(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "DeclareExportAllDeclaration") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isDeclaredPredicate(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "DeclaredPredicate") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isExistsTypeAnnotation(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "ExistsTypeAnnotation") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isFunctionTypeAnnotation(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "FunctionTypeAnnotation") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isFunctionTypeParam(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "FunctionTypeParam") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isGenericTypeAnnotation(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "GenericTypeAnnotation") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isInferredPredicate(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "InferredPredicate") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isInterfaceExtends(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "InterfaceExtends") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isInterfaceDeclaration(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "InterfaceDeclaration") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isInterfaceTypeAnnotation(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "InterfaceTypeAnnotation") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isIntersectionTypeAnnotation(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "IntersectionTypeAnnotation") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isMixedTypeAnnotation(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "MixedTypeAnnotation") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isEmptyTypeAnnotation(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "EmptyTypeAnnotation") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isNullableTypeAnnotation(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "NullableTypeAnnotation") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isNumberLiteralTypeAnnotation(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "NumberLiteralTypeAnnotation") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isNumberTypeAnnotation(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "NumberTypeAnnotation") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isObjectTypeAnnotation(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "ObjectTypeAnnotation") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isObjectTypeInternalSlot(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "ObjectTypeInternalSlot") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isObjectTypeCallProperty(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "ObjectTypeCallProperty") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isObjectTypeIndexer(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "ObjectTypeIndexer") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isObjectTypeProperty(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "ObjectTypeProperty") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isObjectTypeSpreadProperty(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "ObjectTypeSpreadProperty") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isOpaqueType(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "OpaqueType") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isQualifiedTypeIdentifier(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "QualifiedTypeIdentifier") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isStringLiteralTypeAnnotation(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "StringLiteralTypeAnnotation") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isStringTypeAnnotation(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "StringTypeAnnotation") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isThisTypeAnnotation(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "ThisTypeAnnotation") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isTupleTypeAnnotation(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "TupleTypeAnnotation") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isTypeofTypeAnnotation(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "TypeofTypeAnnotation") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isTypeAlias(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "TypeAlias") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isTypeAnnotation(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "TypeAnnotation") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isTypeCastExpression(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "TypeCastExpression") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isTypeParameter(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "TypeParameter") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isTypeParameterDeclaration(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "TypeParameterDeclaration") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isTypeParameterInstantiation(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "TypeParameterInstantiation") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isUnionTypeAnnotation(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "UnionTypeAnnotation") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isVariance(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "Variance") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isVoidTypeAnnotation(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "VoidTypeAnnotation") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isJSXAttribute(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "JSXAttribute") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isJSXClosingElement(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "JSXClosingElement") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isJSXElement(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "JSXElement") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isJSXEmptyExpression(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "JSXEmptyExpression") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isJSXExpressionContainer(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "JSXExpressionContainer") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isJSXSpreadChild(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "JSXSpreadChild") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isJSXIdentifier(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "JSXIdentifier") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isJSXMemberExpression(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "JSXMemberExpression") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isJSXNamespacedName(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "JSXNamespacedName") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isJSXOpeningElement(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "JSXOpeningElement") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isJSXSpreadAttribute(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "JSXSpreadAttribute") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isJSXText(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "JSXText") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isJSXFragment(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "JSXFragment") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isJSXOpeningFragment(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "JSXOpeningFragment") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isJSXClosingFragment(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "JSXClosingFragment") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isNoop(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "Noop") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isParenthesizedExpression(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "ParenthesizedExpression") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isAwaitExpression(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "AwaitExpression") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isBindExpression(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "BindExpression") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isClassProperty(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "ClassProperty") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isOptionalMemberExpression(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "OptionalMemberExpression") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isOptionalCallExpression(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "OptionalCallExpression") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isClassPrivateProperty(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "ClassPrivateProperty") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isImport(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "Import") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isDecorator(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "Decorator") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isDoExpression(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "DoExpression") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isExportDefaultSpecifier(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "ExportDefaultSpecifier") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isExportNamespaceSpecifier(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "ExportNamespaceSpecifier") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isPrivateName(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "PrivateName") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isBigIntLiteral(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "BigIntLiteral") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isTSParameterProperty(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "TSParameterProperty") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isTSDeclareFunction(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "TSDeclareFunction") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isTSDeclareMethod(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "TSDeclareMethod") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isTSQualifiedName(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "TSQualifiedName") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isTSCallSignatureDeclaration(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "TSCallSignatureDeclaration") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isTSConstructSignatureDeclaration(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "TSConstructSignatureDeclaration") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isTSPropertySignature(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "TSPropertySignature") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isTSMethodSignature(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "TSMethodSignature") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isTSIndexSignature(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "TSIndexSignature") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isTSAnyKeyword(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "TSAnyKeyword") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isTSNumberKeyword(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "TSNumberKeyword") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isTSObjectKeyword(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "TSObjectKeyword") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isTSBooleanKeyword(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "TSBooleanKeyword") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isTSStringKeyword(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "TSStringKeyword") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isTSSymbolKeyword(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "TSSymbolKeyword") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isTSVoidKeyword(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "TSVoidKeyword") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isTSUndefinedKeyword(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "TSUndefinedKeyword") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isTSNullKeyword(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "TSNullKeyword") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isTSNeverKeyword(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "TSNeverKeyword") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isTSThisType(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "TSThisType") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isTSFunctionType(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "TSFunctionType") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isTSConstructorType(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "TSConstructorType") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isTSTypeReference(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "TSTypeReference") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isTSTypePredicate(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "TSTypePredicate") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isTSTypeQuery(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "TSTypeQuery") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isTSTypeLiteral(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "TSTypeLiteral") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isTSArrayType(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "TSArrayType") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isTSTupleType(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "TSTupleType") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isTSUnionType(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "TSUnionType") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isTSIntersectionType(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "TSIntersectionType") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isTSConditionalType(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "TSConditionalType") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isTSInferType(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "TSInferType") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isTSParenthesizedType(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "TSParenthesizedType") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isTSTypeOperator(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "TSTypeOperator") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isTSIndexedAccessType(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "TSIndexedAccessType") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isTSMappedType(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "TSMappedType") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isTSLiteralType(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "TSLiteralType") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isTSExpressionWithTypeArguments(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "TSExpressionWithTypeArguments") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isTSInterfaceDeclaration(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "TSInterfaceDeclaration") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isTSInterfaceBody(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "TSInterfaceBody") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isTSTypeAliasDeclaration(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "TSTypeAliasDeclaration") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isTSAsExpression(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "TSAsExpression") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isTSTypeAssertion(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "TSTypeAssertion") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isTSEnumDeclaration(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "TSEnumDeclaration") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isTSEnumMember(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "TSEnumMember") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isTSModuleDeclaration(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "TSModuleDeclaration") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isTSModuleBlock(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "TSModuleBlock") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isTSImportEqualsDeclaration(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "TSImportEqualsDeclaration") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isTSExternalModuleReference(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "TSExternalModuleReference") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isTSNonNullExpression(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "TSNonNullExpression") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isTSExportAssignment(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "TSExportAssignment") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isTSNamespaceExportDeclaration(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "TSNamespaceExportDeclaration") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isTSTypeAnnotation(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "TSTypeAnnotation") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isTSTypeParameterInstantiation(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "TSTypeParameterInstantiation") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isTSTypeParameterDeclaration(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "TSTypeParameterDeclaration") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isTSTypeParameter(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "TSTypeParameter") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isExpression(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "Expression" || "ArrayExpression" === nodeType || "AssignmentExpression" === nodeType || "BinaryExpression" === nodeType || "CallExpression" === nodeType || "ConditionalExpression" === nodeType || "FunctionExpression" === nodeType || "Identifier" === nodeType || "StringLiteral" === nodeType || "NumericLiteral" === nodeType || "NullLiteral" === nodeType || "BooleanLiteral" === nodeType || "RegExpLiteral" === nodeType || "LogicalExpression" === nodeType || "MemberExpression" === nodeType || "NewExpression" === nodeType || "ObjectExpression" === nodeType || "SequenceExpression" === nodeType || "ThisExpression" === nodeType || "UnaryExpression" === nodeType || "UpdateExpression" === nodeType || "ArrowFunctionExpression" === nodeType || "ClassExpression" === nodeType || "MetaProperty" === nodeType || "Super" === nodeType || "TaggedTemplateExpression" === nodeType || "TemplateLiteral" === nodeType || "YieldExpression" === nodeType || "TypeCastExpression" === nodeType || "JSXElement" === nodeType || "JSXFragment" === nodeType || "ParenthesizedExpression" === nodeType || "AwaitExpression" === nodeType || "BindExpression" === nodeType || "OptionalMemberExpression" === nodeType || "OptionalCallExpression" === nodeType || "Import" === nodeType || "DoExpression" === nodeType || "BigIntLiteral" === nodeType || "TSAsExpression" === nodeType || "TSTypeAssertion" === nodeType || "TSNonNullExpression" === nodeType) {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isBinary(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "Binary" || "BinaryExpression" === nodeType || "LogicalExpression" === nodeType) {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isScopable(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "Scopable" || "BlockStatement" === nodeType || "CatchClause" === nodeType || "DoWhileStatement" === nodeType || "ForInStatement" === nodeType || "ForStatement" === nodeType || "FunctionDeclaration" === nodeType || "FunctionExpression" === nodeType || "Program" === nodeType || "ObjectMethod" === nodeType || "SwitchStatement" === nodeType || "WhileStatement" === nodeType || "ArrowFunctionExpression" === nodeType || "ClassDeclaration" === nodeType || "ClassExpression" === nodeType || "ForOfStatement" === nodeType || "ClassMethod" === nodeType) {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isBlockParent(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "BlockParent" || "BlockStatement" === nodeType || "CatchClause" === nodeType || "DoWhileStatement" === nodeType || "ForInStatement" === nodeType || "ForStatement" === nodeType || "FunctionDeclaration" === nodeType || "FunctionExpression" === nodeType || "Program" === nodeType || "ObjectMethod" === nodeType || "SwitchStatement" === nodeType || "WhileStatement" === nodeType || "ArrowFunctionExpression" === nodeType || "ForOfStatement" === nodeType || "ClassMethod" === nodeType) {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isBlock(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "Block" || "BlockStatement" === nodeType || "Program" === nodeType) {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isStatement(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "Statement" || "BlockStatement" === nodeType || "BreakStatement" === nodeType || "ContinueStatement" === nodeType || "DebuggerStatement" === nodeType || "DoWhileStatement" === nodeType || "EmptyStatement" === nodeType || "ExpressionStatement" === nodeType || "ForInStatement" === nodeType || "ForStatement" === nodeType || "FunctionDeclaration" === nodeType || "IfStatement" === nodeType || "LabeledStatement" === nodeType || "ReturnStatement" === nodeType || "SwitchStatement" === nodeType || "ThrowStatement" === nodeType || "TryStatement" === nodeType || "VariableDeclaration" === nodeType || "WhileStatement" === nodeType || "WithStatement" === nodeType || "ClassDeclaration" === nodeType || "ExportAllDeclaration" === nodeType || "ExportDefaultDeclaration" === nodeType || "ExportNamedDeclaration" === nodeType || "ForOfStatement" === nodeType || "ImportDeclaration" === nodeType || "DeclareClass" === nodeType || "DeclareFunction" === nodeType || "DeclareInterface" === nodeType || "DeclareModule" === nodeType || "DeclareModuleExports" === nodeType || "DeclareTypeAlias" === nodeType || "DeclareOpaqueType" === nodeType || "DeclareVariable" === nodeType || "DeclareExportDeclaration" === nodeType || "DeclareExportAllDeclaration" === nodeType || "InterfaceDeclaration" === nodeType || "OpaqueType" === nodeType || "TypeAlias" === nodeType || "TSDeclareFunction" === nodeType || "TSInterfaceDeclaration" === nodeType || "TSTypeAliasDeclaration" === nodeType || "TSEnumDeclaration" === nodeType || "TSModuleDeclaration" === nodeType || "TSImportEqualsDeclaration" === nodeType || "TSExportAssignment" === nodeType || "TSNamespaceExportDeclaration" === nodeType) {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isTerminatorless(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "Terminatorless" || "BreakStatement" === nodeType || "ContinueStatement" === nodeType || "ReturnStatement" === nodeType || "ThrowStatement" === nodeType || "YieldExpression" === nodeType || "AwaitExpression" === nodeType) {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isCompletionStatement(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "CompletionStatement" || "BreakStatement" === nodeType || "ContinueStatement" === nodeType || "ReturnStatement" === nodeType || "ThrowStatement" === nodeType) {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isConditional(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "Conditional" || "ConditionalExpression" === nodeType || "IfStatement" === nodeType) {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isLoop(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "Loop" || "DoWhileStatement" === nodeType || "ForInStatement" === nodeType || "ForStatement" === nodeType || "WhileStatement" === nodeType || "ForOfStatement" === nodeType) {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isWhile(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "While" || "DoWhileStatement" === nodeType || "WhileStatement" === nodeType) {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isExpressionWrapper(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "ExpressionWrapper" || "ExpressionStatement" === nodeType || "TypeCastExpression" === nodeType || "ParenthesizedExpression" === nodeType) {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isFor(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "For" || "ForInStatement" === nodeType || "ForStatement" === nodeType || "ForOfStatement" === nodeType) {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isForXStatement(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "ForXStatement" || "ForInStatement" === nodeType || "ForOfStatement" === nodeType) {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isFunction(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "Function" || "FunctionDeclaration" === nodeType || "FunctionExpression" === nodeType || "ObjectMethod" === nodeType || "ArrowFunctionExpression" === nodeType || "ClassMethod" === nodeType) {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isFunctionParent(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "FunctionParent" || "FunctionDeclaration" === nodeType || "FunctionExpression" === nodeType || "ObjectMethod" === nodeType || "ArrowFunctionExpression" === nodeType || "ClassMethod" === nodeType) {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isPureish(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "Pureish" || "FunctionDeclaration" === nodeType || "FunctionExpression" === nodeType || "StringLiteral" === nodeType || "NumericLiteral" === nodeType || "NullLiteral" === nodeType || "BooleanLiteral" === nodeType || "ArrowFunctionExpression" === nodeType || "ClassDeclaration" === nodeType || "ClassExpression" === nodeType || "BigIntLiteral" === nodeType) {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isDeclaration(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "Declaration" || "FunctionDeclaration" === nodeType || "VariableDeclaration" === nodeType || "ClassDeclaration" === nodeType || "ExportAllDeclaration" === nodeType || "ExportDefaultDeclaration" === nodeType || "ExportNamedDeclaration" === nodeType || "ImportDeclaration" === nodeType || "DeclareClass" === nodeType || "DeclareFunction" === nodeType || "DeclareInterface" === nodeType || "DeclareModule" === nodeType || "DeclareModuleExports" === nodeType || "DeclareTypeAlias" === nodeType || "DeclareOpaqueType" === nodeType || "DeclareVariable" === nodeType || "DeclareExportDeclaration" === nodeType || "DeclareExportAllDeclaration" === nodeType || "InterfaceDeclaration" === nodeType || "OpaqueType" === nodeType || "TypeAlias" === nodeType || "TSDeclareFunction" === nodeType || "TSInterfaceDeclaration" === nodeType || "TSTypeAliasDeclaration" === nodeType || "TSEnumDeclaration" === nodeType || "TSModuleDeclaration" === nodeType) {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isPatternLike(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "PatternLike" || "Identifier" === nodeType || "RestElement" === nodeType || "AssignmentPattern" === nodeType || "ArrayPattern" === nodeType || "ObjectPattern" === nodeType) {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isLVal(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "LVal" || "Identifier" === nodeType || "MemberExpression" === nodeType || "RestElement" === nodeType || "AssignmentPattern" === nodeType || "ArrayPattern" === nodeType || "ObjectPattern" === nodeType || "TSParameterProperty" === nodeType) {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isTSEntityName(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "TSEntityName" || "Identifier" === nodeType || "TSQualifiedName" === nodeType) {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isLiteral(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "Literal" || "StringLiteral" === nodeType || "NumericLiteral" === nodeType || "NullLiteral" === nodeType || "BooleanLiteral" === nodeType || "RegExpLiteral" === nodeType || "TemplateLiteral" === nodeType || "BigIntLiteral" === nodeType) {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isImmutable(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "Immutable" || "StringLiteral" === nodeType || "NumericLiteral" === nodeType || "NullLiteral" === nodeType || "BooleanLiteral" === nodeType || "JSXAttribute" === nodeType || "JSXClosingElement" === nodeType || "JSXElement" === nodeType || "JSXExpressionContainer" === nodeType || "JSXSpreadChild" === nodeType || "JSXOpeningElement" === nodeType || "JSXText" === nodeType || "JSXFragment" === nodeType || "JSXOpeningFragment" === nodeType || "JSXClosingFragment" === nodeType || "BigIntLiteral" === nodeType) {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isUserWhitespacable(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "UserWhitespacable" || "ObjectMethod" === nodeType || "ObjectProperty" === nodeType || "ObjectTypeInternalSlot" === nodeType || "ObjectTypeCallProperty" === nodeType || "ObjectTypeIndexer" === nodeType || "ObjectTypeProperty" === nodeType || "ObjectTypeSpreadProperty" === nodeType) {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isMethod(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "Method" || "ObjectMethod" === nodeType || "ClassMethod" === nodeType) {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isObjectMember(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "ObjectMember" || "ObjectMethod" === nodeType || "ObjectProperty" === nodeType) {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isProperty(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "Property" || "ObjectProperty" === nodeType || "ClassProperty" === nodeType || "ClassPrivateProperty" === nodeType) {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isUnaryLike(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "UnaryLike" || "UnaryExpression" === nodeType || "SpreadElement" === nodeType) {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isPattern(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "Pattern" || "AssignmentPattern" === nodeType || "ArrayPattern" === nodeType || "ObjectPattern" === nodeType) {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isClass(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "Class" || "ClassDeclaration" === nodeType || "ClassExpression" === nodeType) {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isModuleDeclaration(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "ModuleDeclaration" || "ExportAllDeclaration" === nodeType || "ExportDefaultDeclaration" === nodeType || "ExportNamedDeclaration" === nodeType || "ImportDeclaration" === nodeType) {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isExportDeclaration(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "ExportDeclaration" || "ExportAllDeclaration" === nodeType || "ExportDefaultDeclaration" === nodeType || "ExportNamedDeclaration" === nodeType) {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isModuleSpecifier(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "ModuleSpecifier" || "ExportSpecifier" === nodeType || "ImportDefaultSpecifier" === nodeType || "ImportNamespaceSpecifier" === nodeType || "ImportSpecifier" === nodeType || "ExportDefaultSpecifier" === nodeType || "ExportNamespaceSpecifier" === nodeType) {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isFlow(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "Flow" || "AnyTypeAnnotation" === nodeType || "ArrayTypeAnnotation" === nodeType || "BooleanTypeAnnotation" === nodeType || "BooleanLiteralTypeAnnotation" === nodeType || "NullLiteralTypeAnnotation" === nodeType || "ClassImplements" === nodeType || "DeclareClass" === nodeType || "DeclareFunction" === nodeType || "DeclareInterface" === nodeType || "DeclareModule" === nodeType || "DeclareModuleExports" === nodeType || "DeclareTypeAlias" === nodeType || "DeclareOpaqueType" === nodeType || "DeclareVariable" === nodeType || "DeclareExportDeclaration" === nodeType || "DeclareExportAllDeclaration" === nodeType || "DeclaredPredicate" === nodeType || "ExistsTypeAnnotation" === nodeType || "FunctionTypeAnnotation" === nodeType || "FunctionTypeParam" === nodeType || "GenericTypeAnnotation" === nodeType || "InferredPredicate" === nodeType || "InterfaceExtends" === nodeType || "InterfaceDeclaration" === nodeType || "InterfaceTypeAnnotation" === nodeType || "IntersectionTypeAnnotation" === nodeType || "MixedTypeAnnotation" === nodeType || "EmptyTypeAnnotation" === nodeType || "NullableTypeAnnotation" === nodeType || "NumberLiteralTypeAnnotation" === nodeType || "NumberTypeAnnotation" === nodeType || "ObjectTypeAnnotation" === nodeType || "ObjectTypeInternalSlot" === nodeType || "ObjectTypeCallProperty" === nodeType || "ObjectTypeIndexer" === nodeType || "ObjectTypeProperty" === nodeType || "ObjectTypeSpreadProperty" === nodeType || "OpaqueType" === nodeType || "QualifiedTypeIdentifier" === nodeType || "StringLiteralTypeAnnotation" === nodeType || "StringTypeAnnotation" === nodeType || "ThisTypeAnnotation" === nodeType || "TupleTypeAnnotation" === nodeType || "TypeofTypeAnnotation" === nodeType || "TypeAlias" === nodeType || "TypeAnnotation" === nodeType || "TypeCastExpression" === nodeType || "TypeParameter" === nodeType || "TypeParameterDeclaration" === nodeType || "TypeParameterInstantiation" === nodeType || "UnionTypeAnnotation" === nodeType || "Variance" === nodeType || "VoidTypeAnnotation" === nodeType) {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isFlowType(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "FlowType" || "AnyTypeAnnotation" === nodeType || "ArrayTypeAnnotation" === nodeType || "BooleanTypeAnnotation" === nodeType || "BooleanLiteralTypeAnnotation" === nodeType || "NullLiteralTypeAnnotation" === nodeType || "ExistsTypeAnnotation" === nodeType || "FunctionTypeAnnotation" === nodeType || "GenericTypeAnnotation" === nodeType || "InterfaceTypeAnnotation" === nodeType || "IntersectionTypeAnnotation" === nodeType || "MixedTypeAnnotation" === nodeType || "EmptyTypeAnnotation" === nodeType || "NullableTypeAnnotation" === nodeType || "NumberLiteralTypeAnnotation" === nodeType || "NumberTypeAnnotation" === nodeType || "ObjectTypeAnnotation" === nodeType || "StringLiteralTypeAnnotation" === nodeType || "StringTypeAnnotation" === nodeType || "ThisTypeAnnotation" === nodeType || "TupleTypeAnnotation" === nodeType || "TypeofTypeAnnotation" === nodeType || "UnionTypeAnnotation" === nodeType || "VoidTypeAnnotation" === nodeType) {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isFlowBaseAnnotation(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "FlowBaseAnnotation" || "AnyTypeAnnotation" === nodeType || "BooleanTypeAnnotation" === nodeType || "NullLiteralTypeAnnotation" === nodeType || "MixedTypeAnnotation" === nodeType || "EmptyTypeAnnotation" === nodeType || "NumberTypeAnnotation" === nodeType || "StringTypeAnnotation" === nodeType || "ThisTypeAnnotation" === nodeType || "VoidTypeAnnotation" === nodeType) {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isFlowDeclaration(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "FlowDeclaration" || "DeclareClass" === nodeType || "DeclareFunction" === nodeType || "DeclareInterface" === nodeType || "DeclareModule" === nodeType || "DeclareModuleExports" === nodeType || "DeclareTypeAlias" === nodeType || "DeclareOpaqueType" === nodeType || "DeclareVariable" === nodeType || "DeclareExportDeclaration" === nodeType || "DeclareExportAllDeclaration" === nodeType || "InterfaceDeclaration" === nodeType || "OpaqueType" === nodeType || "TypeAlias" === nodeType) {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isFlowPredicate(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "FlowPredicate" || "DeclaredPredicate" === nodeType || "InferredPredicate" === nodeType) {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isJSX(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "JSX" || "JSXAttribute" === nodeType || "JSXClosingElement" === nodeType || "JSXElement" === nodeType || "JSXEmptyExpression" === nodeType || "JSXExpressionContainer" === nodeType || "JSXSpreadChild" === nodeType || "JSXIdentifier" === nodeType || "JSXMemberExpression" === nodeType || "JSXNamespacedName" === nodeType || "JSXOpeningElement" === nodeType || "JSXSpreadAttribute" === nodeType || "JSXText" === nodeType || "JSXFragment" === nodeType || "JSXOpeningFragment" === nodeType || "JSXClosingFragment" === nodeType) {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isPrivate(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "Private" || "ClassPrivateProperty" === nodeType || "PrivateName" === nodeType) {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isTSTypeElement(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "TSTypeElement" || "TSCallSignatureDeclaration" === nodeType || "TSConstructSignatureDeclaration" === nodeType || "TSPropertySignature" === nodeType || "TSMethodSignature" === nodeType || "TSIndexSignature" === nodeType) {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isTSType(node, opts) {
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "TSType" || "TSAnyKeyword" === nodeType || "TSNumberKeyword" === nodeType || "TSObjectKeyword" === nodeType || "TSBooleanKeyword" === nodeType || "TSStringKeyword" === nodeType || "TSSymbolKeyword" === nodeType || "TSVoidKeyword" === nodeType || "TSUndefinedKeyword" === nodeType || "TSNullKeyword" === nodeType || "TSNeverKeyword" === nodeType || "TSThisType" === nodeType || "TSFunctionType" === nodeType || "TSConstructorType" === nodeType || "TSTypeReference" === nodeType || "TSTypePredicate" === nodeType || "TSTypeQuery" === nodeType || "TSTypeLiteral" === nodeType || "TSArrayType" === nodeType || "TSTupleType" === nodeType || "TSUnionType" === nodeType || "TSIntersectionType" === nodeType || "TSConditionalType" === nodeType || "TSInferType" === nodeType || "TSParenthesizedType" === nodeType || "TSTypeOperator" === nodeType || "TSIndexedAccessType" === nodeType || "TSMappedType" === nodeType || "TSLiteralType" === nodeType || "TSExpressionWithTypeArguments" === nodeType) {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isNumberLiteral(node, opts) {
	  console.trace("The node type NumberLiteral has been renamed to NumericLiteral");
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "NumberLiteral") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isRegexLiteral(node, opts) {
	  console.trace("The node type RegexLiteral has been renamed to RegExpLiteral");
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "RegexLiteral") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isRestProperty(node, opts) {
	  console.trace("The node type RestProperty has been renamed to RestElement");
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "RestProperty") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

	function isSpreadProperty(node, opts) {
	  console.trace("The node type SpreadProperty has been renamed to SpreadElement");
	  if (!node) return false;
	  const nodeType = node.type;

	  if (nodeType === "SpreadProperty") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return (0, _shallowEqual.default)(node, opts);
	    }
	  }

	  return false;
	}

/***/ }),
/* 9 */
/***/ (function(module, exports) {

	module.exports = require("babel-runtime/helpers/extends");

/***/ }),
/* 10 */
/***/ (function(module, exports) {

	module.exports = require("babel-runtime/helpers/toConsumableArray");

/***/ }),
/* 11 */
/***/ (function(module, exports) {

	module.exports = require("fs");

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.arrayExpression = exports.ArrayExpression = ArrayExpression;
	exports.assignmentExpression = exports.AssignmentExpression = AssignmentExpression;
	exports.binaryExpression = exports.BinaryExpression = BinaryExpression;
	exports.interpreterDirective = exports.InterpreterDirective = InterpreterDirective;
	exports.directive = exports.Directive = Directive;
	exports.directiveLiteral = exports.DirectiveLiteral = DirectiveLiteral;
	exports.blockStatement = exports.BlockStatement = BlockStatement;
	exports.breakStatement = exports.BreakStatement = BreakStatement;
	exports.callExpression = exports.CallExpression = CallExpression;
	exports.catchClause = exports.CatchClause = CatchClause;
	exports.conditionalExpression = exports.ConditionalExpression = ConditionalExpression;
	exports.continueStatement = exports.ContinueStatement = ContinueStatement;
	exports.debuggerStatement = exports.DebuggerStatement = DebuggerStatement;
	exports.doWhileStatement = exports.DoWhileStatement = DoWhileStatement;
	exports.emptyStatement = exports.EmptyStatement = EmptyStatement;
	exports.expressionStatement = exports.ExpressionStatement = ExpressionStatement;
	exports.file = exports.File = File;
	exports.forInStatement = exports.ForInStatement = ForInStatement;
	exports.forStatement = exports.ForStatement = ForStatement;
	exports.functionDeclaration = exports.FunctionDeclaration = FunctionDeclaration;
	exports.functionExpression = exports.FunctionExpression = FunctionExpression;
	exports.identifier = exports.Identifier = Identifier;
	exports.ifStatement = exports.IfStatement = IfStatement;
	exports.labeledStatement = exports.LabeledStatement = LabeledStatement;
	exports.stringLiteral = exports.StringLiteral = StringLiteral;
	exports.numericLiteral = exports.NumericLiteral = NumericLiteral;
	exports.nullLiteral = exports.NullLiteral = NullLiteral;
	exports.booleanLiteral = exports.BooleanLiteral = BooleanLiteral;
	exports.regExpLiteral = exports.RegExpLiteral = RegExpLiteral;
	exports.logicalExpression = exports.LogicalExpression = LogicalExpression;
	exports.memberExpression = exports.MemberExpression = MemberExpression;
	exports.newExpression = exports.NewExpression = NewExpression;
	exports.program = exports.Program = Program;
	exports.objectExpression = exports.ObjectExpression = ObjectExpression;
	exports.objectMethod = exports.ObjectMethod = ObjectMethod;
	exports.objectProperty = exports.ObjectProperty = ObjectProperty;
	exports.restElement = exports.RestElement = RestElement;
	exports.returnStatement = exports.ReturnStatement = ReturnStatement;
	exports.sequenceExpression = exports.SequenceExpression = SequenceExpression;
	exports.switchCase = exports.SwitchCase = SwitchCase;
	exports.switchStatement = exports.SwitchStatement = SwitchStatement;
	exports.thisExpression = exports.ThisExpression = ThisExpression;
	exports.throwStatement = exports.ThrowStatement = ThrowStatement;
	exports.tryStatement = exports.TryStatement = TryStatement;
	exports.unaryExpression = exports.UnaryExpression = UnaryExpression;
	exports.updateExpression = exports.UpdateExpression = UpdateExpression;
	exports.variableDeclaration = exports.VariableDeclaration = VariableDeclaration;
	exports.variableDeclarator = exports.VariableDeclarator = VariableDeclarator;
	exports.whileStatement = exports.WhileStatement = WhileStatement;
	exports.withStatement = exports.WithStatement = WithStatement;
	exports.assignmentPattern = exports.AssignmentPattern = AssignmentPattern;
	exports.arrayPattern = exports.ArrayPattern = ArrayPattern;
	exports.arrowFunctionExpression = exports.ArrowFunctionExpression = ArrowFunctionExpression;
	exports.classBody = exports.ClassBody = ClassBody;
	exports.classDeclaration = exports.ClassDeclaration = ClassDeclaration;
	exports.classExpression = exports.ClassExpression = ClassExpression;
	exports.exportAllDeclaration = exports.ExportAllDeclaration = ExportAllDeclaration;
	exports.exportDefaultDeclaration = exports.ExportDefaultDeclaration = ExportDefaultDeclaration;
	exports.exportNamedDeclaration = exports.ExportNamedDeclaration = ExportNamedDeclaration;
	exports.exportSpecifier = exports.ExportSpecifier = ExportSpecifier;
	exports.forOfStatement = exports.ForOfStatement = ForOfStatement;
	exports.importDeclaration = exports.ImportDeclaration = ImportDeclaration;
	exports.importDefaultSpecifier = exports.ImportDefaultSpecifier = ImportDefaultSpecifier;
	exports.importNamespaceSpecifier = exports.ImportNamespaceSpecifier = ImportNamespaceSpecifier;
	exports.importSpecifier = exports.ImportSpecifier = ImportSpecifier;
	exports.metaProperty = exports.MetaProperty = MetaProperty;
	exports.classMethod = exports.ClassMethod = ClassMethod;
	exports.objectPattern = exports.ObjectPattern = ObjectPattern;
	exports.spreadElement = exports.SpreadElement = SpreadElement;
	exports.super = exports.Super = Super;
	exports.taggedTemplateExpression = exports.TaggedTemplateExpression = TaggedTemplateExpression;
	exports.templateElement = exports.TemplateElement = TemplateElement;
	exports.templateLiteral = exports.TemplateLiteral = TemplateLiteral;
	exports.yieldExpression = exports.YieldExpression = YieldExpression;
	exports.anyTypeAnnotation = exports.AnyTypeAnnotation = AnyTypeAnnotation;
	exports.arrayTypeAnnotation = exports.ArrayTypeAnnotation = ArrayTypeAnnotation;
	exports.booleanTypeAnnotation = exports.BooleanTypeAnnotation = BooleanTypeAnnotation;
	exports.booleanLiteralTypeAnnotation = exports.BooleanLiteralTypeAnnotation = BooleanLiteralTypeAnnotation;
	exports.nullLiteralTypeAnnotation = exports.NullLiteralTypeAnnotation = NullLiteralTypeAnnotation;
	exports.classImplements = exports.ClassImplements = ClassImplements;
	exports.declareClass = exports.DeclareClass = DeclareClass;
	exports.declareFunction = exports.DeclareFunction = DeclareFunction;
	exports.declareInterface = exports.DeclareInterface = DeclareInterface;
	exports.declareModule = exports.DeclareModule = DeclareModule;
	exports.declareModuleExports = exports.DeclareModuleExports = DeclareModuleExports;
	exports.declareTypeAlias = exports.DeclareTypeAlias = DeclareTypeAlias;
	exports.declareOpaqueType = exports.DeclareOpaqueType = DeclareOpaqueType;
	exports.declareVariable = exports.DeclareVariable = DeclareVariable;
	exports.declareExportDeclaration = exports.DeclareExportDeclaration = DeclareExportDeclaration;
	exports.declareExportAllDeclaration = exports.DeclareExportAllDeclaration = DeclareExportAllDeclaration;
	exports.declaredPredicate = exports.DeclaredPredicate = DeclaredPredicate;
	exports.existsTypeAnnotation = exports.ExistsTypeAnnotation = ExistsTypeAnnotation;
	exports.functionTypeAnnotation = exports.FunctionTypeAnnotation = FunctionTypeAnnotation;
	exports.functionTypeParam = exports.FunctionTypeParam = FunctionTypeParam;
	exports.genericTypeAnnotation = exports.GenericTypeAnnotation = GenericTypeAnnotation;
	exports.inferredPredicate = exports.InferredPredicate = InferredPredicate;
	exports.interfaceExtends = exports.InterfaceExtends = InterfaceExtends;
	exports.interfaceDeclaration = exports.InterfaceDeclaration = InterfaceDeclaration;
	exports.interfaceTypeAnnotation = exports.InterfaceTypeAnnotation = InterfaceTypeAnnotation;
	exports.intersectionTypeAnnotation = exports.IntersectionTypeAnnotation = IntersectionTypeAnnotation;
	exports.mixedTypeAnnotation = exports.MixedTypeAnnotation = MixedTypeAnnotation;
	exports.emptyTypeAnnotation = exports.EmptyTypeAnnotation = EmptyTypeAnnotation;
	exports.nullableTypeAnnotation = exports.NullableTypeAnnotation = NullableTypeAnnotation;
	exports.numberLiteralTypeAnnotation = exports.NumberLiteralTypeAnnotation = NumberLiteralTypeAnnotation;
	exports.numberTypeAnnotation = exports.NumberTypeAnnotation = NumberTypeAnnotation;
	exports.objectTypeAnnotation = exports.ObjectTypeAnnotation = ObjectTypeAnnotation;
	exports.objectTypeInternalSlot = exports.ObjectTypeInternalSlot = ObjectTypeInternalSlot;
	exports.objectTypeCallProperty = exports.ObjectTypeCallProperty = ObjectTypeCallProperty;
	exports.objectTypeIndexer = exports.ObjectTypeIndexer = ObjectTypeIndexer;
	exports.objectTypeProperty = exports.ObjectTypeProperty = ObjectTypeProperty;
	exports.objectTypeSpreadProperty = exports.ObjectTypeSpreadProperty = ObjectTypeSpreadProperty;
	exports.opaqueType = exports.OpaqueType = OpaqueType;
	exports.qualifiedTypeIdentifier = exports.QualifiedTypeIdentifier = QualifiedTypeIdentifier;
	exports.stringLiteralTypeAnnotation = exports.StringLiteralTypeAnnotation = StringLiteralTypeAnnotation;
	exports.stringTypeAnnotation = exports.StringTypeAnnotation = StringTypeAnnotation;
	exports.thisTypeAnnotation = exports.ThisTypeAnnotation = ThisTypeAnnotation;
	exports.tupleTypeAnnotation = exports.TupleTypeAnnotation = TupleTypeAnnotation;
	exports.typeofTypeAnnotation = exports.TypeofTypeAnnotation = TypeofTypeAnnotation;
	exports.typeAlias = exports.TypeAlias = TypeAlias;
	exports.typeAnnotation = exports.TypeAnnotation = TypeAnnotation;
	exports.typeCastExpression = exports.TypeCastExpression = TypeCastExpression;
	exports.typeParameter = exports.TypeParameter = TypeParameter;
	exports.typeParameterDeclaration = exports.TypeParameterDeclaration = TypeParameterDeclaration;
	exports.typeParameterInstantiation = exports.TypeParameterInstantiation = TypeParameterInstantiation;
	exports.unionTypeAnnotation = exports.UnionTypeAnnotation = UnionTypeAnnotation;
	exports.variance = exports.Variance = Variance;
	exports.voidTypeAnnotation = exports.VoidTypeAnnotation = VoidTypeAnnotation;
	exports.jSXAttribute = exports.jsxAttribute = exports.JSXAttribute = JSXAttribute;
	exports.jSXClosingElement = exports.jsxClosingElement = exports.JSXClosingElement = JSXClosingElement;
	exports.jSXElement = exports.jsxElement = exports.JSXElement = JSXElement;
	exports.jSXEmptyExpression = exports.jsxEmptyExpression = exports.JSXEmptyExpression = JSXEmptyExpression;
	exports.jSXExpressionContainer = exports.jsxExpressionContainer = exports.JSXExpressionContainer = JSXExpressionContainer;
	exports.jSXSpreadChild = exports.jsxSpreadChild = exports.JSXSpreadChild = JSXSpreadChild;
	exports.jSXIdentifier = exports.jsxIdentifier = exports.JSXIdentifier = JSXIdentifier;
	exports.jSXMemberExpression = exports.jsxMemberExpression = exports.JSXMemberExpression = JSXMemberExpression;
	exports.jSXNamespacedName = exports.jsxNamespacedName = exports.JSXNamespacedName = JSXNamespacedName;
	exports.jSXOpeningElement = exports.jsxOpeningElement = exports.JSXOpeningElement = JSXOpeningElement;
	exports.jSXSpreadAttribute = exports.jsxSpreadAttribute = exports.JSXSpreadAttribute = JSXSpreadAttribute;
	exports.jSXText = exports.jsxText = exports.JSXText = JSXText;
	exports.jSXFragment = exports.jsxFragment = exports.JSXFragment = JSXFragment;
	exports.jSXOpeningFragment = exports.jsxOpeningFragment = exports.JSXOpeningFragment = JSXOpeningFragment;
	exports.jSXClosingFragment = exports.jsxClosingFragment = exports.JSXClosingFragment = JSXClosingFragment;
	exports.noop = exports.Noop = Noop;
	exports.parenthesizedExpression = exports.ParenthesizedExpression = ParenthesizedExpression;
	exports.awaitExpression = exports.AwaitExpression = AwaitExpression;
	exports.bindExpression = exports.BindExpression = BindExpression;
	exports.classProperty = exports.ClassProperty = ClassProperty;
	exports.optionalMemberExpression = exports.OptionalMemberExpression = OptionalMemberExpression;
	exports.optionalCallExpression = exports.OptionalCallExpression = OptionalCallExpression;
	exports.classPrivateProperty = exports.ClassPrivateProperty = ClassPrivateProperty;
	exports.import = exports.Import = Import;
	exports.decorator = exports.Decorator = Decorator;
	exports.doExpression = exports.DoExpression = DoExpression;
	exports.exportDefaultSpecifier = exports.ExportDefaultSpecifier = ExportDefaultSpecifier;
	exports.exportNamespaceSpecifier = exports.ExportNamespaceSpecifier = ExportNamespaceSpecifier;
	exports.privateName = exports.PrivateName = PrivateName;
	exports.bigIntLiteral = exports.BigIntLiteral = BigIntLiteral;
	exports.tSParameterProperty = exports.tsParameterProperty = exports.TSParameterProperty = TSParameterProperty;
	exports.tSDeclareFunction = exports.tsDeclareFunction = exports.TSDeclareFunction = TSDeclareFunction;
	exports.tSDeclareMethod = exports.tsDeclareMethod = exports.TSDeclareMethod = TSDeclareMethod;
	exports.tSQualifiedName = exports.tsQualifiedName = exports.TSQualifiedName = TSQualifiedName;
	exports.tSCallSignatureDeclaration = exports.tsCallSignatureDeclaration = exports.TSCallSignatureDeclaration = TSCallSignatureDeclaration;
	exports.tSConstructSignatureDeclaration = exports.tsConstructSignatureDeclaration = exports.TSConstructSignatureDeclaration = TSConstructSignatureDeclaration;
	exports.tSPropertySignature = exports.tsPropertySignature = exports.TSPropertySignature = TSPropertySignature;
	exports.tSMethodSignature = exports.tsMethodSignature = exports.TSMethodSignature = TSMethodSignature;
	exports.tSIndexSignature = exports.tsIndexSignature = exports.TSIndexSignature = TSIndexSignature;
	exports.tSAnyKeyword = exports.tsAnyKeyword = exports.TSAnyKeyword = TSAnyKeyword;
	exports.tSNumberKeyword = exports.tsNumberKeyword = exports.TSNumberKeyword = TSNumberKeyword;
	exports.tSObjectKeyword = exports.tsObjectKeyword = exports.TSObjectKeyword = TSObjectKeyword;
	exports.tSBooleanKeyword = exports.tsBooleanKeyword = exports.TSBooleanKeyword = TSBooleanKeyword;
	exports.tSStringKeyword = exports.tsStringKeyword = exports.TSStringKeyword = TSStringKeyword;
	exports.tSSymbolKeyword = exports.tsSymbolKeyword = exports.TSSymbolKeyword = TSSymbolKeyword;
	exports.tSVoidKeyword = exports.tsVoidKeyword = exports.TSVoidKeyword = TSVoidKeyword;
	exports.tSUndefinedKeyword = exports.tsUndefinedKeyword = exports.TSUndefinedKeyword = TSUndefinedKeyword;
	exports.tSNullKeyword = exports.tsNullKeyword = exports.TSNullKeyword = TSNullKeyword;
	exports.tSNeverKeyword = exports.tsNeverKeyword = exports.TSNeverKeyword = TSNeverKeyword;
	exports.tSThisType = exports.tsThisType = exports.TSThisType = TSThisType;
	exports.tSFunctionType = exports.tsFunctionType = exports.TSFunctionType = TSFunctionType;
	exports.tSConstructorType = exports.tsConstructorType = exports.TSConstructorType = TSConstructorType;
	exports.tSTypeReference = exports.tsTypeReference = exports.TSTypeReference = TSTypeReference;
	exports.tSTypePredicate = exports.tsTypePredicate = exports.TSTypePredicate = TSTypePredicate;
	exports.tSTypeQuery = exports.tsTypeQuery = exports.TSTypeQuery = TSTypeQuery;
	exports.tSTypeLiteral = exports.tsTypeLiteral = exports.TSTypeLiteral = TSTypeLiteral;
	exports.tSArrayType = exports.tsArrayType = exports.TSArrayType = TSArrayType;
	exports.tSTupleType = exports.tsTupleType = exports.TSTupleType = TSTupleType;
	exports.tSUnionType = exports.tsUnionType = exports.TSUnionType = TSUnionType;
	exports.tSIntersectionType = exports.tsIntersectionType = exports.TSIntersectionType = TSIntersectionType;
	exports.tSConditionalType = exports.tsConditionalType = exports.TSConditionalType = TSConditionalType;
	exports.tSInferType = exports.tsInferType = exports.TSInferType = TSInferType;
	exports.tSParenthesizedType = exports.tsParenthesizedType = exports.TSParenthesizedType = TSParenthesizedType;
	exports.tSTypeOperator = exports.tsTypeOperator = exports.TSTypeOperator = TSTypeOperator;
	exports.tSIndexedAccessType = exports.tsIndexedAccessType = exports.TSIndexedAccessType = TSIndexedAccessType;
	exports.tSMappedType = exports.tsMappedType = exports.TSMappedType = TSMappedType;
	exports.tSLiteralType = exports.tsLiteralType = exports.TSLiteralType = TSLiteralType;
	exports.tSExpressionWithTypeArguments = exports.tsExpressionWithTypeArguments = exports.TSExpressionWithTypeArguments = TSExpressionWithTypeArguments;
	exports.tSInterfaceDeclaration = exports.tsInterfaceDeclaration = exports.TSInterfaceDeclaration = TSInterfaceDeclaration;
	exports.tSInterfaceBody = exports.tsInterfaceBody = exports.TSInterfaceBody = TSInterfaceBody;
	exports.tSTypeAliasDeclaration = exports.tsTypeAliasDeclaration = exports.TSTypeAliasDeclaration = TSTypeAliasDeclaration;
	exports.tSAsExpression = exports.tsAsExpression = exports.TSAsExpression = TSAsExpression;
	exports.tSTypeAssertion = exports.tsTypeAssertion = exports.TSTypeAssertion = TSTypeAssertion;
	exports.tSEnumDeclaration = exports.tsEnumDeclaration = exports.TSEnumDeclaration = TSEnumDeclaration;
	exports.tSEnumMember = exports.tsEnumMember = exports.TSEnumMember = TSEnumMember;
	exports.tSModuleDeclaration = exports.tsModuleDeclaration = exports.TSModuleDeclaration = TSModuleDeclaration;
	exports.tSModuleBlock = exports.tsModuleBlock = exports.TSModuleBlock = TSModuleBlock;
	exports.tSImportEqualsDeclaration = exports.tsImportEqualsDeclaration = exports.TSImportEqualsDeclaration = TSImportEqualsDeclaration;
	exports.tSExternalModuleReference = exports.tsExternalModuleReference = exports.TSExternalModuleReference = TSExternalModuleReference;
	exports.tSNonNullExpression = exports.tsNonNullExpression = exports.TSNonNullExpression = TSNonNullExpression;
	exports.tSExportAssignment = exports.tsExportAssignment = exports.TSExportAssignment = TSExportAssignment;
	exports.tSNamespaceExportDeclaration = exports.tsNamespaceExportDeclaration = exports.TSNamespaceExportDeclaration = TSNamespaceExportDeclaration;
	exports.tSTypeAnnotation = exports.tsTypeAnnotation = exports.TSTypeAnnotation = TSTypeAnnotation;
	exports.tSTypeParameterInstantiation = exports.tsTypeParameterInstantiation = exports.TSTypeParameterInstantiation = TSTypeParameterInstantiation;
	exports.tSTypeParameterDeclaration = exports.tsTypeParameterDeclaration = exports.TSTypeParameterDeclaration = TSTypeParameterDeclaration;
	exports.tSTypeParameter = exports.tsTypeParameter = exports.TSTypeParameter = TSTypeParameter;
	exports.numberLiteral = exports.NumberLiteral = NumberLiteral;
	exports.regexLiteral = exports.RegexLiteral = RegexLiteral;
	exports.restProperty = exports.RestProperty = RestProperty;
	exports.spreadProperty = exports.SpreadProperty = SpreadProperty;

	var _builder = _interopRequireDefault(__webpack_require__(103));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function ArrayExpression(...args) {
	  return (0, _builder.default)("ArrayExpression", ...args);
	}

	function AssignmentExpression(...args) {
	  return (0, _builder.default)("AssignmentExpression", ...args);
	}

	function BinaryExpression(...args) {
	  return (0, _builder.default)("BinaryExpression", ...args);
	}

	function InterpreterDirective(...args) {
	  return (0, _builder.default)("InterpreterDirective", ...args);
	}

	function Directive(...args) {
	  return (0, _builder.default)("Directive", ...args);
	}

	function DirectiveLiteral(...args) {
	  return (0, _builder.default)("DirectiveLiteral", ...args);
	}

	function BlockStatement(...args) {
	  return (0, _builder.default)("BlockStatement", ...args);
	}

	function BreakStatement(...args) {
	  return (0, _builder.default)("BreakStatement", ...args);
	}

	function CallExpression(...args) {
	  return (0, _builder.default)("CallExpression", ...args);
	}

	function CatchClause(...args) {
	  return (0, _builder.default)("CatchClause", ...args);
	}

	function ConditionalExpression(...args) {
	  return (0, _builder.default)("ConditionalExpression", ...args);
	}

	function ContinueStatement(...args) {
	  return (0, _builder.default)("ContinueStatement", ...args);
	}

	function DebuggerStatement(...args) {
	  return (0, _builder.default)("DebuggerStatement", ...args);
	}

	function DoWhileStatement(...args) {
	  return (0, _builder.default)("DoWhileStatement", ...args);
	}

	function EmptyStatement(...args) {
	  return (0, _builder.default)("EmptyStatement", ...args);
	}

	function ExpressionStatement(...args) {
	  return (0, _builder.default)("ExpressionStatement", ...args);
	}

	function File(...args) {
	  return (0, _builder.default)("File", ...args);
	}

	function ForInStatement(...args) {
	  return (0, _builder.default)("ForInStatement", ...args);
	}

	function ForStatement(...args) {
	  return (0, _builder.default)("ForStatement", ...args);
	}

	function FunctionDeclaration(...args) {
	  return (0, _builder.default)("FunctionDeclaration", ...args);
	}

	function FunctionExpression(...args) {
	  return (0, _builder.default)("FunctionExpression", ...args);
	}

	function Identifier(...args) {
	  return (0, _builder.default)("Identifier", ...args);
	}

	function IfStatement(...args) {
	  return (0, _builder.default)("IfStatement", ...args);
	}

	function LabeledStatement(...args) {
	  return (0, _builder.default)("LabeledStatement", ...args);
	}

	function StringLiteral(...args) {
	  return (0, _builder.default)("StringLiteral", ...args);
	}

	function NumericLiteral(...args) {
	  return (0, _builder.default)("NumericLiteral", ...args);
	}

	function NullLiteral(...args) {
	  return (0, _builder.default)("NullLiteral", ...args);
	}

	function BooleanLiteral(...args) {
	  return (0, _builder.default)("BooleanLiteral", ...args);
	}

	function RegExpLiteral(...args) {
	  return (0, _builder.default)("RegExpLiteral", ...args);
	}

	function LogicalExpression(...args) {
	  return (0, _builder.default)("LogicalExpression", ...args);
	}

	function MemberExpression(...args) {
	  return (0, _builder.default)("MemberExpression", ...args);
	}

	function NewExpression(...args) {
	  return (0, _builder.default)("NewExpression", ...args);
	}

	function Program(...args) {
	  return (0, _builder.default)("Program", ...args);
	}

	function ObjectExpression(...args) {
	  return (0, _builder.default)("ObjectExpression", ...args);
	}

	function ObjectMethod(...args) {
	  return (0, _builder.default)("ObjectMethod", ...args);
	}

	function ObjectProperty(...args) {
	  return (0, _builder.default)("ObjectProperty", ...args);
	}

	function RestElement(...args) {
	  return (0, _builder.default)("RestElement", ...args);
	}

	function ReturnStatement(...args) {
	  return (0, _builder.default)("ReturnStatement", ...args);
	}

	function SequenceExpression(...args) {
	  return (0, _builder.default)("SequenceExpression", ...args);
	}

	function SwitchCase(...args) {
	  return (0, _builder.default)("SwitchCase", ...args);
	}

	function SwitchStatement(...args) {
	  return (0, _builder.default)("SwitchStatement", ...args);
	}

	function ThisExpression(...args) {
	  return (0, _builder.default)("ThisExpression", ...args);
	}

	function ThrowStatement(...args) {
	  return (0, _builder.default)("ThrowStatement", ...args);
	}

	function TryStatement(...args) {
	  return (0, _builder.default)("TryStatement", ...args);
	}

	function UnaryExpression(...args) {
	  return (0, _builder.default)("UnaryExpression", ...args);
	}

	function UpdateExpression(...args) {
	  return (0, _builder.default)("UpdateExpression", ...args);
	}

	function VariableDeclaration(...args) {
	  return (0, _builder.default)("VariableDeclaration", ...args);
	}

	function VariableDeclarator(...args) {
	  return (0, _builder.default)("VariableDeclarator", ...args);
	}

	function WhileStatement(...args) {
	  return (0, _builder.default)("WhileStatement", ...args);
	}

	function WithStatement(...args) {
	  return (0, _builder.default)("WithStatement", ...args);
	}

	function AssignmentPattern(...args) {
	  return (0, _builder.default)("AssignmentPattern", ...args);
	}

	function ArrayPattern(...args) {
	  return (0, _builder.default)("ArrayPattern", ...args);
	}

	function ArrowFunctionExpression(...args) {
	  return (0, _builder.default)("ArrowFunctionExpression", ...args);
	}

	function ClassBody(...args) {
	  return (0, _builder.default)("ClassBody", ...args);
	}

	function ClassDeclaration(...args) {
	  return (0, _builder.default)("ClassDeclaration", ...args);
	}

	function ClassExpression(...args) {
	  return (0, _builder.default)("ClassExpression", ...args);
	}

	function ExportAllDeclaration(...args) {
	  return (0, _builder.default)("ExportAllDeclaration", ...args);
	}

	function ExportDefaultDeclaration(...args) {
	  return (0, _builder.default)("ExportDefaultDeclaration", ...args);
	}

	function ExportNamedDeclaration(...args) {
	  return (0, _builder.default)("ExportNamedDeclaration", ...args);
	}

	function ExportSpecifier(...args) {
	  return (0, _builder.default)("ExportSpecifier", ...args);
	}

	function ForOfStatement(...args) {
	  return (0, _builder.default)("ForOfStatement", ...args);
	}

	function ImportDeclaration(...args) {
	  return (0, _builder.default)("ImportDeclaration", ...args);
	}

	function ImportDefaultSpecifier(...args) {
	  return (0, _builder.default)("ImportDefaultSpecifier", ...args);
	}

	function ImportNamespaceSpecifier(...args) {
	  return (0, _builder.default)("ImportNamespaceSpecifier", ...args);
	}

	function ImportSpecifier(...args) {
	  return (0, _builder.default)("ImportSpecifier", ...args);
	}

	function MetaProperty(...args) {
	  return (0, _builder.default)("MetaProperty", ...args);
	}

	function ClassMethod(...args) {
	  return (0, _builder.default)("ClassMethod", ...args);
	}

	function ObjectPattern(...args) {
	  return (0, _builder.default)("ObjectPattern", ...args);
	}

	function SpreadElement(...args) {
	  return (0, _builder.default)("SpreadElement", ...args);
	}

	function Super(...args) {
	  return (0, _builder.default)("Super", ...args);
	}

	function TaggedTemplateExpression(...args) {
	  return (0, _builder.default)("TaggedTemplateExpression", ...args);
	}

	function TemplateElement(...args) {
	  return (0, _builder.default)("TemplateElement", ...args);
	}

	function TemplateLiteral(...args) {
	  return (0, _builder.default)("TemplateLiteral", ...args);
	}

	function YieldExpression(...args) {
	  return (0, _builder.default)("YieldExpression", ...args);
	}

	function AnyTypeAnnotation(...args) {
	  return (0, _builder.default)("AnyTypeAnnotation", ...args);
	}

	function ArrayTypeAnnotation(...args) {
	  return (0, _builder.default)("ArrayTypeAnnotation", ...args);
	}

	function BooleanTypeAnnotation(...args) {
	  return (0, _builder.default)("BooleanTypeAnnotation", ...args);
	}

	function BooleanLiteralTypeAnnotation(...args) {
	  return (0, _builder.default)("BooleanLiteralTypeAnnotation", ...args);
	}

	function NullLiteralTypeAnnotation(...args) {
	  return (0, _builder.default)("NullLiteralTypeAnnotation", ...args);
	}

	function ClassImplements(...args) {
	  return (0, _builder.default)("ClassImplements", ...args);
	}

	function DeclareClass(...args) {
	  return (0, _builder.default)("DeclareClass", ...args);
	}

	function DeclareFunction(...args) {
	  return (0, _builder.default)("DeclareFunction", ...args);
	}

	function DeclareInterface(...args) {
	  return (0, _builder.default)("DeclareInterface", ...args);
	}

	function DeclareModule(...args) {
	  return (0, _builder.default)("DeclareModule", ...args);
	}

	function DeclareModuleExports(...args) {
	  return (0, _builder.default)("DeclareModuleExports", ...args);
	}

	function DeclareTypeAlias(...args) {
	  return (0, _builder.default)("DeclareTypeAlias", ...args);
	}

	function DeclareOpaqueType(...args) {
	  return (0, _builder.default)("DeclareOpaqueType", ...args);
	}

	function DeclareVariable(...args) {
	  return (0, _builder.default)("DeclareVariable", ...args);
	}

	function DeclareExportDeclaration(...args) {
	  return (0, _builder.default)("DeclareExportDeclaration", ...args);
	}

	function DeclareExportAllDeclaration(...args) {
	  return (0, _builder.default)("DeclareExportAllDeclaration", ...args);
	}

	function DeclaredPredicate(...args) {
	  return (0, _builder.default)("DeclaredPredicate", ...args);
	}

	function ExistsTypeAnnotation(...args) {
	  return (0, _builder.default)("ExistsTypeAnnotation", ...args);
	}

	function FunctionTypeAnnotation(...args) {
	  return (0, _builder.default)("FunctionTypeAnnotation", ...args);
	}

	function FunctionTypeParam(...args) {
	  return (0, _builder.default)("FunctionTypeParam", ...args);
	}

	function GenericTypeAnnotation(...args) {
	  return (0, _builder.default)("GenericTypeAnnotation", ...args);
	}

	function InferredPredicate(...args) {
	  return (0, _builder.default)("InferredPredicate", ...args);
	}

	function InterfaceExtends(...args) {
	  return (0, _builder.default)("InterfaceExtends", ...args);
	}

	function InterfaceDeclaration(...args) {
	  return (0, _builder.default)("InterfaceDeclaration", ...args);
	}

	function InterfaceTypeAnnotation(...args) {
	  return (0, _builder.default)("InterfaceTypeAnnotation", ...args);
	}

	function IntersectionTypeAnnotation(...args) {
	  return (0, _builder.default)("IntersectionTypeAnnotation", ...args);
	}

	function MixedTypeAnnotation(...args) {
	  return (0, _builder.default)("MixedTypeAnnotation", ...args);
	}

	function EmptyTypeAnnotation(...args) {
	  return (0, _builder.default)("EmptyTypeAnnotation", ...args);
	}

	function NullableTypeAnnotation(...args) {
	  return (0, _builder.default)("NullableTypeAnnotation", ...args);
	}

	function NumberLiteralTypeAnnotation(...args) {
	  return (0, _builder.default)("NumberLiteralTypeAnnotation", ...args);
	}

	function NumberTypeAnnotation(...args) {
	  return (0, _builder.default)("NumberTypeAnnotation", ...args);
	}

	function ObjectTypeAnnotation(...args) {
	  return (0, _builder.default)("ObjectTypeAnnotation", ...args);
	}

	function ObjectTypeInternalSlot(...args) {
	  return (0, _builder.default)("ObjectTypeInternalSlot", ...args);
	}

	function ObjectTypeCallProperty(...args) {
	  return (0, _builder.default)("ObjectTypeCallProperty", ...args);
	}

	function ObjectTypeIndexer(...args) {
	  return (0, _builder.default)("ObjectTypeIndexer", ...args);
	}

	function ObjectTypeProperty(...args) {
	  return (0, _builder.default)("ObjectTypeProperty", ...args);
	}

	function ObjectTypeSpreadProperty(...args) {
	  return (0, _builder.default)("ObjectTypeSpreadProperty", ...args);
	}

	function OpaqueType(...args) {
	  return (0, _builder.default)("OpaqueType", ...args);
	}

	function QualifiedTypeIdentifier(...args) {
	  return (0, _builder.default)("QualifiedTypeIdentifier", ...args);
	}

	function StringLiteralTypeAnnotation(...args) {
	  return (0, _builder.default)("StringLiteralTypeAnnotation", ...args);
	}

	function StringTypeAnnotation(...args) {
	  return (0, _builder.default)("StringTypeAnnotation", ...args);
	}

	function ThisTypeAnnotation(...args) {
	  return (0, _builder.default)("ThisTypeAnnotation", ...args);
	}

	function TupleTypeAnnotation(...args) {
	  return (0, _builder.default)("TupleTypeAnnotation", ...args);
	}

	function TypeofTypeAnnotation(...args) {
	  return (0, _builder.default)("TypeofTypeAnnotation", ...args);
	}

	function TypeAlias(...args) {
	  return (0, _builder.default)("TypeAlias", ...args);
	}

	function TypeAnnotation(...args) {
	  return (0, _builder.default)("TypeAnnotation", ...args);
	}

	function TypeCastExpression(...args) {
	  return (0, _builder.default)("TypeCastExpression", ...args);
	}

	function TypeParameter(...args) {
	  return (0, _builder.default)("TypeParameter", ...args);
	}

	function TypeParameterDeclaration(...args) {
	  return (0, _builder.default)("TypeParameterDeclaration", ...args);
	}

	function TypeParameterInstantiation(...args) {
	  return (0, _builder.default)("TypeParameterInstantiation", ...args);
	}

	function UnionTypeAnnotation(...args) {
	  return (0, _builder.default)("UnionTypeAnnotation", ...args);
	}

	function Variance(...args) {
	  return (0, _builder.default)("Variance", ...args);
	}

	function VoidTypeAnnotation(...args) {
	  return (0, _builder.default)("VoidTypeAnnotation", ...args);
	}

	function JSXAttribute(...args) {
	  return (0, _builder.default)("JSXAttribute", ...args);
	}

	function JSXClosingElement(...args) {
	  return (0, _builder.default)("JSXClosingElement", ...args);
	}

	function JSXElement(...args) {
	  return (0, _builder.default)("JSXElement", ...args);
	}

	function JSXEmptyExpression(...args) {
	  return (0, _builder.default)("JSXEmptyExpression", ...args);
	}

	function JSXExpressionContainer(...args) {
	  return (0, _builder.default)("JSXExpressionContainer", ...args);
	}

	function JSXSpreadChild(...args) {
	  return (0, _builder.default)("JSXSpreadChild", ...args);
	}

	function JSXIdentifier(...args) {
	  return (0, _builder.default)("JSXIdentifier", ...args);
	}

	function JSXMemberExpression(...args) {
	  return (0, _builder.default)("JSXMemberExpression", ...args);
	}

	function JSXNamespacedName(...args) {
	  return (0, _builder.default)("JSXNamespacedName", ...args);
	}

	function JSXOpeningElement(...args) {
	  return (0, _builder.default)("JSXOpeningElement", ...args);
	}

	function JSXSpreadAttribute(...args) {
	  return (0, _builder.default)("JSXSpreadAttribute", ...args);
	}

	function JSXText(...args) {
	  return (0, _builder.default)("JSXText", ...args);
	}

	function JSXFragment(...args) {
	  return (0, _builder.default)("JSXFragment", ...args);
	}

	function JSXOpeningFragment(...args) {
	  return (0, _builder.default)("JSXOpeningFragment", ...args);
	}

	function JSXClosingFragment(...args) {
	  return (0, _builder.default)("JSXClosingFragment", ...args);
	}

	function Noop(...args) {
	  return (0, _builder.default)("Noop", ...args);
	}

	function ParenthesizedExpression(...args) {
	  return (0, _builder.default)("ParenthesizedExpression", ...args);
	}

	function AwaitExpression(...args) {
	  return (0, _builder.default)("AwaitExpression", ...args);
	}

	function BindExpression(...args) {
	  return (0, _builder.default)("BindExpression", ...args);
	}

	function ClassProperty(...args) {
	  return (0, _builder.default)("ClassProperty", ...args);
	}

	function OptionalMemberExpression(...args) {
	  return (0, _builder.default)("OptionalMemberExpression", ...args);
	}

	function OptionalCallExpression(...args) {
	  return (0, _builder.default)("OptionalCallExpression", ...args);
	}

	function ClassPrivateProperty(...args) {
	  return (0, _builder.default)("ClassPrivateProperty", ...args);
	}

	function Import(...args) {
	  return (0, _builder.default)("Import", ...args);
	}

	function Decorator(...args) {
	  return (0, _builder.default)("Decorator", ...args);
	}

	function DoExpression(...args) {
	  return (0, _builder.default)("DoExpression", ...args);
	}

	function ExportDefaultSpecifier(...args) {
	  return (0, _builder.default)("ExportDefaultSpecifier", ...args);
	}

	function ExportNamespaceSpecifier(...args) {
	  return (0, _builder.default)("ExportNamespaceSpecifier", ...args);
	}

	function PrivateName(...args) {
	  return (0, _builder.default)("PrivateName", ...args);
	}

	function BigIntLiteral(...args) {
	  return (0, _builder.default)("BigIntLiteral", ...args);
	}

	function TSParameterProperty(...args) {
	  return (0, _builder.default)("TSParameterProperty", ...args);
	}

	function TSDeclareFunction(...args) {
	  return (0, _builder.default)("TSDeclareFunction", ...args);
	}

	function TSDeclareMethod(...args) {
	  return (0, _builder.default)("TSDeclareMethod", ...args);
	}

	function TSQualifiedName(...args) {
	  return (0, _builder.default)("TSQualifiedName", ...args);
	}

	function TSCallSignatureDeclaration(...args) {
	  return (0, _builder.default)("TSCallSignatureDeclaration", ...args);
	}

	function TSConstructSignatureDeclaration(...args) {
	  return (0, _builder.default)("TSConstructSignatureDeclaration", ...args);
	}

	function TSPropertySignature(...args) {
	  return (0, _builder.default)("TSPropertySignature", ...args);
	}

	function TSMethodSignature(...args) {
	  return (0, _builder.default)("TSMethodSignature", ...args);
	}

	function TSIndexSignature(...args) {
	  return (0, _builder.default)("TSIndexSignature", ...args);
	}

	function TSAnyKeyword(...args) {
	  return (0, _builder.default)("TSAnyKeyword", ...args);
	}

	function TSNumberKeyword(...args) {
	  return (0, _builder.default)("TSNumberKeyword", ...args);
	}

	function TSObjectKeyword(...args) {
	  return (0, _builder.default)("TSObjectKeyword", ...args);
	}

	function TSBooleanKeyword(...args) {
	  return (0, _builder.default)("TSBooleanKeyword", ...args);
	}

	function TSStringKeyword(...args) {
	  return (0, _builder.default)("TSStringKeyword", ...args);
	}

	function TSSymbolKeyword(...args) {
	  return (0, _builder.default)("TSSymbolKeyword", ...args);
	}

	function TSVoidKeyword(...args) {
	  return (0, _builder.default)("TSVoidKeyword", ...args);
	}

	function TSUndefinedKeyword(...args) {
	  return (0, _builder.default)("TSUndefinedKeyword", ...args);
	}

	function TSNullKeyword(...args) {
	  return (0, _builder.default)("TSNullKeyword", ...args);
	}

	function TSNeverKeyword(...args) {
	  return (0, _builder.default)("TSNeverKeyword", ...args);
	}

	function TSThisType(...args) {
	  return (0, _builder.default)("TSThisType", ...args);
	}

	function TSFunctionType(...args) {
	  return (0, _builder.default)("TSFunctionType", ...args);
	}

	function TSConstructorType(...args) {
	  return (0, _builder.default)("TSConstructorType", ...args);
	}

	function TSTypeReference(...args) {
	  return (0, _builder.default)("TSTypeReference", ...args);
	}

	function TSTypePredicate(...args) {
	  return (0, _builder.default)("TSTypePredicate", ...args);
	}

	function TSTypeQuery(...args) {
	  return (0, _builder.default)("TSTypeQuery", ...args);
	}

	function TSTypeLiteral(...args) {
	  return (0, _builder.default)("TSTypeLiteral", ...args);
	}

	function TSArrayType(...args) {
	  return (0, _builder.default)("TSArrayType", ...args);
	}

	function TSTupleType(...args) {
	  return (0, _builder.default)("TSTupleType", ...args);
	}

	function TSUnionType(...args) {
	  return (0, _builder.default)("TSUnionType", ...args);
	}

	function TSIntersectionType(...args) {
	  return (0, _builder.default)("TSIntersectionType", ...args);
	}

	function TSConditionalType(...args) {
	  return (0, _builder.default)("TSConditionalType", ...args);
	}

	function TSInferType(...args) {
	  return (0, _builder.default)("TSInferType", ...args);
	}

	function TSParenthesizedType(...args) {
	  return (0, _builder.default)("TSParenthesizedType", ...args);
	}

	function TSTypeOperator(...args) {
	  return (0, _builder.default)("TSTypeOperator", ...args);
	}

	function TSIndexedAccessType(...args) {
	  return (0, _builder.default)("TSIndexedAccessType", ...args);
	}

	function TSMappedType(...args) {
	  return (0, _builder.default)("TSMappedType", ...args);
	}

	function TSLiteralType(...args) {
	  return (0, _builder.default)("TSLiteralType", ...args);
	}

	function TSExpressionWithTypeArguments(...args) {
	  return (0, _builder.default)("TSExpressionWithTypeArguments", ...args);
	}

	function TSInterfaceDeclaration(...args) {
	  return (0, _builder.default)("TSInterfaceDeclaration", ...args);
	}

	function TSInterfaceBody(...args) {
	  return (0, _builder.default)("TSInterfaceBody", ...args);
	}

	function TSTypeAliasDeclaration(...args) {
	  return (0, _builder.default)("TSTypeAliasDeclaration", ...args);
	}

	function TSAsExpression(...args) {
	  return (0, _builder.default)("TSAsExpression", ...args);
	}

	function TSTypeAssertion(...args) {
	  return (0, _builder.default)("TSTypeAssertion", ...args);
	}

	function TSEnumDeclaration(...args) {
	  return (0, _builder.default)("TSEnumDeclaration", ...args);
	}

	function TSEnumMember(...args) {
	  return (0, _builder.default)("TSEnumMember", ...args);
	}

	function TSModuleDeclaration(...args) {
	  return (0, _builder.default)("TSModuleDeclaration", ...args);
	}

	function TSModuleBlock(...args) {
	  return (0, _builder.default)("TSModuleBlock", ...args);
	}

	function TSImportEqualsDeclaration(...args) {
	  return (0, _builder.default)("TSImportEqualsDeclaration", ...args);
	}

	function TSExternalModuleReference(...args) {
	  return (0, _builder.default)("TSExternalModuleReference", ...args);
	}

	function TSNonNullExpression(...args) {
	  return (0, _builder.default)("TSNonNullExpression", ...args);
	}

	function TSExportAssignment(...args) {
	  return (0, _builder.default)("TSExportAssignment", ...args);
	}

	function TSNamespaceExportDeclaration(...args) {
	  return (0, _builder.default)("TSNamespaceExportDeclaration", ...args);
	}

	function TSTypeAnnotation(...args) {
	  return (0, _builder.default)("TSTypeAnnotation", ...args);
	}

	function TSTypeParameterInstantiation(...args) {
	  return (0, _builder.default)("TSTypeParameterInstantiation", ...args);
	}

	function TSTypeParameterDeclaration(...args) {
	  return (0, _builder.default)("TSTypeParameterDeclaration", ...args);
	}

	function TSTypeParameter(...args) {
	  return (0, _builder.default)("TSTypeParameter", ...args);
	}

	function NumberLiteral(...args) {
	  console.trace("The node type NumberLiteral has been renamed to NumericLiteral");
	  return NumberLiteral("NumberLiteral", ...args);
	}

	function RegexLiteral(...args) {
	  console.trace("The node type RegexLiteral has been renamed to RegExpLiteral");
	  return RegexLiteral("RegexLiteral", ...args);
	}

	function RestProperty(...args) {
	  console.trace("The node type RestProperty has been renamed to RestElement");
	  return RestProperty("RestProperty", ...args);
	}

	function SpreadProperty(...args) {
	  console.trace("The node type SpreadProperty has been renamed to SpreadElement");
	  return SpreadProperty("SpreadProperty", ...args);
	}

/***/ }),
/* 13 */
/***/ (function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 *  strict
	 * @format
	 */

	'use strict';

	var AFTER = 'after';
	var BEFORE = 'before';
	var FIRST = 'first';
	var KEY = 'key';
	var LAST = 'last';

	module.exports = {
	  AFTER: AFTER,
	  BEFORE: BEFORE,
	  FIRST: FIRST,
	  KEY: KEY,
	  LAST: LAST
	};

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	Object.defineProperty(exports, "VISITOR_KEYS", {
	  enumerable: true,
	  get: function () {
	    return _utils.VISITOR_KEYS;
	  }
	});
	Object.defineProperty(exports, "ALIAS_KEYS", {
	  enumerable: true,
	  get: function () {
	    return _utils.ALIAS_KEYS;
	  }
	});
	Object.defineProperty(exports, "FLIPPED_ALIAS_KEYS", {
	  enumerable: true,
	  get: function () {
	    return _utils.FLIPPED_ALIAS_KEYS;
	  }
	});
	Object.defineProperty(exports, "NODE_FIELDS", {
	  enumerable: true,
	  get: function () {
	    return _utils.NODE_FIELDS;
	  }
	});
	Object.defineProperty(exports, "BUILDER_KEYS", {
	  enumerable: true,
	  get: function () {
	    return _utils.BUILDER_KEYS;
	  }
	});
	Object.defineProperty(exports, "DEPRECATED_KEYS", {
	  enumerable: true,
	  get: function () {
	    return _utils.DEPRECATED_KEYS;
	  }
	});
	exports.TYPES = void 0;

	function _toFastProperties() {
	  const data = _interopRequireDefault(__webpack_require__(158));

	  _toFastProperties = function () {
	    return data;
	  };

	  return data;
	}

	__webpack_require__(27);

	__webpack_require__(28);

	__webpack_require__(122);

	__webpack_require__(123);

	__webpack_require__(124);

	__webpack_require__(121);

	__webpack_require__(125);

	var _utils = __webpack_require__(15);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	(0, _toFastProperties().default)(_utils.VISITOR_KEYS);
	(0, _toFastProperties().default)(_utils.ALIAS_KEYS);
	(0, _toFastProperties().default)(_utils.FLIPPED_ALIAS_KEYS);
	(0, _toFastProperties().default)(_utils.NODE_FIELDS);
	(0, _toFastProperties().default)(_utils.BUILDER_KEYS);
	(0, _toFastProperties().default)(_utils.DEPRECATED_KEYS);
	const TYPES = Object.keys(_utils.VISITOR_KEYS).concat(Object.keys(_utils.FLIPPED_ALIAS_KEYS)).concat(Object.keys(_utils.DEPRECATED_KEYS));
	exports.TYPES = TYPES;

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.validate = validate;
	exports.typeIs = typeIs;
	exports.validateType = validateType;
	exports.validateOptional = validateOptional;
	exports.validateOptionalType = validateOptionalType;
	exports.arrayOf = arrayOf;
	exports.arrayOfType = arrayOfType;
	exports.validateArrayOfType = validateArrayOfType;
	exports.assertEach = assertEach;
	exports.assertOneOf = assertOneOf;
	exports.assertNodeType = assertNodeType;
	exports.assertNodeOrValueType = assertNodeOrValueType;
	exports.assertValueType = assertValueType;
	exports.chain = chain;
	exports.default = defineType;
	exports.DEPRECATED_KEYS = exports.BUILDER_KEYS = exports.NODE_FIELDS = exports.FLIPPED_ALIAS_KEYS = exports.ALIAS_KEYS = exports.VISITOR_KEYS = void 0;

	var _is = _interopRequireDefault(__webpack_require__(31));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	const VISITOR_KEYS = {};
	exports.VISITOR_KEYS = VISITOR_KEYS;
	const ALIAS_KEYS = {};
	exports.ALIAS_KEYS = ALIAS_KEYS;
	const FLIPPED_ALIAS_KEYS = {};
	exports.FLIPPED_ALIAS_KEYS = FLIPPED_ALIAS_KEYS;
	const NODE_FIELDS = {};
	exports.NODE_FIELDS = NODE_FIELDS;
	const BUILDER_KEYS = {};
	exports.BUILDER_KEYS = BUILDER_KEYS;
	const DEPRECATED_KEYS = {};
	exports.DEPRECATED_KEYS = DEPRECATED_KEYS;

	function getType(val) {
	  if (Array.isArray(val)) {
	    return "array";
	  } else if (val === null) {
	    return "null";
	  } else if (val === undefined) {
	    return "undefined";
	  } else {
	    return typeof val;
	  }
	}

	function validate(validate) {
	  return {
	    validate
	  };
	}

	function typeIs(typeName) {
	  return typeof typeName === "string" ? assertNodeType(typeName) : assertNodeType(...typeName);
	}

	function validateType(typeName) {
	  return validate(typeIs(typeName));
	}

	function validateOptional(validate) {
	  return {
	    validate,
	    optional: true
	  };
	}

	function validateOptionalType(typeName) {
	  return {
	    validate: typeIs(typeName),
	    optional: true
	  };
	}

	function arrayOf(elementType) {
	  return chain(assertValueType("array"), assertEach(elementType));
	}

	function arrayOfType(typeName) {
	  return arrayOf(typeIs(typeName));
	}

	function validateArrayOfType(typeName) {
	  return validate(arrayOfType(typeName));
	}

	function assertEach(callback) {
	  function validator(node, key, val) {
	    if (!Array.isArray(val)) return;

	    for (let i = 0; i < val.length; i++) {
	      callback(node, `${key}[${i}]`, val[i]);
	    }
	  }

	  validator.each = callback;
	  return validator;
	}

	function assertOneOf(...values) {
	  function validate(node, key, val) {
	    if (values.indexOf(val) < 0) {
	      throw new TypeError(`Property ${key} expected value to be one of ${JSON.stringify(values)} but got ${JSON.stringify(val)}`);
	    }
	  }

	  validate.oneOf = values;
	  return validate;
	}

	function assertNodeType(...types) {
	  function validate(node, key, val) {
	    let valid = false;

	    for (const type of types) {
	      if ((0, _is.default)(type, val)) {
	        valid = true;
	        break;
	      }
	    }

	    if (!valid) {
	      throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} ` + `but instead got ${JSON.stringify(val && val.type)}`);
	    }
	  }

	  validate.oneOfNodeTypes = types;
	  return validate;
	}

	function assertNodeOrValueType(...types) {
	  function validate(node, key, val) {
	    let valid = false;

	    for (const type of types) {
	      if (getType(val) === type || (0, _is.default)(type, val)) {
	        valid = true;
	        break;
	      }
	    }

	    if (!valid) {
	      throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} ` + `but instead got ${JSON.stringify(val && val.type)}`);
	    }
	  }

	  validate.oneOfNodeOrValueTypes = types;
	  return validate;
	}

	function assertValueType(type) {
	  function validate(node, key, val) {
	    const valid = getType(val) === type;

	    if (!valid) {
	      throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
	    }
	  }

	  validate.type = type;
	  return validate;
	}

	function chain(...fns) {
	  function validate(...args) {
	    for (const fn of fns) {
	      fn(...args);
	    }
	  }

	  validate.chainOf = fns;
	  return validate;
	}

	function defineType(type, opts = {}) {
	  const inherits = opts.inherits && store[opts.inherits] || {};
	  const fields = opts.fields || inherits.fields || {};
	  const visitor = opts.visitor || inherits.visitor || [];
	  const aliases = opts.aliases || inherits.aliases || [];
	  const builder = opts.builder || inherits.builder || opts.visitor || [];

	  if (opts.deprecatedAlias) {
	    DEPRECATED_KEYS[opts.deprecatedAlias] = type;
	  }

	  for (const key of visitor.concat(builder)) {
	    fields[key] = fields[key] || {};
	  }

	  for (const key in fields) {
	    const field = fields[key];

	    if (builder.indexOf(key) === -1) {
	      field.optional = true;
	    }

	    if (field.default === undefined) {
	      field.default = null;
	    } else if (!field.validate) {
	      field.validate = assertValueType(getType(field.default));
	    }
	  }

	  VISITOR_KEYS[type] = opts.visitor = visitor;
	  BUILDER_KEYS[type] = opts.builder = builder;
	  NODE_FIELDS[type] = opts.fields = fields;
	  ALIAS_KEYS[type] = opts.aliases = aliases;
	  aliases.forEach(alias => {
	    FLIPPED_ALIAS_KEYS[alias] = FLIPPED_ALIAS_KEYS[alias] || [];
	    FLIPPED_ALIAS_KEYS[alias].push(type);
	  });
	  store[type] = opts;
	}

	const store = {};

/***/ }),
/* 16 */
/***/ (function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.NOT_LOCAL_BINDING = exports.BLOCK_SCOPED_SYMBOL = exports.INHERIT_KEYS = exports.UNARY_OPERATORS = exports.STRING_UNARY_OPERATORS = exports.NUMBER_UNARY_OPERATORS = exports.BOOLEAN_UNARY_OPERATORS = exports.BINARY_OPERATORS = exports.NUMBER_BINARY_OPERATORS = exports.BOOLEAN_BINARY_OPERATORS = exports.COMPARISON_BINARY_OPERATORS = exports.EQUALITY_BINARY_OPERATORS = exports.BOOLEAN_NUMBER_BINARY_OPERATORS = exports.UPDATE_OPERATORS = exports.LOGICAL_OPERATORS = exports.COMMENT_KEYS = exports.FOR_INIT_KEYS = exports.FLATTENABLE_KEYS = exports.STATEMENT_OR_BLOCK_KEYS = void 0;
	const STATEMENT_OR_BLOCK_KEYS = ["consequent", "body", "alternate"];
	exports.STATEMENT_OR_BLOCK_KEYS = STATEMENT_OR_BLOCK_KEYS;
	const FLATTENABLE_KEYS = ["body", "expressions"];
	exports.FLATTENABLE_KEYS = FLATTENABLE_KEYS;
	const FOR_INIT_KEYS = ["left", "init"];
	exports.FOR_INIT_KEYS = FOR_INIT_KEYS;
	const COMMENT_KEYS = ["leadingComments", "trailingComments", "innerComments"];
	exports.COMMENT_KEYS = COMMENT_KEYS;
	const LOGICAL_OPERATORS = ["||", "&&", "??"];
	exports.LOGICAL_OPERATORS = LOGICAL_OPERATORS;
	const UPDATE_OPERATORS = ["++", "--"];
	exports.UPDATE_OPERATORS = UPDATE_OPERATORS;
	const BOOLEAN_NUMBER_BINARY_OPERATORS = [">", "<", ">=", "<="];
	exports.BOOLEAN_NUMBER_BINARY_OPERATORS = BOOLEAN_NUMBER_BINARY_OPERATORS;
	const EQUALITY_BINARY_OPERATORS = ["==", "===", "!=", "!=="];
	exports.EQUALITY_BINARY_OPERATORS = EQUALITY_BINARY_OPERATORS;
	const COMPARISON_BINARY_OPERATORS = [...EQUALITY_BINARY_OPERATORS, "in", "instanceof"];
	exports.COMPARISON_BINARY_OPERATORS = COMPARISON_BINARY_OPERATORS;
	const BOOLEAN_BINARY_OPERATORS = [...COMPARISON_BINARY_OPERATORS, ...BOOLEAN_NUMBER_BINARY_OPERATORS];
	exports.BOOLEAN_BINARY_OPERATORS = BOOLEAN_BINARY_OPERATORS;
	const NUMBER_BINARY_OPERATORS = ["-", "/", "%", "*", "**", "&", "|", ">>", ">>>", "<<", "^"];
	exports.NUMBER_BINARY_OPERATORS = NUMBER_BINARY_OPERATORS;
	const BINARY_OPERATORS = ["+", ...NUMBER_BINARY_OPERATORS, ...BOOLEAN_BINARY_OPERATORS];
	exports.BINARY_OPERATORS = BINARY_OPERATORS;
	const BOOLEAN_UNARY_OPERATORS = ["delete", "!"];
	exports.BOOLEAN_UNARY_OPERATORS = BOOLEAN_UNARY_OPERATORS;
	const NUMBER_UNARY_OPERATORS = ["+", "-", "~"];
	exports.NUMBER_UNARY_OPERATORS = NUMBER_UNARY_OPERATORS;
	const STRING_UNARY_OPERATORS = ["typeof"];
	exports.STRING_UNARY_OPERATORS = STRING_UNARY_OPERATORS;
	const UNARY_OPERATORS = ["void", "throw", ...BOOLEAN_UNARY_OPERATORS, ...NUMBER_UNARY_OPERATORS, ...STRING_UNARY_OPERATORS];
	exports.UNARY_OPERATORS = UNARY_OPERATORS;
	const INHERIT_KEYS = {
	  optional: ["typeAnnotation", "typeParameters", "returnType"],
	  force: ["start", "loc", "end"]
	};
	exports.INHERIT_KEYS = INHERIT_KEYS;
	const BLOCK_SCOPED_SYMBOL = Symbol.for("var used to be block scoped");
	exports.BLOCK_SCOPED_SYMBOL = BLOCK_SCOPED_SYMBOL;
	const NOT_LOCAL_BINDING = Symbol.for("should not be considered a local binding");
	exports.NOT_LOCAL_BINDING = NOT_LOCAL_BINDING;

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 *  strict-local
	 * @format
	 */

	'use strict';

	// Transforms applied to the code used to process a query response.
	var relaySchemaExtensions = [__webpack_require__(37).SCHEMA_EXTENSION, __webpack_require__(25).SCHEMA_EXTENSION];

	// Transforms applied to both operations and fragments for both reading and
	// writing from the store.
	var relayCommonTransforms = [__webpack_require__(37).transform, __webpack_require__(75).transform, __webpack_require__(25).transform, __webpack_require__(39).transform, __webpack_require__(66).transform];

	// Transforms applied to fragments used for reading data from a store
	var relayFragmentTransforms = [__webpack_require__(67).transform, __webpack_require__(1).FlattenTransform.transformWithOptions({ flattenAbstractTypes: true }), __webpack_require__(1).SkipRedundantNodesTransform.transform];

	// Transforms applied to queries/mutations/subscriptions that are used for
	// fetching data from the server and parsing those responses.
	var relayQueryTransforms = [__webpack_require__(63).transform, __webpack_require__(1).SkipClientFieldTransform.transform, __webpack_require__(1).SkipUnreachableNodeTransform.transform, __webpack_require__(71).transform];

	// Transforms applied to the code used to process a query response.
	var relayCodegenTransforms = [__webpack_require__(1).InlineFragmentsTransform.transform, __webpack_require__(1).FlattenTransform.transformWithOptions({ flattenAbstractTypes: true }), __webpack_require__(1).SkipRedundantNodesTransform.transform, __webpack_require__(38).transform, __webpack_require__(1).FilterDirectivesTransform.transform];

	// Transforms applied before printing the query sent to the server.
	var relayPrintTransforms = [__webpack_require__(1).FlattenTransform.transformWithOptions({}), __webpack_require__(38).transform, __webpack_require__(73).transform, __webpack_require__(1).FilterDirectivesTransform.transform, __webpack_require__(1).StripUnusedVariablesTransform.transform];

	module.exports = {
	  commonTransforms: relayCommonTransforms,
	  codegenTransforms: relayCodegenTransforms,
	  fragmentTransforms: relayFragmentTransforms,
	  printTransforms: relayPrintTransforms,
	  queryTransforms: relayQueryTransforms,
	  schemaExtensions: relaySchemaExtensions
	};

/***/ }),
/* 18 */
/***/ (function(module, exports) {

	module.exports = require("fbjs/lib/nullthrows");

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = cloneNode;

	var _definitions = __webpack_require__(14);

	const has = Function.call.bind(Object.prototype.hasOwnProperty);

	function cloneIfNode(obj, deep) {
	  if (obj && typeof obj.type === "string" && obj.type !== "CommentLine" && obj.type !== "CommentBlock") {
	    return cloneNode(obj, deep);
	  }

	  return obj;
	}

	function cloneIfNodeOrArray(obj, deep) {
	  if (Array.isArray(obj)) {
	    return obj.map(node => cloneIfNode(node, deep));
	  }

	  return cloneIfNode(obj, deep);
	}

	function cloneNode(node, deep = true) {
	  if (!node) return node;
	  const {
	    type
	  } = node;
	  const newNode = {
	    type
	  };

	  if (type === "Identifier") {
	    newNode.name = node.name;
	  } else if (!has(_definitions.NODE_FIELDS, type)) {
	    throw new Error(`Unknown node type: "${type}"`);
	  } else {
	    for (const field of Object.keys(_definitions.NODE_FIELDS[type])) {
	      if (has(node, field)) {
	        newNode[field] = deep ? cloneIfNodeOrArray(node[field], true) : node[field];
	      }
	    }
	  }

	  if (has(node, "loc")) {
	    newNode.loc = node.loc;
	  }

	  if (has(node, "leadingComments")) {
	    newNode.leadingComments = node.leadingComments;
	  }

	  if (has(node, "innerComments")) {
	    newNode.innerComments = node.innerCmments;
	  }

	  if (has(node, "trailingComments")) {
	    newNode.trailingComments = node.trailingComments;
	  }

	  if (has(node, "extra")) {
	    newNode.extra = Object.assign({}, node.extra);
	  }

	  return newNode;
	}

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = isValidIdentifier;

	function _esutils() {
	  const data = _interopRequireDefault(__webpack_require__(147));

	  _esutils = function () {
	    return data;
	  };

	  return data;
	}

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function isValidIdentifier(name) {
	  if (typeof name !== "string" || _esutils().default.keyword.isReservedWordES6(name, true)) {
	    return false;
	  } else if (name === "await") {
	    return false;
	  } else {
	    return _esutils().default.keyword.isIdentifierNameES6(name);
	  }
	}

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = getBindingIdentifiers;

	var _generated = __webpack_require__(8);

	function getBindingIdentifiers(node, duplicates, outerOnly) {
	  let search = [].concat(node);
	  const ids = Object.create(null);

	  while (search.length) {
	    const id = search.shift();
	    if (!id) continue;
	    const keys = getBindingIdentifiers.keys[id.type];

	    if ((0, _generated.isIdentifier)(id)) {
	      if (duplicates) {
	        const _ids = ids[id.name] = ids[id.name] || [];

	        _ids.push(id);
	      } else {
	        ids[id.name] = id;
	      }

	      continue;
	    }

	    if ((0, _generated.isExportDeclaration)(id)) {
	      if ((0, _generated.isDeclaration)(id.declaration)) {
	        search.push(id.declaration);
	      }

	      continue;
	    }

	    if (outerOnly) {
	      if ((0, _generated.isFunctionDeclaration)(id)) {
	        search.push(id.id);
	        continue;
	      }

	      if ((0, _generated.isFunctionExpression)(id)) {
	        continue;
	      }
	    }

	    if (keys) {
	      for (let i = 0; i < keys.length; i++) {
	        const key = keys[i];

	        if (id[key]) {
	          search = search.concat(id[key]);
	        }
	      }
	    }
	  }

	  return ids;
	}

	getBindingIdentifiers.keys = {
	  DeclareClass: ["id"],
	  DeclareFunction: ["id"],
	  DeclareModule: ["id"],
	  DeclareVariable: ["id"],
	  DeclareInterface: ["id"],
	  DeclareTypeAlias: ["id"],
	  DeclareOpaqueType: ["id"],
	  InterfaceDeclaration: ["id"],
	  TypeAlias: ["id"],
	  OpaqueType: ["id"],
	  CatchClause: ["param"],
	  LabeledStatement: ["label"],
	  UnaryExpression: ["argument"],
	  AssignmentExpression: ["left"],
	  ImportSpecifier: ["local"],
	  ImportNamespaceSpecifier: ["local"],
	  ImportDefaultSpecifier: ["local"],
	  ImportDeclaration: ["specifiers"],
	  ExportSpecifier: ["exported"],
	  ExportNamespaceSpecifier: ["exported"],
	  ExportDefaultSpecifier: ["exported"],
	  FunctionDeclaration: ["id", "params"],
	  FunctionExpression: ["id", "params"],
	  ArrowFunctionExpression: ["params"],
	  ObjectMethod: ["params"],
	  ClassMethod: ["params"],
	  ForInStatement: ["left"],
	  ForOfStatement: ["left"],
	  ClassDeclaration: ["id"],
	  ClassExpression: ["id"],
	  RestElement: ["argument"],
	  UpdateExpression: ["argument"],
	  ObjectProperty: ["value"],
	  AssignmentPattern: ["left"],
	  ArrayPattern: ["elements"],
	  ObjectPattern: ["properties"],
	  VariableDeclaration: ["declarations"],
	  VariableDeclarator: ["id"]
	};

/***/ }),
/* 22 */
/***/ (function(module, exports) {

	module.exports = require("util");

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 *  strict-local
	 * @format
	 */

	'use strict';

	function getInputObjectTypeIdentifier(type) {
	  return type.name;
	}

	function transformScalarType(type, state, objectProps) {
	  if (type instanceof __webpack_require__(3).GraphQLNonNull) {
	    return transformNonNullableScalarType(type.ofType, state, objectProps);
	  } else {
	    return __webpack_require__(2).nullableTypeAnnotation(transformNonNullableScalarType(type, state, objectProps));
	  }
	}

	function transformNonNullableScalarType(type, state, objectProps) {
	  if (type instanceof __webpack_require__(3).GraphQLList) {
	    return __webpack_require__(5).readOnlyArrayOfType(transformScalarType(type.ofType, state, objectProps));
	  } else if (type instanceof __webpack_require__(3).GraphQLObjectType || type instanceof __webpack_require__(3).GraphQLUnionType || type instanceof __webpack_require__(3).GraphQLInterfaceType) {
	    return objectProps;
	  } else if (type instanceof __webpack_require__(3).GraphQLScalarType) {
	    return transformGraphQLScalarType(type, state);
	  } else if (type instanceof __webpack_require__(3).GraphQLEnumType) {
	    return transformGraphQLEnumType(type, state);
	  } else {
	    throw new Error('Could not convert from GraphQL type ' + type.toString());
	  }
	}

	function transformGraphQLScalarType(type, state) {
	  var customType = state.customScalars[type.name];
	  switch (customType || type.name) {
	    case 'ID':
	    case 'String':
	      return __webpack_require__(2).stringTypeAnnotation();
	    case 'Float':
	    case 'Int':
	      return __webpack_require__(2).numberTypeAnnotation();
	    case 'Boolean':
	      return __webpack_require__(2).booleanTypeAnnotation();
	    default:
	      return customType == null ? __webpack_require__(2).anyTypeAnnotation() : __webpack_require__(2).genericTypeAnnotation(__webpack_require__(2).identifier(customType));
	  }
	}

	function transformGraphQLEnumType(type, state) {
	  state.usedEnums[type.name] = type;
	  return __webpack_require__(2).genericTypeAnnotation(__webpack_require__(2).identifier(type.name));
	}

	function transformInputType(type, state) {
	  if (type instanceof __webpack_require__(3).GraphQLNonNull) {
	    return transformNonNullableInputType(type.ofType, state);
	  } else {
	    return __webpack_require__(2).nullableTypeAnnotation(transformNonNullableInputType(type, state));
	  }
	}

	function transformNonNullableInputType(type, state) {
	  if (type instanceof __webpack_require__(3).GraphQLList) {
	    return __webpack_require__(5).readOnlyArrayOfType(transformInputType(type.ofType, state));
	  } else if (type instanceof __webpack_require__(3).GraphQLScalarType) {
	    return transformGraphQLScalarType(type, state);
	  } else if (type instanceof __webpack_require__(3).GraphQLEnumType) {
	    return transformGraphQLEnumType(type, state);
	  } else if (type instanceof __webpack_require__(3).GraphQLInputObjectType) {
	    var typeIdentifier = getInputObjectTypeIdentifier(type);
	    if (state.generatedInputObjectTypes[typeIdentifier]) {
	      return __webpack_require__(2).genericTypeAnnotation(__webpack_require__(2).identifier(typeIdentifier));
	    }
	    state.generatedInputObjectTypes[typeIdentifier] = 'pending';
	    var fields = type.getFields();
	    var props = Object.keys(fields).map(function (key) {
	      return fields[key];
	    }).filter(function (field) {
	      return state.inputFieldWhiteList.indexOf(field.name) < 0;
	    }).map(function (field) {
	      var property = __webpack_require__(2).objectTypeProperty(__webpack_require__(2).identifier(field.name), transformInputType(field.type, state));
	      if (!(field.type instanceof __webpack_require__(3).GraphQLNonNull)) {
	        property.optional = true;
	      }
	      return property;
	    });
	    state.generatedInputObjectTypes[typeIdentifier] = __webpack_require__(2).objectTypeAnnotation(props);
	    return __webpack_require__(2).genericTypeAnnotation(__webpack_require__(2).identifier(typeIdentifier));
	  } else {
	    throw new Error('Could not convert from GraphQL type ' + type.toString());
	  }
	}

	module.exports = {
	  transformInputType: transformInputType,
	  transformScalarType: transformScalarType
	};

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 * @format
	 */

	'use strict';

	var _classCallCheck3 = _interopRequireDefault(__webpack_require__(34));

	var _possibleConstructorReturn3 = _interopRequireDefault(__webpack_require__(146));

	var _inherits3 = _interopRequireDefault(__webpack_require__(145));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var getRawType = __webpack_require__(1).SchemaUtils.getRawType;

	var RelayParser = function (_Parser) {
	  (0, _inherits3['default'])(RelayParser, _Parser);

	  function RelayParser(schema, definition) {
	    (0, _classCallCheck3['default'])(this, RelayParser);

	    var _this = (0, _possibleConstructorReturn3['default'])(this, _Parser.call(this, schema, definition));

	    _this._definition = definition;
	    _this._schema = schema;
	    return _this;
	  }

	  /**
	   * Find the definition of a field of the specified type.
	   */


	  RelayParser.prototype.getFieldDefinition = function getFieldDefinition(parentType, fieldName, fieldAST) {
	    var schemaFieldDef = _Parser.prototype.getFieldDefinition.call(this, parentType, fieldName, fieldAST);
	    if (!schemaFieldDef) {
	      var type = getRawType(parentType);
	      schemaFieldDef = getClassicFieldDefinition(this._schema, type, fieldName, fieldAST);
	    }
	    return schemaFieldDef || null;
	  };

	  return RelayParser;
	}(__webpack_require__(1).Parser);

	function getName(ast) {
	  var name = ast.name ? ast.name.value : null;
	  !(typeof name === 'string') ?  true ? __webpack_require__(4)(false, 'RelayParser: Expected ast node `%s` to have a name.', ast) : require('fbjs/lib/invariant')(false) : void 0;
	  return name;
	}

	function getClassicFieldDefinition(schema, type, fieldName, fieldAST) {
	  if (__webpack_require__(3).isAbstractType(type) && fieldAST && fieldAST.directives && fieldAST.directives.some(function (directive) {
	    return getName(directive) === 'fixme_fat_interface';
	  })) {
	    var possibleTypes = schema.getPossibleTypes(__webpack_require__(3).assertAbstractType(type));
	    var schemaFieldDef = void 0;

	    var _loop = function _loop(ii) {
	      var possibleField = possibleTypes[ii].getFields()[fieldName];
	      if (possibleField) {
	        // Fat interface fields can have differing arguments. Try to return
	        // a field with matching arguments, but still return a field if the
	        // arguments do not match.
	        schemaFieldDef = possibleField;
	        if (fieldAST && fieldAST.arguments) {
	          var argumentsAllExist = fieldAST.arguments.every(function (argument) {
	            return possibleField.args.find(function (argDef) {
	              return argDef.name === getName(argument);
	            });
	          });
	          if (argumentsAllExist) {
	            return 'break';
	          }
	        }
	      }
	    };

	    for (var ii = 0; ii < possibleTypes.length; ii++) {
	      var _ret = _loop(ii);

	      if (_ret === 'break') break;
	    }
	    return schemaFieldDef;
	  }
	}

	module.exports = RelayParser;

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 *  strict-local
	 * @format
	 */

	'use strict';

	var _extends3 = _interopRequireDefault(__webpack_require__(9));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var RELAY = 'relay';
	var SCHEMA_EXTENSION = 'directive @relay(\n  # Marks this fragment spread as being deferrable such that it loads after\n  # other portions of the view.\n  deferrable: Boolean,\n\n  # Marks a connection field as containing nodes without \'id\' fields.\n  # This is used to silence the warning when diffing connections.\n  isConnectionWithoutNodeID: Boolean,\n\n  # Marks a fragment as intended for pattern matching (as opposed to fetching).\n  # Used in Classic only.\n  pattern: Boolean,\n\n  # Marks a fragment as being backed by a GraphQLList.\n  plural: Boolean,\n\n  # Marks a fragment spread which should be unmasked if provided false\n  mask: Boolean = true,\n\n  # Selectively pass variables down into a fragment. Only used in Classic.\n  variables: [String!],\n) on FRAGMENT_DEFINITION | FRAGMENT_SPREAD | INLINE_FRAGMENT | FIELD';

	/**
	 * A transform that extracts `@relay(plural: Boolean)` directives and converts
	 * them to metadata that can be accessed at runtime.
	 */
	function relayRelayDirectiveTransform(context) {
	  return __webpack_require__(1).IRTransformer.transform(context, {
	    Fragment: visitRelayMetadata(fragmentMetadata),
	    FragmentSpread: visitRelayMetadata(fragmentSpreadMetadata)
	  });
	}

	function visitRelayMetadata(metadataFn) {
	  return function (node) {
	    var relayDirective = node.directives.find(function (_ref) {
	      var name = _ref.name;
	      return name === RELAY;
	    });
	    if (!relayDirective) {
	      return this.traverse(node);
	    }
	    var argValues = __webpack_require__(1).getLiteralArgumentValues(relayDirective.args);
	    var metadata = metadataFn(argValues);
	    return this.traverse((0, _extends3['default'])({}, node, {
	      directives: node.directives.filter(function (directive) {
	        return directive !== relayDirective;
	      }),
	      metadata: (0, _extends3['default'])({}, node.metadata || {}, metadata)
	    }));
	  };
	}

	function fragmentMetadata(_ref2) {
	  var mask = _ref2.mask,
	      plural = _ref2.plural;

	  !(plural === undefined || typeof plural === 'boolean') ?  true ? __webpack_require__(4)(false, 'RelayRelayDirectiveTransform: Expected the "plural" argument to @relay ' + 'to be a boolean literal if specified.') : require('fbjs/lib/invariant')(false) : void 0;
	  !(mask === undefined || typeof mask === 'boolean') ?  true ? __webpack_require__(4)(false, 'RelayRelayDirectiveTransform: Expected the "mask" argument to @relay ' + 'to be a boolean literal if specified.') : require('fbjs/lib/invariant')(false) : void 0;
	  return { mask: mask, plural: plural };
	}

	function fragmentSpreadMetadata(_ref3) {
	  var mask = _ref3.mask,
	      deferrable = _ref3.deferrable;

	  !(mask === undefined || typeof mask === 'boolean') ?  true ? __webpack_require__(4)(false, 'RelayRelayDirectiveTransform: Expected the "mask" argument to @relay ' + 'to be a boolean literal if specified.') : require('fbjs/lib/invariant')(false) : void 0;
	  !(deferrable === undefined || typeof deferrable === 'boolean') ?  true ? __webpack_require__(4)(false, 'RelayRelayDirectiveTransform: Expected the "deferrable" argument to ' + '@relay to be a boolean literal if specified.') : require('fbjs/lib/invariant')(false) : void 0;
	  !!(deferrable === true && mask === false) ?  true ? __webpack_require__(4)(false, 'RelayRelayDirectiveTransform: Cannot unmask a deferrable fragment spread.') : require('fbjs/lib/invariant')(false) : void 0;
	  return { mask: mask, deferrable: deferrable };
	}

	module.exports = {
	  RELAY: RELAY,
	  SCHEMA_EXTENSION: SCHEMA_EXTENSION,
	  transform: relayRelayDirectiveTransform
	};

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.Identifier = Identifier;
	exports.SpreadElement = exports.RestElement = RestElement;
	exports.ObjectPattern = exports.ObjectExpression = ObjectExpression;
	exports.ObjectMethod = ObjectMethod;
	exports.ObjectProperty = ObjectProperty;
	exports.ArrayPattern = exports.ArrayExpression = ArrayExpression;
	exports.RegExpLiteral = RegExpLiteral;
	exports.BooleanLiteral = BooleanLiteral;
	exports.NullLiteral = NullLiteral;
	exports.NumericLiteral = NumericLiteral;
	exports.StringLiteral = StringLiteral;
	exports.BigIntLiteral = BigIntLiteral;

	function t() {
	  const data = _interopRequireWildcard(__webpack_require__(2));

	  t = function () {
	    return data;
	  };

	  return data;
	}

	function _jsesc() {
	  const data = _interopRequireDefault(__webpack_require__(150));

	  _jsesc = function () {
	    return data;
	  };

	  return data;
	}

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

	function Identifier(node) {
	  this.exactSource(node.loc, () => {
	    this.word(node.name);
	  });
	}

	function RestElement(node) {
	  this.token("...");
	  this.print(node.argument, node);
	}

	function ObjectExpression(node) {
	  const props = node.properties;
	  this.token("{");
	  this.printInnerComments(node);

	  if (props.length) {
	    this.space();
	    this.printList(props, node, {
	      indent: true,
	      statement: true
	    });
	    this.space();
	  }

	  this.token("}");
	}

	function ObjectMethod(node) {
	  this.printJoin(node.decorators, node);

	  this._methodHead(node);

	  this.space();
	  this.print(node.body, node);
	}

	function ObjectProperty(node) {
	  this.printJoin(node.decorators, node);

	  if (node.computed) {
	    this.token("[");
	    this.print(node.key, node);
	    this.token("]");
	  } else {
	    if (t().isAssignmentPattern(node.value) && t().isIdentifier(node.key) && node.key.name === node.value.left.name) {
	      this.print(node.value, node);
	      return;
	    }

	    this.print(node.key, node);

	    if (node.shorthand && t().isIdentifier(node.key) && t().isIdentifier(node.value) && node.key.name === node.value.name) {
	      return;
	    }
	  }

	  this.token(":");
	  this.space();
	  this.print(node.value, node);
	}

	function ArrayExpression(node) {
	  const elems = node.elements;
	  const len = elems.length;
	  this.token("[");
	  this.printInnerComments(node);

	  for (let i = 0; i < elems.length; i++) {
	    const elem = elems[i];

	    if (elem) {
	      if (i > 0) this.space();
	      this.print(elem, node);
	      if (i < len - 1) this.token(",");
	    } else {
	      this.token(",");
	    }
	  }

	  this.token("]");
	}

	function RegExpLiteral(node) {
	  this.word(`/${node.pattern}/${node.flags}`);
	}

	function BooleanLiteral(node) {
	  this.word(node.value ? "true" : "false");
	}

	function NullLiteral() {
	  this.word("null");
	}

	function NumericLiteral(node) {
	  const raw = this.getPossibleRaw(node);
	  const value = node.value + "";

	  if (raw == null) {
	    this.number(value);
	  } else if (this.format.minified) {
	    this.number(raw.length < value.length ? raw : value);
	  } else {
	    this.number(raw);
	  }
	}

	function StringLiteral(node) {
	  const raw = this.getPossibleRaw(node);

	  if (!this.format.minified && raw != null) {
	    this.token(raw);
	    return;
	  }

	  const opts = this.format.jsescOption;

	  if (this.format.jsonCompatibleStrings) {
	    opts.json = true;
	  }

	  const val = (0, _jsesc().default)(node.value, opts);
	  return this.token(val);
	}

	function BigIntLiteral(node) {
	  const raw = this.getPossibleRaw(node);

	  if (!this.format.minified && raw != null) {
	    this.token(raw);
	    return;
	  }

	  this.token(node.value);
	}

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.patternLikeCommon = exports.functionDeclarationCommon = exports.functionTypeAnnotationCommon = exports.functionCommon = void 0;

	var _isValidIdentifier = _interopRequireDefault(__webpack_require__(20));

	var _constants = __webpack_require__(16);

	var _utils = _interopRequireWildcard(__webpack_require__(15));

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	(0, _utils.default)("ArrayExpression", {
	  fields: {
	    elements: {
	      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeOrValueType)("null", "Expression", "SpreadElement"))),
	      default: []
	    }
	  },
	  visitor: ["elements"],
	  aliases: ["Expression"]
	});
	(0, _utils.default)("AssignmentExpression", {
	  fields: {
	    operator: {
	      validate: (0, _utils.assertValueType)("string")
	    },
	    left: {
	      validate: (0, _utils.assertNodeType)("LVal")
	    },
	    right: {
	      validate: (0, _utils.assertNodeType)("Expression")
	    }
	  },
	  builder: ["operator", "left", "right"],
	  visitor: ["left", "right"],
	  aliases: ["Expression"]
	});
	(0, _utils.default)("BinaryExpression", {
	  builder: ["operator", "left", "right"],
	  fields: {
	    operator: {
	      validate: (0, _utils.assertOneOf)(..._constants.BINARY_OPERATORS)
	    },
	    left: {
	      validate: (0, _utils.assertNodeType)("Expression")
	    },
	    right: {
	      validate: (0, _utils.assertNodeType)("Expression")
	    }
	  },
	  visitor: ["left", "right"],
	  aliases: ["Binary", "Expression"]
	});
	(0, _utils.default)("InterpreterDirective", {
	  builder: ["value"],
	  fields: {
	    value: {
	      validate: (0, _utils.assertValueType)("string")
	    }
	  }
	});
	(0, _utils.default)("Directive", {
	  visitor: ["value"],
	  fields: {
	    value: {
	      validate: (0, _utils.assertNodeType)("DirectiveLiteral")
	    }
	  }
	});
	(0, _utils.default)("DirectiveLiteral", {
	  builder: ["value"],
	  fields: {
	    value: {
	      validate: (0, _utils.assertValueType)("string")
	    }
	  }
	});
	(0, _utils.default)("BlockStatement", {
	  builder: ["body", "directives"],
	  visitor: ["directives", "body"],
	  fields: {
	    directives: {
	      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Directive"))),
	      default: []
	    },
	    body: {
	      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Statement")))
	    }
	  },
	  aliases: ["Scopable", "BlockParent", "Block", "Statement"]
	});
	(0, _utils.default)("BreakStatement", {
	  visitor: ["label"],
	  fields: {
	    label: {
	      validate: (0, _utils.assertNodeType)("Identifier"),
	      optional: true
	    }
	  },
	  aliases: ["Statement", "Terminatorless", "CompletionStatement"]
	});
	(0, _utils.default)("CallExpression", {
	  visitor: ["callee", "arguments", "typeParameters", "typeArguments"],
	  builder: ["callee", "arguments"],
	  aliases: ["Expression"],
	  fields: {
	    callee: {
	      validate: (0, _utils.assertNodeType)("Expression")
	    },
	    arguments: {
	      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression", "SpreadElement", "JSXNamespacedName")))
	    },
	    optional: {
	      validate: (0, _utils.assertOneOf)(true, false),
	      optional: true
	    },
	    typeArguments: {
	      validate: (0, _utils.assertNodeType)("TypeParameterInstantiation"),
	      optional: true
	    },
	    typeParameters: {
	      validate: (0, _utils.assertNodeType)("TSTypeParameterInstantiation"),
	      optional: true
	    }
	  }
	});
	(0, _utils.default)("CatchClause", {
	  visitor: ["param", "body"],
	  fields: {
	    param: {
	      validate: (0, _utils.assertNodeType)("Identifier"),
	      optional: true
	    },
	    body: {
	      validate: (0, _utils.assertNodeType)("BlockStatement")
	    }
	  },
	  aliases: ["Scopable", "BlockParent"]
	});
	(0, _utils.default)("ConditionalExpression", {
	  visitor: ["test", "consequent", "alternate"],
	  fields: {
	    test: {
	      validate: (0, _utils.assertNodeType)("Expression")
	    },
	    consequent: {
	      validate: (0, _utils.assertNodeType)("Expression")
	    },
	    alternate: {
	      validate: (0, _utils.assertNodeType)("Expression")
	    }
	  },
	  aliases: ["Expression", "Conditional"]
	});
	(0, _utils.default)("ContinueStatement", {
	  visitor: ["label"],
	  fields: {
	    label: {
	      validate: (0, _utils.assertNodeType)("Identifier"),
	      optional: true
	    }
	  },
	  aliases: ["Statement", "Terminatorless", "CompletionStatement"]
	});
	(0, _utils.default)("DebuggerStatement", {
	  aliases: ["Statement"]
	});
	(0, _utils.default)("DoWhileStatement", {
	  visitor: ["test", "body"],
	  fields: {
	    test: {
	      validate: (0, _utils.assertNodeType)("Expression")
	    },
	    body: {
	      validate: (0, _utils.assertNodeType)("Statement")
	    }
	  },
	  aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"]
	});
	(0, _utils.default)("EmptyStatement", {
	  aliases: ["Statement"]
	});
	(0, _utils.default)("ExpressionStatement", {
	  visitor: ["expression"],
	  fields: {
	    expression: {
	      validate: (0, _utils.assertNodeType)("Expression")
	    }
	  },
	  aliases: ["Statement", "ExpressionWrapper"]
	});
	(0, _utils.default)("File", {
	  builder: ["program", "comments", "tokens"],
	  visitor: ["program"],
	  fields: {
	    program: {
	      validate: (0, _utils.assertNodeType)("Program")
	    }
	  }
	});
	(0, _utils.default)("ForInStatement", {
	  visitor: ["left", "right", "body"],
	  aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
	  fields: {
	    left: {
	      validate: (0, _utils.assertNodeType)("VariableDeclaration", "LVal")
	    },
	    right: {
	      validate: (0, _utils.assertNodeType)("Expression")
	    },
	    body: {
	      validate: (0, _utils.assertNodeType)("Statement")
	    }
	  }
	});
	(0, _utils.default)("ForStatement", {
	  visitor: ["init", "test", "update", "body"],
	  aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop"],
	  fields: {
	    init: {
	      validate: (0, _utils.assertNodeType)("VariableDeclaration", "Expression"),
	      optional: true
	    },
	    test: {
	      validate: (0, _utils.assertNodeType)("Expression"),
	      optional: true
	    },
	    update: {
	      validate: (0, _utils.assertNodeType)("Expression"),
	      optional: true
	    },
	    body: {
	      validate: (0, _utils.assertNodeType)("Statement")
	    }
	  }
	});
	const functionCommon = {
	  params: {
	    validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("LVal")))
	  },
	  generator: {
	    default: false,
	    validate: (0, _utils.assertValueType)("boolean")
	  },
	  async: {
	    validate: (0, _utils.assertValueType)("boolean"),
	    default: false
	  }
	};
	exports.functionCommon = functionCommon;
	const functionTypeAnnotationCommon = {
	  returnType: {
	    validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
	    optional: true
	  },
	  typeParameters: {
	    validate: (0, _utils.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
	    optional: true
	  }
	};
	exports.functionTypeAnnotationCommon = functionTypeAnnotationCommon;
	const functionDeclarationCommon = Object.assign({}, functionCommon, {
	  declare: {
	    validate: (0, _utils.assertValueType)("boolean"),
	    optional: true
	  },
	  id: {
	    validate: (0, _utils.assertNodeType)("Identifier"),
	    optional: true
	  }
	});
	exports.functionDeclarationCommon = functionDeclarationCommon;
	(0, _utils.default)("FunctionDeclaration", {
	  builder: ["id", "params", "body", "generator", "async"],
	  visitor: ["id", "params", "body", "returnType", "typeParameters"],
	  fields: Object.assign({}, functionDeclarationCommon, functionTypeAnnotationCommon, {
	    body: {
	      validate: (0, _utils.assertNodeType)("BlockStatement")
	    }
	  }),
	  aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Statement", "Pureish", "Declaration"]
	});
	(0, _utils.default)("FunctionExpression", {
	  inherits: "FunctionDeclaration",
	  aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"],
	  fields: Object.assign({}, functionCommon, functionTypeAnnotationCommon, {
	    id: {
	      validate: (0, _utils.assertNodeType)("Identifier"),
	      optional: true
	    },
	    body: {
	      validate: (0, _utils.assertNodeType)("BlockStatement")
	    }
	  })
	});
	const patternLikeCommon = {
	  typeAnnotation: {
	    validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
	    optional: true
	  },
	  decorators: {
	    validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator")))
	  }
	};
	exports.patternLikeCommon = patternLikeCommon;
	(0, _utils.default)("Identifier", {
	  builder: ["name"],
	  visitor: ["typeAnnotation"],
	  aliases: ["Expression", "PatternLike", "LVal", "TSEntityName"],
	  fields: Object.assign({}, patternLikeCommon, {
	    name: {
	      validate: (0, _utils.chain)(function (node, key, val) {
	        if (!(0, _isValidIdentifier.default)(val)) {}
	      }, (0, _utils.assertValueType)("string"))
	    },
	    optional: {
	      validate: (0, _utils.assertValueType)("boolean"),
	      optional: true
	    }
	  })
	});
	(0, _utils.default)("IfStatement", {
	  visitor: ["test", "consequent", "alternate"],
	  aliases: ["Statement", "Conditional"],
	  fields: {
	    test: {
	      validate: (0, _utils.assertNodeType)("Expression")
	    },
	    consequent: {
	      validate: (0, _utils.assertNodeType)("Statement")
	    },
	    alternate: {
	      optional: true,
	      validate: (0, _utils.assertNodeType)("Statement")
	    }
	  }
	});
	(0, _utils.default)("LabeledStatement", {
	  visitor: ["label", "body"],
	  aliases: ["Statement"],
	  fields: {
	    label: {
	      validate: (0, _utils.assertNodeType)("Identifier")
	    },
	    body: {
	      validate: (0, _utils.assertNodeType)("Statement")
	    }
	  }
	});
	(0, _utils.default)("StringLiteral", {
	  builder: ["value"],
	  fields: {
	    value: {
	      validate: (0, _utils.assertValueType)("string")
	    }
	  },
	  aliases: ["Expression", "Pureish", "Literal", "Immutable"]
	});
	(0, _utils.default)("NumericLiteral", {
	  builder: ["value"],
	  deprecatedAlias: "NumberLiteral",
	  fields: {
	    value: {
	      validate: (0, _utils.assertValueType)("number")
	    }
	  },
	  aliases: ["Expression", "Pureish", "Literal", "Immutable"]
	});
	(0, _utils.default)("NullLiteral", {
	  aliases: ["Expression", "Pureish", "Literal", "Immutable"]
	});
	(0, _utils.default)("BooleanLiteral", {
	  builder: ["value"],
	  fields: {
	    value: {
	      validate: (0, _utils.assertValueType)("boolean")
	    }
	  },
	  aliases: ["Expression", "Pureish", "Literal", "Immutable"]
	});
	(0, _utils.default)("RegExpLiteral", {
	  builder: ["pattern", "flags"],
	  deprecatedAlias: "RegexLiteral",
	  aliases: ["Expression", "Literal"],
	  fields: {
	    pattern: {
	      validate: (0, _utils.assertValueType)("string")
	    },
	    flags: {
	      validate: (0, _utils.assertValueType)("string"),
	      default: ""
	    }
	  }
	});
	(0, _utils.default)("LogicalExpression", {
	  builder: ["operator", "left", "right"],
	  visitor: ["left", "right"],
	  aliases: ["Binary", "Expression"],
	  fields: {
	    operator: {
	      validate: (0, _utils.assertOneOf)(..._constants.LOGICAL_OPERATORS)
	    },
	    left: {
	      validate: (0, _utils.assertNodeType)("Expression")
	    },
	    right: {
	      validate: (0, _utils.assertNodeType)("Expression")
	    }
	  }
	});
	(0, _utils.default)("MemberExpression", {
	  builder: ["object", "property", "computed", "optional"],
	  visitor: ["object", "property"],
	  aliases: ["Expression", "LVal"],
	  fields: {
	    object: {
	      validate: (0, _utils.assertNodeType)("Expression")
	    },
	    property: {
	      validate: function () {
	        const normal = (0, _utils.assertNodeType)("Identifier", "PrivateName");
	        const computed = (0, _utils.assertNodeType)("Expression");
	        return function (node, key, val) {
	          const validator = node.computed ? computed : normal;
	          validator(node, key, val);
	        };
	      }()
	    },
	    computed: {
	      default: false
	    },
	    optional: {
	      validate: (0, _utils.assertOneOf)(true, false),
	      optional: true
	    }
	  }
	});
	(0, _utils.default)("NewExpression", {
	  inherits: "CallExpression"
	});
	(0, _utils.default)("Program", {
	  visitor: ["directives", "body"],
	  builder: ["body", "directives", "sourceType", "interpreter"],
	  fields: {
	    sourceFile: {
	      validate: (0, _utils.assertValueType)("string")
	    },
	    sourceType: {
	      validate: (0, _utils.assertOneOf)("script", "module"),
	      default: "script"
	    },
	    interpreter: {
	      validate: (0, _utils.assertNodeType)("InterpreterDirective"),
	      default: null,
	      optional: true
	    },
	    directives: {
	      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Directive"))),
	      default: []
	    },
	    body: {
	      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Statement")))
	    }
	  },
	  aliases: ["Scopable", "BlockParent", "Block"]
	});
	(0, _utils.default)("ObjectExpression", {
	  visitor: ["properties"],
	  aliases: ["Expression"],
	  fields: {
	    properties: {
	      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ObjectMethod", "ObjectProperty", "SpreadElement")))
	    }
	  }
	});
	(0, _utils.default)("ObjectMethod", {
	  builder: ["kind", "key", "params", "body", "computed"],
	  fields: Object.assign({}, functionCommon, functionTypeAnnotationCommon, {
	    kind: {
	      validate: (0, _utils.chain)((0, _utils.assertValueType)("string"), (0, _utils.assertOneOf)("method", "get", "set")),
	      default: "method"
	    },
	    computed: {
	      validate: (0, _utils.assertValueType)("boolean"),
	      default: false
	    },
	    key: {
	      validate: function () {
	        const normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral");
	        const computed = (0, _utils.assertNodeType)("Expression");
	        return function (node, key, val) {
	          const validator = node.computed ? computed : normal;
	          validator(node, key, val);
	        };
	      }()
	    },
	    decorators: {
	      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator")))
	    },
	    body: {
	      validate: (0, _utils.assertNodeType)("BlockStatement")
	    }
	  }),
	  visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"],
	  aliases: ["UserWhitespacable", "Function", "Scopable", "BlockParent", "FunctionParent", "Method", "ObjectMember"]
	});
	(0, _utils.default)("ObjectProperty", {
	  builder: ["key", "value", "computed", "shorthand", "decorators"],
	  fields: {
	    computed: {
	      validate: (0, _utils.assertValueType)("boolean"),
	      default: false
	    },
	    key: {
	      validate: function () {
	        const normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral");
	        const computed = (0, _utils.assertNodeType)("Expression");
	        return function (node, key, val) {
	          const validator = node.computed ? computed : normal;
	          validator(node, key, val);
	        };
	      }()
	    },
	    value: {
	      validate: (0, _utils.assertNodeType)("Expression", "PatternLike")
	    },
	    shorthand: {
	      validate: (0, _utils.assertValueType)("boolean"),
	      default: false
	    },
	    decorators: {
	      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
	      optional: true
	    }
	  },
	  visitor: ["key", "value", "decorators"],
	  aliases: ["UserWhitespacable", "Property", "ObjectMember"]
	});
	(0, _utils.default)("RestElement", {
	  visitor: ["argument", "typeAnnotation"],
	  builder: ["argument"],
	  aliases: ["LVal", "PatternLike"],
	  deprecatedAlias: "RestProperty",
	  fields: Object.assign({}, patternLikeCommon, {
	    argument: {
	      validate: (0, _utils.assertNodeType)("LVal")
	    }
	  })
	});
	(0, _utils.default)("ReturnStatement", {
	  visitor: ["argument"],
	  aliases: ["Statement", "Terminatorless", "CompletionStatement"],
	  fields: {
	    argument: {
	      validate: (0, _utils.assertNodeType)("Expression"),
	      optional: true
	    }
	  }
	});
	(0, _utils.default)("SequenceExpression", {
	  visitor: ["expressions"],
	  fields: {
	    expressions: {
	      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression")))
	    }
	  },
	  aliases: ["Expression"]
	});
	(0, _utils.default)("SwitchCase", {
	  visitor: ["test", "consequent"],
	  fields: {
	    test: {
	      validate: (0, _utils.assertNodeType)("Expression"),
	      optional: true
	    },
	    consequent: {
	      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Statement")))
	    }
	  }
	});
	(0, _utils.default)("SwitchStatement", {
	  visitor: ["discriminant", "cases"],
	  aliases: ["Statement", "BlockParent", "Scopable"],
	  fields: {
	    discriminant: {
	      validate: (0, _utils.assertNodeType)("Expression")
	    },
	    cases: {
	      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("SwitchCase")))
	    }
	  }
	});
	(0, _utils.default)("ThisExpression", {
	  aliases: ["Expression"]
	});
	(0, _utils.default)("ThrowStatement", {
	  visitor: ["argument"],
	  aliases: ["Statement", "Terminatorless", "CompletionStatement"],
	  fields: {
	    argument: {
	      validate: (0, _utils.assertNodeType)("Expression")
	    }
	  }
	});
	(0, _utils.default)("TryStatement", {
	  visitor: ["block", "handler", "finalizer"],
	  aliases: ["Statement"],
	  fields: {
	    block: {
	      validate: (0, _utils.assertNodeType)("BlockStatement")
	    },
	    handler: {
	      optional: true,
	      validate: (0, _utils.assertNodeType)("CatchClause")
	    },
	    finalizer: {
	      optional: true,
	      validate: (0, _utils.assertNodeType)("BlockStatement")
	    }
	  }
	});
	(0, _utils.default)("UnaryExpression", {
	  builder: ["operator", "argument", "prefix"],
	  fields: {
	    prefix: {
	      default: true
	    },
	    argument: {
	      validate: (0, _utils.assertNodeType)("Expression")
	    },
	    operator: {
	      validate: (0, _utils.assertOneOf)(..._constants.UNARY_OPERATORS)
	    }
	  },
	  visitor: ["argument"],
	  aliases: ["UnaryLike", "Expression"]
	});
	(0, _utils.default)("UpdateExpression", {
	  builder: ["operator", "argument", "prefix"],
	  fields: {
	    prefix: {
	      default: false
	    },
	    argument: {
	      validate: (0, _utils.assertNodeType)("Expression")
	    },
	    operator: {
	      validate: (0, _utils.assertOneOf)(..._constants.UPDATE_OPERATORS)
	    }
	  },
	  visitor: ["argument"],
	  aliases: ["Expression"]
	});
	(0, _utils.default)("VariableDeclaration", {
	  builder: ["kind", "declarations"],
	  visitor: ["declarations"],
	  aliases: ["Statement", "Declaration"],
	  fields: {
	    declare: {
	      validate: (0, _utils.assertValueType)("boolean"),
	      optional: true
	    },
	    kind: {
	      validate: (0, _utils.chain)((0, _utils.assertValueType)("string"), (0, _utils.assertOneOf)("var", "let", "const"))
	    },
	    declarations: {
	      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("VariableDeclarator")))
	    }
	  }
	});
	(0, _utils.default)("VariableDeclarator", {
	  visitor: ["id", "init"],
	  fields: {
	    id: {
	      validate: (0, _utils.assertNodeType)("LVal")
	    },
	    definite: {
	      optional: true,
	      validate: (0, _utils.assertValueType)("boolean")
	    },
	    init: {
	      optional: true,
	      validate: (0, _utils.assertNodeType)("Expression")
	    }
	  }
	});
	(0, _utils.default)("WhileStatement", {
	  visitor: ["test", "body"],
	  aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"],
	  fields: {
	    test: {
	      validate: (0, _utils.assertNodeType)("Expression")
	    },
	    body: {
	      validate: (0, _utils.assertNodeType)("BlockStatement", "Statement")
	    }
	  }
	});
	(0, _utils.default)("WithStatement", {
	  visitor: ["object", "body"],
	  aliases: ["Statement"],
	  fields: {
	    object: {
	      validate: (0, _utils.assertNodeType)("Expression")
	    },
	    body: {
	      validate: (0, _utils.assertNodeType)("BlockStatement", "Statement")
	    }
	  }
	});

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.classMethodOrDeclareMethodCommon = exports.classMethodOrPropertyCommon = void 0;

	var _utils = _interopRequireWildcard(__webpack_require__(15));

	var _core = __webpack_require__(27);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

	(0, _utils.default)("AssignmentPattern", {
	  visitor: ["left", "right"],
	  builder: ["left", "right"],
	  aliases: ["Pattern", "PatternLike", "LVal"],
	  fields: Object.assign({}, _core.patternLikeCommon, {
	    left: {
	      validate: (0, _utils.assertNodeType)("Identifier", "ObjectPattern", "ArrayPattern")
	    },
	    right: {
	      validate: (0, _utils.assertNodeType)("Expression")
	    },
	    decorators: {
	      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator")))
	    }
	  })
	});
	(0, _utils.default)("ArrayPattern", {
	  visitor: ["elements", "typeAnnotation"],
	  builder: ["elements"],
	  aliases: ["Pattern", "PatternLike", "LVal"],
	  fields: Object.assign({}, _core.patternLikeCommon, {
	    elements: {
	      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("PatternLike")))
	    },
	    decorators: {
	      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator")))
	    }
	  })
	});
	(0, _utils.default)("ArrowFunctionExpression", {
	  builder: ["params", "body", "async"],
	  visitor: ["params", "body", "returnType", "typeParameters"],
	  aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"],
	  fields: Object.assign({}, _core.functionCommon, _core.functionTypeAnnotationCommon, {
	    expression: {
	      validate: (0, _utils.assertValueType)("boolean")
	    },
	    body: {
	      validate: (0, _utils.assertNodeType)("BlockStatement", "Expression")
	    }
	  })
	});
	(0, _utils.default)("ClassBody", {
	  visitor: ["body"],
	  fields: {
	    body: {
	      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ClassMethod", "ClassProperty", "ClassPrivateProperty", "TSDeclareMethod", "TSIndexSignature")))
	    }
	  }
	});
	const classCommon = {
	  typeParameters: {
	    validate: (0, _utils.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
	    optional: true
	  },
	  body: {
	    validate: (0, _utils.assertNodeType)("ClassBody")
	  },
	  superClass: {
	    optional: true,
	    validate: (0, _utils.assertNodeType)("Expression")
	  },
	  superTypeParameters: {
	    validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
	    optional: true
	  },
	  implements: {
	    validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("TSExpressionWithTypeArguments", "ClassImplements"))),
	    optional: true
	  }
	};
	(0, _utils.default)("ClassDeclaration", {
	  builder: ["id", "superClass", "body", "decorators"],
	  visitor: ["id", "body", "superClass", "mixins", "typeParameters", "superTypeParameters", "implements", "decorators"],
	  aliases: ["Scopable", "Class", "Statement", "Declaration", "Pureish"],
	  fields: Object.assign({}, classCommon, {
	    declare: {
	      validate: (0, _utils.assertValueType)("boolean"),
	      optional: true
	    },
	    abstract: {
	      validate: (0, _utils.assertValueType)("boolean"),
	      optional: true
	    },
	    id: {
	      validate: (0, _utils.assertNodeType)("Identifier"),
	      optional: true
	    },
	    decorators: {
	      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
	      optional: true
	    }
	  })
	});
	(0, _utils.default)("ClassExpression", {
	  inherits: "ClassDeclaration",
	  aliases: ["Scopable", "Class", "Expression", "Pureish"],
	  fields: Object.assign({}, classCommon, {
	    id: {
	      optional: true,
	      validate: (0, _utils.assertNodeType)("Identifier")
	    },
	    body: {
	      validate: (0, _utils.assertNodeType)("ClassBody")
	    },
	    superClass: {
	      optional: true,
	      validate: (0, _utils.assertNodeType)("Expression")
	    },
	    decorators: {
	      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
	      optional: true
	    }
	  })
	});
	(0, _utils.default)("ExportAllDeclaration", {
	  visitor: ["source"],
	  aliases: ["Statement", "Declaration", "ModuleDeclaration", "ExportDeclaration"],
	  fields: {
	    source: {
	      validate: (0, _utils.assertNodeType)("StringLiteral")
	    }
	  }
	});
	(0, _utils.default)("ExportDefaultDeclaration", {
	  visitor: ["declaration"],
	  aliases: ["Statement", "Declaration", "ModuleDeclaration", "ExportDeclaration"],
	  fields: {
	    declaration: {
	      validate: (0, _utils.assertNodeType)("FunctionDeclaration", "TSDeclareFunction", "ClassDeclaration", "Expression")
	    }
	  }
	});
	(0, _utils.default)("ExportNamedDeclaration", {
	  visitor: ["declaration", "specifiers", "source"],
	  aliases: ["Statement", "Declaration", "ModuleDeclaration", "ExportDeclaration"],
	  fields: {
	    declaration: {
	      validate: (0, _utils.assertNodeType)("Declaration"),
	      optional: true
	    },
	    specifiers: {
	      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ExportSpecifier", "ExportDefaultSpecifier", "ExportNamespaceSpecifier")))
	    },
	    source: {
	      validate: (0, _utils.assertNodeType)("StringLiteral"),
	      optional: true
	    }
	  }
	});
	(0, _utils.default)("ExportSpecifier", {
	  visitor: ["local", "exported"],
	  aliases: ["ModuleSpecifier"],
	  fields: {
	    local: {
	      validate: (0, _utils.assertNodeType)("Identifier")
	    },
	    exported: {
	      validate: (0, _utils.assertNodeType)("Identifier")
	    }
	  }
	});
	(0, _utils.default)("ForOfStatement", {
	  visitor: ["left", "right", "body"],
	  aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
	  fields: {
	    left: {
	      validate: (0, _utils.assertNodeType)("VariableDeclaration", "LVal")
	    },
	    right: {
	      validate: (0, _utils.assertNodeType)("Expression")
	    },
	    body: {
	      validate: (0, _utils.assertNodeType)("Statement")
	    },
	    await: {
	      default: false,
	      validate: (0, _utils.assertValueType)("boolean")
	    }
	  }
	});
	(0, _utils.default)("ImportDeclaration", {
	  visitor: ["specifiers", "source"],
	  aliases: ["Statement", "Declaration", "ModuleDeclaration"],
	  fields: {
	    specifiers: {
	      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ImportSpecifier", "ImportDefaultSpecifier", "ImportNamespaceSpecifier")))
	    },
	    source: {
	      validate: (0, _utils.assertNodeType)("StringLiteral")
	    }
	  }
	});
	(0, _utils.default)("ImportDefaultSpecifier", {
	  visitor: ["local"],
	  aliases: ["ModuleSpecifier"],
	  fields: {
	    local: {
	      validate: (0, _utils.assertNodeType)("Identifier")
	    }
	  }
	});
	(0, _utils.default)("ImportNamespaceSpecifier", {
	  visitor: ["local"],
	  aliases: ["ModuleSpecifier"],
	  fields: {
	    local: {
	      validate: (0, _utils.assertNodeType)("Identifier")
	    }
	  }
	});
	(0, _utils.default)("ImportSpecifier", {
	  visitor: ["local", "imported"],
	  aliases: ["ModuleSpecifier"],
	  fields: {
	    local: {
	      validate: (0, _utils.assertNodeType)("Identifier")
	    },
	    imported: {
	      validate: (0, _utils.assertNodeType)("Identifier")
	    },
	    importKind: {
	      validate: (0, _utils.assertOneOf)(null, "type", "typeof")
	    }
	  }
	});
	(0, _utils.default)("MetaProperty", {
	  visitor: ["meta", "property"],
	  aliases: ["Expression"],
	  fields: {
	    meta: {
	      validate: (0, _utils.assertNodeType)("Identifier")
	    },
	    property: {
	      validate: (0, _utils.assertNodeType)("Identifier")
	    }
	  }
	});
	const classMethodOrPropertyCommon = {
	  abstract: {
	    validate: (0, _utils.assertValueType)("boolean"),
	    optional: true
	  },
	  accessibility: {
	    validate: (0, _utils.chain)((0, _utils.assertValueType)("string"), (0, _utils.assertOneOf)("public", "private", "protected")),
	    optional: true
	  },
	  static: {
	    validate: (0, _utils.assertValueType)("boolean"),
	    optional: true
	  },
	  computed: {
	    default: false,
	    validate: (0, _utils.assertValueType)("boolean")
	  },
	  optional: {
	    validate: (0, _utils.assertValueType)("boolean"),
	    optional: true
	  },
	  key: {
	    validate: (0, _utils.chain)(function () {
	      const normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral");
	      const computed = (0, _utils.assertNodeType)("Expression");
	      return function (node, key, val) {
	        const validator = node.computed ? computed : normal;
	        validator(node, key, val);
	      };
	    }(), (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "Expression"))
	  }
	};
	exports.classMethodOrPropertyCommon = classMethodOrPropertyCommon;
	const classMethodOrDeclareMethodCommon = Object.assign({}, _core.functionCommon, classMethodOrPropertyCommon, {
	  kind: {
	    validate: (0, _utils.chain)((0, _utils.assertValueType)("string"), (0, _utils.assertOneOf)("get", "set", "method", "constructor")),
	    default: "method"
	  },
	  access: {
	    validate: (0, _utils.chain)((0, _utils.assertValueType)("string"), (0, _utils.assertOneOf)("public", "private", "protected")),
	    optional: true
	  },
	  decorators: {
	    validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
	    optional: true
	  }
	});
	exports.classMethodOrDeclareMethodCommon = classMethodOrDeclareMethodCommon;
	(0, _utils.default)("ClassMethod", {
	  aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method"],
	  builder: ["kind", "key", "params", "body", "computed", "static"],
	  visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"],
	  fields: Object.assign({}, classMethodOrDeclareMethodCommon, _core.functionTypeAnnotationCommon, {
	    body: {
	      validate: (0, _utils.assertNodeType)("BlockStatement")
	    }
	  })
	});
	(0, _utils.default)("ObjectPattern", {
	  visitor: ["properties", "typeAnnotation"],
	  builder: ["properties"],
	  aliases: ["Pattern", "PatternLike", "LVal"],
	  fields: Object.assign({}, _core.patternLikeCommon, {
	    properties: {
	      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("RestElement", "ObjectProperty")))
	    }
	  })
	});
	(0, _utils.default)("SpreadElement", {
	  visitor: ["argument"],
	  aliases: ["UnaryLike"],
	  deprecatedAlias: "SpreadProperty",
	  fields: {
	    argument: {
	      validate: (0, _utils.assertNodeType)("Expression")
	    }
	  }
	});
	(0, _utils.default)("Super", {
	  aliases: ["Expression"]
	});
	(0, _utils.default)("TaggedTemplateExpression", {
	  visitor: ["tag", "quasi"],
	  aliases: ["Expression"],
	  fields: {
	    tag: {
	      validate: (0, _utils.assertNodeType)("Expression")
	    },
	    quasi: {
	      validate: (0, _utils.assertNodeType)("TemplateLiteral")
	    },
	    typeParameters: {
	      validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
	      optional: true
	    }
	  }
	});
	(0, _utils.default)("TemplateElement", {
	  builder: ["value", "tail"],
	  fields: {
	    value: {},
	    tail: {
	      validate: (0, _utils.assertValueType)("boolean"),
	      default: false
	    }
	  }
	});
	(0, _utils.default)("TemplateLiteral", {
	  visitor: ["quasis", "expressions"],
	  aliases: ["Expression", "Literal"],
	  fields: {
	    quasis: {
	      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("TemplateElement")))
	    },
	    expressions: {
	      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression")))
	    }
	  }
	});
	(0, _utils.default)("YieldExpression", {
	  builder: ["argument", "delegate"],
	  visitor: ["argument"],
	  aliases: ["Expression", "Terminatorless"],
	  fields: {
	    delegate: {
	      validate: (0, _utils.assertValueType)("boolean"),
	      default: false
	    },
	    argument: {
	      optional: true,
	      validate: (0, _utils.assertNodeType)("Expression")
	    }
	  }
	});

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = inherit;

	function _uniq() {
	  const data = _interopRequireDefault(__webpack_require__(156));

	  _uniq = function () {
	    return data;
	  };

	  return data;
	}

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function inherit(key, child, parent) {
	  if (child && parent) {
	    child[key] = (0, _uniq().default)([].concat(child[key], parent[key]).filter(Boolean));
	  }
	}

/***/ }),
/* 30 */
/***/ (function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = shallowEqual;

	function shallowEqual(actual, expected) {
	  const keys = Object.keys(expected);

	  for (const key of keys) {
	    if (actual[key] !== expected[key]) {
	      return false;
	    }
	  }

	  return true;
	}

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = is;

	var _shallowEqual = _interopRequireDefault(__webpack_require__(30));

	var _isType = _interopRequireDefault(__webpack_require__(32));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function is(type, node, opts) {
	  if (!node) return false;
	  const matches = (0, _isType.default)(node.type, type);
	  if (!matches) return false;

	  if (typeof opts === "undefined") {
	    return true;
	  } else {
	    return (0, _shallowEqual.default)(node, opts);
	  }
	}

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = isType;

	var _definitions = __webpack_require__(14);

	function isType(nodeType, targetType) {
	  if (nodeType === targetType) return true;
	  if (_definitions.ALIAS_KEYS[targetType]) return false;
	  const aliases = _definitions.FLIPPED_ALIAS_KEYS[targetType];

	  if (aliases) {
	    if (aliases[0] === nodeType) return true;

	    for (const alias of aliases) {
	      if (nodeType === alias) return true;
	    }
	  }

	  return false;
	}

/***/ }),
/* 33 */
/***/ (function(module, exports) {

	module.exports = require("babel-runtime/helpers/asyncToGenerator");

/***/ }),
/* 34 */
/***/ (function(module, exports) {

	module.exports = require("babel-runtime/helpers/classCallCheck");

/***/ }),
/* 35 */
/***/ (function(module, exports) {

	module.exports = require("crypto");

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 *  strict-local
	 * @format
	 */

	'use strict';

	/**
	 * Creates a scope for a `Root`, with each argument mapped to a variable of the
	 * same name. Example:
	 *
	 * Query:
	 * query Foo($id: ID, $size: Int = 42) { ... }
	 *
	 * Scope:
	 * {
	 *   id: $id,
	 *   size: $size,
	 * }
	 *
	 * Note that even though a default value is defined for $size, the scope must
	 * assume that this could be overridden at runtime. The value cannot be decided
	 * statically and therefore is set to a variable.
	 */


	/**
	 * A scope is a mapping of the values for each argument defined by the nearest
	 * ancestor root or fragment of a given IR selection. A scope maps argument
	 * names to the argument's statically determined value, which can be either a
	 * variable or a literal.
	 *
	 * There are two categories of scopes: root scopes and fragment scopes.
	 *
	 * Root scopes apply to `Root` IR and their subselections, up until any fragment
	 * spreads. Root scopes have the property that any argument may be provided at
	 * runtime: even where a default value is defined, the compiler must consider
	 * the value to be variable. Therefore, root scopes are a mapping of argument
	 * name to variables of the same name:
	 *
	 *   Map {
	 *     foo: $foo
	 *   }
	 *
	 * Fragment scopes apply to `Fragment` IR nodes and their subselections, up
	 * until any fragment spreads. Fragment scopes differ from root scopes in
	 * several ways:
	 * - Arguments may be overridden by the including fragment spread.
	 * - Arguments may import values from the root scope.
	 * - All other arguments must have their default values, or be null.
	 *
	 * Fragment scopes are also a mapping of argument name to value, but the value
	 * may also be a literal:
	 *
	 *   Map {
	 *     foo: $foo
	 *     bar: 42
	 *   }
	 */
	function getRootScope(definitions) {
	  var scope = {};
	  definitions.forEach(function (definition) {
	    scope[definition.name] = {
	      kind: 'Variable',
	      variableName: definition.name
	    };
	  });
	  return scope;
	}

	/**
	 * Creates a scope for a `Fragment` by translating fragment spread arguments in
	 * the context of a parent scope into a new scope and validating them against
	 * the argument definitions.
	 *
	 *
	 * Parent Scope:
	 * {
	 *   active: $parentActive
	 * }
	 *
	 * Fragment Spread:
	 * ...Bar(size: 42, enabled: $active)
	 *
	 * Fragment:
	 * fragment Bar on Foo @argumentDefinitions(
	 *   id: {type: "ID"}
	 *   size: {type: "Int"}
	 *   enabled: {type: "Boolean}
	 *   scale: {type: "Int", imports: "pixelRatio"}
	 * )
	 *
	 * Scope:
	 * {
	 *   // No argument is provided for $id, it gets the default value which in this
	 *   // case is `null`:
	 *   id: null,
	 *
	 *   // The parent passes 42 as a literal value for $size:
	 *   size: 42,
	 *
	 *   // The parent passes a variable as the value of $enabled. This variable is
	 *   // resolved in the parent scope to the value $parentActive, which becomes
	 *   // the value of $enabled:
	 *   $enabled: $parentActive,
	 *
	 *   // $scale imports pixelRatio from the root scope. Since any argument in a
	 *   // root scope maps to a variable of the same name, that means the value of
	 *   // pixelRatio in the root is $pixelRatio:
	 *   $scale: $pixelRatio,
	 * }
	 */
	function getFragmentScope(definitions, args, parentScope, fragmentName) {
	  var argMap = {};
	  args.forEach(function (arg) {
	    if (arg.value.kind === 'Literal') {
	      argMap[arg.name] = arg.value;
	    } else if (arg.value.kind === 'Variable') {
	      argMap[arg.name] = parentScope[arg.value.variableName];
	    }
	  });

	  var fragmentScope = {};
	  definitions.forEach(function (definition) {
	    if (definition.kind === 'RootArgumentDefinition') {
	      !!argMap.hasOwnProperty(definition.name) ?  true ? __webpack_require__(4)(false, 'RelayCompilerScope: Unexpected argument for global variable `%s` ' + 'for `%s`. @arguments may only be provided for variables ' + "defined in the fragment's @argumentDefinitions list.", definition.name, fragmentName) : require('fbjs/lib/invariant')(false) : void 0;
	      fragmentScope[definition.name] = {
	        kind: 'Variable',
	        variableName: definition.name
	      };
	    } else {
	      var arg = argMap[definition.name];
	      if (arg == null || arg.kind === 'Literal' && arg.value == null) {
	        // No variable or literal null was passed, fall back to default
	        // value.
	        !(definition.defaultValue != null || !(definition.type instanceof __webpack_require__(3).GraphQLNonNull)) ?  true ? __webpack_require__(4)(false, 'RelayCompilerScope: No value found for required argument ' + '`$%s: %s` in `%s`.', definition.name, definition.type.toString(), fragmentName) : require('fbjs/lib/invariant')(false) : void 0;
	        fragmentScope[definition.name] = {
	          kind: 'Literal',
	          value: definition.defaultValue
	        };
	      } else {
	        // Variable or non-null literal.
	        fragmentScope[definition.name] = arg;
	      }
	    }
	  });
	  return fragmentScope;
	}

	module.exports = { getFragmentScope: getFragmentScope, getRootScope: getRootScope };

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 * @format
	 */

	'use strict';

	var _extends3 = _interopRequireDefault(__webpack_require__(9));

	var _toConsumableArray3 = _interopRequireDefault(__webpack_require__(10));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var CONNECTION = 'connection';

	/**
	 * @public
	 *
	 * Transforms fields with the `@connection` directive:
	 * - Verifies that the field type is connection-like.
	 * - Adds a `handle` property to the field, either the user-provided `handle`
	 *   argument or the default value "connection".
	 * - Inserts a sub-fragment on the field to ensure that standard connection
	 *   fields are fetched (e.g. cursors, node ids, page info).
	 */
	function relayConnectionTransform(context) {
	  return __webpack_require__(1).IRTransformer.transform(context, {
	    Fragment: visitFragmentOrRoot,
	    LinkedField: visitLinkedField,
	    Root: visitFragmentOrRoot
	  }, function (node) {
	    return {
	      path: [],
	      connectionMetadata: [],
	      definitionName: node.name
	    };
	  });
	}

	var SCHEMA_EXTENSION = 'directive @connection(key: String!, filters: [String]) on FIELD';

	/**
	 * @internal
	 */
	function visitFragmentOrRoot(node, options) {
	  var transformedNode = this.traverse(node, options);
	  var connectionMetadata = options.connectionMetadata;
	  if (connectionMetadata.length) {
	    return (0, _extends3['default'])({}, transformedNode, {
	      metadata: (0, _extends3['default'])({}, transformedNode.metadata, {
	        connection: connectionMetadata
	      })
	    });
	  }
	  return transformedNode;
	}

	/**
	 * @internal
	 */
	function visitLinkedField(field, options) {
	  var isPlural = __webpack_require__(1).SchemaUtils.getNullableType(field.type) instanceof __webpack_require__(3).GraphQLList;
	  options.path.push(isPlural ? null : field.alias || field.name);
	  var transformedField = this.traverse(field, options);
	  var connectionDirective = field.directives.find(function (directive) {
	    return directive.name === CONNECTION;
	  });
	  if (!connectionDirective) {
	    options.path.pop();
	    return transformedField;
	  }
	  var definitionName = options.definitionName;

	  validateConnectionSelection(definitionName, transformedField);
	  validateConnectionType(definitionName, transformedField.type);

	  var pathHasPlural = options.path.includes(null);
	  var firstArg = findArg(transformedField, __webpack_require__(13).FIRST);
	  var lastArg = findArg(transformedField, __webpack_require__(13).LAST);
	  var direction = null;
	  var countArg = null;
	  var cursorArg = null;
	  if (firstArg && !lastArg) {
	    direction = 'forward';
	    countArg = firstArg;
	    cursorArg = findArg(transformedField, __webpack_require__(13).AFTER);
	  } else if (lastArg && !firstArg) {
	    direction = 'backward';
	    countArg = lastArg;
	    cursorArg = findArg(transformedField, __webpack_require__(13).BEFORE);
	  } else if (lastArg && firstArg) {
	    direction = 'bidirectional';
	    // TODO(T26511885) Maybe add connection metadata to this case
	  }
	  var countVariable = countArg && countArg.value.kind === 'Variable' ? countArg.value.variableName : null;
	  var cursorVariable = cursorArg && cursorArg.value.kind === 'Variable' ? cursorArg.value.variableName : null;
	  options.connectionMetadata.push({
	    count: countVariable,
	    cursor: cursorVariable,
	    direction: direction,
	    path: pathHasPlural ? null : [].concat((0, _toConsumableArray3['default'])(options.path))
	  });
	  options.path.pop();

	  var _getLiteralArgumentVa = __webpack_require__(1).getLiteralArgumentValues(connectionDirective.args),
	      key = _getLiteralArgumentVa.key,
	      filters = _getLiteralArgumentVa.filters;

	  !(typeof key === 'string') ?  true ? __webpack_require__(4)(false, 'RelayConnectionTransform: Expected the %s argument to @%s to ' + 'be a string literal for field %s', __webpack_require__(13).KEY, CONNECTION, field.name) : require('fbjs/lib/invariant')(false) : void 0;
	  var postfix = '' + (field.alias || field.name);
	  !key.endsWith('_' + postfix) ?  true ? __webpack_require__(4)(false, 'RelayConnectionTransform: Expected the %s argument to @%s to ' + 'be of form <SomeName>_%s, but get %s. For detailed explanation, check out the dex page ' + 'https://facebook.github.io/relay/docs/pagination-container.html#connection-directive', __webpack_require__(13).KEY, CONNECTION, postfix, key) : require('fbjs/lib/invariant')(false) : void 0;

	  var generateFilters = function generateFilters() {
	    var filteredVariableArgs = field.args.filter(function (arg) {
	      return !__webpack_require__(7).ConnectionInterface.isConnectionCall({
	        name: arg.name,
	        value: null
	      });
	    }).map(function (arg) {
	      return arg.name;
	    });
	    return filteredVariableArgs.length === 0 ? null : filteredVariableArgs;
	  };

	  var handle = {
	    name: CONNECTION,
	    key: key,
	    filters: filters || generateFilters()
	  };

	  if (direction !== null) {
	    var fragment = generateConnectionFragment(this.getContext(), transformedField.type, direction);
	    transformedField = (0, _extends3['default'])({}, transformedField, {
	      selections: transformedField.selections.concat(fragment)
	    });
	  }
	  return (0, _extends3['default'])({}, transformedField, {
	    directives: transformedField.directives.filter(function (directive) {
	      return directive.name !== CONNECTION;
	    }),
	    handles: transformedField.handles ? [].concat((0, _toConsumableArray3['default'])(transformedField.handles), [handle]) : [handle]
	  });
	}

	/**
	 * @internal
	 *
	 * Generates a fragment on the given type that fetches the minimal connection
	 * fields in order to merge different pagination results together at runtime.
	 */
	function generateConnectionFragment(context, type, direction) {
	  var _ConnectionInterface$ = __webpack_require__(7).ConnectionInterface.get(),
	      CURSOR = _ConnectionInterface$.CURSOR,
	      EDGES = _ConnectionInterface$.EDGES,
	      END_CURSOR = _ConnectionInterface$.END_CURSOR,
	      HAS_NEXT_PAGE = _ConnectionInterface$.HAS_NEXT_PAGE,
	      HAS_PREV_PAGE = _ConnectionInterface$.HAS_PREV_PAGE,
	      NODE = _ConnectionInterface$.NODE,
	      PAGE_INFO = _ConnectionInterface$.PAGE_INFO,
	      START_CURSOR = _ConnectionInterface$.START_CURSOR;

	  var compositeType = __webpack_require__(3).assertCompositeType(__webpack_require__(1).SchemaUtils.getNullableType(type));

	  var pageInfo = PAGE_INFO;
	  if (direction === 'forward') {
	    pageInfo += '{\n      ' + END_CURSOR + '\n      ' + HAS_NEXT_PAGE + '\n    }';
	  } else if (direction === 'backward') {
	    pageInfo += '{\n      ' + HAS_PREV_PAGE + '\n      ' + START_CURSOR + '\n    }';
	  } else {
	    pageInfo += '{\n      ' + END_CURSOR + '\n      ' + HAS_NEXT_PAGE + '\n      ' + HAS_PREV_PAGE + '\n      ' + START_CURSOR + '\n    }';
	  }

	  var fragmentString = 'fragment ConnectionFragment on ' + String(compositeType) + ' {\n      ' + EDGES + ' {\n        ' + CURSOR + '\n        ' + NODE + ' {\n          __typename # rely on GenerateRequisiteFieldTransform to add "id"\n        }\n      }\n      ' + pageInfo + '\n    }';

	  var ast = __webpack_require__(3).parse(fragmentString);
	  var fragmentAST = ast.definitions[0];
	  !(fragmentAST && fragmentAST.kind === 'FragmentDefinition') ?  true ? __webpack_require__(4)(false, 'RelayConnectionTransform: Expected a fragment definition AST.') : require('fbjs/lib/invariant')(false) : void 0;
	  var fragment = __webpack_require__(24).transform(context.clientSchema, fragmentAST);
	  !(fragment && fragment.kind === 'Fragment') ?  true ? __webpack_require__(4)(false, 'RelayConnectionTransform: Expected a connection fragment.') : require('fbjs/lib/invariant')(false) : void 0;
	  return {
	    directives: [],
	    kind: 'InlineFragment',
	    metadata: null,
	    selections: fragment.selections,
	    typeCondition: compositeType
	  };
	}

	function findArg(field, argName) {
	  return field.args && field.args.find(function (arg) {
	    return arg.name === argName;
	  });
	}

	/**
	 * @internal
	 *
	 * Validates that the selection is a valid connection:
	 * - Specifies a first or last argument to prevent accidental, unconstrained
	 *   data access.
	 * - Has an `edges` selection, otherwise there is nothing to paginate.
	 *
	 * TODO: This implementation requires the edges field to be a direct selection
	 * and not contained within an inline fragment or fragment spread. It's
	 * technically possible to remove this restriction if this pattern becomes
	 * common/necessary.
	 */
	function validateConnectionSelection(definitionName, field) {
	  var _ConnectionInterface$2 = __webpack_require__(7).ConnectionInterface.get(),
	      EDGES = _ConnectionInterface$2.EDGES;

	  if (!findArg(field, __webpack_require__(13).FIRST) && !findArg(field, __webpack_require__(13).LAST)) {
	    throw new Error('RelayConnectionTransform: Expected field `' + field.name + ': ' + (String(field.type) + '` to have a ' + __webpack_require__(13).FIRST + ' or ' + __webpack_require__(13).LAST + ' argument in ') + ('document `' + definitionName + '`.'));
	  }
	  if (!field.selections.some(function (selection) {
	    return selection.kind === 'LinkedField' && selection.name === EDGES;
	  })) {
	    throw new Error('RelayConnectionTransform: Expected field `' + field.name + ': ' + (String(field.type) + '` to have a ' + EDGES + ' selection in document ') + ('`' + definitionName + '`.'));
	  }
	}

	/**
	 * @internal
	 *
	 * Validates that the type satisfies the Connection specification:
	 * - The type has an edges field, and edges have scalar `cursor` and object
	 *   `node` fields.
	 * - The type has a page info field which is an object with the correct
	 *   subfields.
	 */
	function validateConnectionType(definitionName, type) {
	  var _ConnectionInterface$3 = __webpack_require__(7).ConnectionInterface.get(),
	      CURSOR = _ConnectionInterface$3.CURSOR,
	      EDGES = _ConnectionInterface$3.EDGES,
	      END_CURSOR = _ConnectionInterface$3.END_CURSOR,
	      HAS_NEXT_PAGE = _ConnectionInterface$3.HAS_NEXT_PAGE,
	      HAS_PREV_PAGE = _ConnectionInterface$3.HAS_PREV_PAGE,
	      NODE = _ConnectionInterface$3.NODE,
	      PAGE_INFO = _ConnectionInterface$3.PAGE_INFO,
	      START_CURSOR = _ConnectionInterface$3.START_CURSOR;

	  var typeWithFields = __webpack_require__(1).SchemaUtils.assertTypeWithFields(__webpack_require__(1).SchemaUtils.getNullableType(type));
	  var typeFields = typeWithFields.getFields();
	  var edges = typeFields[EDGES];

	  !edges ?  true ? __webpack_require__(4)(false, 'RelayConnectionTransform: Expected type `%s` to have an %s field in ' + 'document `%s`.', type, EDGES, definitionName) : require('fbjs/lib/invariant')(false) : void 0;

	  var edgesType = __webpack_require__(1).SchemaUtils.getNullableType(edges.type);
	  !(edgesType instanceof __webpack_require__(3).GraphQLList) ?  true ? __webpack_require__(4)(false, 'RelayConnectionTransform: Expected `%s` field on type `%s` to be a ' + 'list type in document `%s`.', EDGES, type, definitionName) : require('fbjs/lib/invariant')(false) : void 0;
	  var edgeType = __webpack_require__(1).SchemaUtils.getNullableType(edgesType.ofType);
	  !(edgeType instanceof __webpack_require__(3).GraphQLObjectType) ?  true ? __webpack_require__(4)(false, 'RelayConnectionTransform: Expected %s field on type `%s` to be a list ' + 'of objects in document `%s`.', EDGES, type, definitionName) : require('fbjs/lib/invariant')(false) : void 0;

	  var node = edgeType.getFields()[NODE];
	  !node ?  true ? __webpack_require__(4)(false, 'RelayConnectionTransform: Expected type `%s` to have an %s.%s field in ' + 'document `%s`.', type, EDGES, NODE, definitionName) : require('fbjs/lib/invariant')(false) : void 0;
	  var nodeType = __webpack_require__(1).SchemaUtils.getNullableType(node.type);
	  !(nodeType instanceof __webpack_require__(3).GraphQLInterfaceType || nodeType instanceof __webpack_require__(3).GraphQLUnionType || nodeType instanceof __webpack_require__(3).GraphQLObjectType) ?  true ? __webpack_require__(4)(false, 'RelayConnectionTransform: Expected type `%s` to have an %s.%s field' + 'for which the type is an interface, object, or union in document `%s`.', type, EDGES, NODE, definitionName) : require('fbjs/lib/invariant')(false) : void 0;

	  var cursor = edgeType.getFields()[CURSOR];
	  !(cursor && __webpack_require__(1).SchemaUtils.getNullableType(cursor.type) instanceof __webpack_require__(3).GraphQLScalarType) ?  true ? __webpack_require__(4)(false, 'RelayConnectionTransform: Expected type `%s` to have an ' + '%s.%s field for which the type is a scalar in document `%s`.', type, EDGES, CURSOR, definitionName) : require('fbjs/lib/invariant')(false) : void 0;

	  var pageInfo = typeFields[PAGE_INFO];
	  !pageInfo ?  true ? __webpack_require__(4)(false, 'RelayConnectionTransform: Expected type `%s` to have a %s field ' + 'in document `%s`.', type, PAGE_INFO, definitionName) : require('fbjs/lib/invariant')(false) : void 0;
	  var pageInfoType = __webpack_require__(1).SchemaUtils.getNullableType(pageInfo.type);
	  !(pageInfoType instanceof __webpack_require__(3).GraphQLObjectType) ?  true ? __webpack_require__(4)(false, 'RelayConnectionTransform: Expected type `%s` to have a %s field for ' + 'which the type is an object in document `%s`.', type, PAGE_INFO, definitionName) : require('fbjs/lib/invariant')(false) : void 0;

	  [END_CURSOR, HAS_NEXT_PAGE, HAS_PREV_PAGE, START_CURSOR].forEach(function (fieldName) {
	    var pageInfoField = pageInfoType.getFields()[fieldName];
	    !(pageInfoField && __webpack_require__(1).SchemaUtils.getNullableType(pageInfoField.type) instanceof __webpack_require__(3).GraphQLScalarType) ?  true ? __webpack_require__(4)(false, 'RelayConnectionTransform: Expected type `%s` to have an ' + '%s field for which the type is an scalar in document `%s`.', pageInfo.type, fieldName, definitionName) : require('fbjs/lib/invariant')(false) : void 0;
	  });
	}

	module.exports = {
	  CONNECTION: CONNECTION,
	  SCHEMA_EXTENSION: SCHEMA_EXTENSION,
	  transform: relayConnectionTransform
	};

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 *  strict-local
	 * @format
	 */

	'use strict';

	var _extends3 = _interopRequireDefault(__webpack_require__(9));

	var _toConsumableArray3 = _interopRequireDefault(__webpack_require__(10));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var isAbstractType = __webpack_require__(1).SchemaUtils.isAbstractType;

	var TYPENAME_KEY = '__typename';
	var STRING_TYPE = 'String';

	/**
	 * A transform that adds `__typename` field on any `LinkedField` of a union or
	 * interface type where there is no unaliased `__typename` selection.
	 */
	function relayGenerateTypeNameTransform(context) {
	  var stringType = __webpack_require__(3).assertLeafType(context.serverSchema.getType(STRING_TYPE));
	  var typenameField = {
	    kind: 'ScalarField',
	    alias: null,
	    args: [],
	    directives: [],
	    handles: null,
	    metadata: null,
	    name: TYPENAME_KEY,
	    type: stringType
	  };
	  var state = {
	    typenameField: typenameField
	  };
	  return __webpack_require__(1).IRTransformer.transform(context, {
	    LinkedField: visitLinkedField
	  }, function () {
	    return state;
	  });
	}

	function visitLinkedField(field, state) {
	  var transformedNode = this.traverse(field, state);
	  if (isAbstractType(transformedNode.type) && !__webpack_require__(40).hasUnaliasedSelection(transformedNode, TYPENAME_KEY)) {
	    return (0, _extends3['default'])({}, transformedNode, {
	      selections: [state.typenameField].concat((0, _toConsumableArray3['default'])(transformedNode.selections))
	    });
	  }
	  return transformedNode;
	}

	module.exports = {
	  transform: relayGenerateTypeNameTransform
	};

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * All rights reserved.
	 *
	 * 
	 * @format
	 */

	'use strict';

	var _extends3 = _interopRequireDefault(__webpack_require__(9));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	/**
	 * A transform that inlines fragment spreads with the @relay(mask: false)
	 * directive.
	 */
	function relayMaskTransform(context) {
	  return __webpack_require__(1).IRTransformer.transform(context, {
	    FragmentSpread: visitFragmentSpread,
	    Fragment: visitFragment
	  }, function () {
	    return {
	      hoistedArgDefs: new Map()
	    };
	  });
	}

	function visitFragment(fragment, state) {
	  var result = this.traverse(fragment, state);
	  if (state.hoistedArgDefs.size === 0) {
	    return result;
	  }
	  var existingArgDefs = new Map();
	  result.argumentDefinitions.forEach(function (argDef) {
	    existingArgDefs.set(argDef.name, argDef);
	  });
	  var combinedArgDefs = result.argumentDefinitions.slice(); // Copy array
	  state.hoistedArgDefs.forEach(function (hoistedArgDef, argName) {
	    var existingArgDef = existingArgDefs.get(argName);
	    if (existingArgDef) {
	      !areSameArgumentDefinitions(existingArgDef, hoistedArgDef.argDef) ?  true ? __webpack_require__(4)(false, 'RelayMaskTransform: Cannot unmask fragment spread `%s` because ' + 'argument `%s` has been declared in `%s` and they are not the same.', hoistedArgDef.source, argName, fragment.name) : require('fbjs/lib/invariant')(false) : void 0;
	      return;
	    }
	    combinedArgDefs.push(hoistedArgDef.argDef);
	  });
	  return (0, _extends3['default'])({}, result, {
	    argumentDefinitions: combinedArgDefs
	  });
	}

	function visitFragmentSpread(fragmentSpread, state) {
	  if (!isUnmaskedSpread(fragmentSpread)) {
	    return fragmentSpread;
	  }
	  !(fragmentSpread.args.length === 0) ?  true ? __webpack_require__(4)(false, 'RelayMaskTransform: Cannot unmask fragment spread `%s` with ' + 'arguments. Use the `ApplyFragmentArgumentTransform` before flattening', fragmentSpread.name) : require('fbjs/lib/invariant')(false) : void 0;
	  var fragment = this.getContext().getFragment(fragmentSpread.name);
	  var result = {
	    kind: 'InlineFragment',
	    directives: fragmentSpread.directives,
	    metadata: fragmentSpread.metadata,
	    selections: fragment.selections,
	    typeCondition: fragment.type
	  };

	  !!fragment.argumentDefinitions.find(function (argDef) {
	    return argDef.kind === 'LocalArgumentDefinition';
	  }) ?  true ? __webpack_require__(4)(false, 'RelayMaskTransform: Cannot unmask fragment spread `%s` because it has local ' + 'argument definition.', fragmentSpread.name) : require('fbjs/lib/invariant')(false) : void 0;

	  var _iteratorNormalCompletion = true;
	  var _didIteratorError = false;
	  var _iteratorError = undefined;

	  try {
	    for (var _iterator = fragment.argumentDefinitions[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	      var _argDef = _step.value;

	      var hoistedArgDef = state.hoistedArgDefs.get(_argDef.name);
	      if (hoistedArgDef) {
	        !areSameArgumentDefinitions(_argDef, hoistedArgDef.argDef) ?  true ? __webpack_require__(4)(false, 'RelayMaskTransform: Cannot unmask fragment spread `%s` because ' + 'argument `%s` has been declared in `%s` and they are not the same.', hoistedArgDef.source, _argDef.name, fragmentSpread.name) : require('fbjs/lib/invariant')(false) : void 0;
	        continue;
	      }
	      state.hoistedArgDefs.set(_argDef.name, {
	        argDef: _argDef,
	        source: fragmentSpread.name
	      });
	    }
	  } catch (err) {
	    _didIteratorError = true;
	    _iteratorError = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion && _iterator['return']) {
	        _iterator['return']();
	      }
	    } finally {
	      if (_didIteratorError) {
	        throw _iteratorError;
	      }
	    }
	  }

	  return this.traverse(result, state);
	}

	function isUnmaskedSpread(spread) {
	  return Boolean(spread.metadata && spread.metadata.mask === false);
	}

	function areSameArgumentDefinitions(argDef1, argDef2) {
	  return argDef1.kind === argDef2.kind && argDef1.name === argDef2.name && __webpack_require__(1).isEquivalentType(argDef1.type, argDef2.type) &&
	  // Only LocalArgumentDefinition defines defaultValue
	  argDef1.defaultValue === argDef2.defaultValue;
	}

	module.exports = {
	  transform: relayMaskTransform
	};

/***/ }),
/* 40 */
/***/ (function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 *  strict-local
	 * @format
	 */

	'use strict';

	function hasUnaliasedSelection(field, fieldName) {
	  return field.selections.some(function (selection) {
	    return selection.kind === 'ScalarField' && selection.alias == null && selection.name === fieldName;
	  });
	}

	module.exports = { hasUnaliasedSelection: hasUnaliasedSelection };

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 * @format
	 */

	'use strict';

	var _toConsumableArray3 = _interopRequireDefault(__webpack_require__(10));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var GLOBAL_RULES = __webpack_require__(1).Validator.GLOBAL_RULES,
	    LOCAL_RULES = __webpack_require__(1).Validator.LOCAL_RULES,
	    validate = __webpack_require__(1).Validator.validate;

	function DisallowIdAsAliasValidationRule(context) {
	  return {
	    Field: function Field(field) {
	      if (
	      /* $FlowFixMe(>=0.68.0 site=react_native_fb,react_native_oss) This
	       * comment suppresses an error found when Flow v0.68 was deployed. To
	       * see the error delete this comment and run Flow. */
	      field.alias && field.alias.value === 'id' &&
	      /* $FlowFixMe(>=0.68.0 site=react_native_fb,react_native_oss) This
	       * comment suppresses an error found when Flow v0.68 was deployed. To
	       * see the error delete this comment and run Flow. */
	      field.name.value !== 'id') {
	        throw new Error('RelayValidator: Relay does not allow aliasing fields to `id`. ' + 'This name is reserved for the globally unique `id` field on ' + '`Node`.');
	      }
	    }
	  };
	}

	var relayGlobalRules = GLOBAL_RULES;

	var relayLocalRules = [].concat((0, _toConsumableArray3['default'])(LOCAL_RULES), [DisallowIdAsAliasValidationRule]);

	module.exports = {
	  GLOBAL_RULES: relayGlobalRules,
	  LOCAL_RULES: relayLocalRules,
	  validate: validate
	};

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.ImportSpecifier = ImportSpecifier;
	exports.ImportDefaultSpecifier = ImportDefaultSpecifier;
	exports.ExportDefaultSpecifier = ExportDefaultSpecifier;
	exports.ExportSpecifier = ExportSpecifier;
	exports.ExportNamespaceSpecifier = ExportNamespaceSpecifier;
	exports.ExportAllDeclaration = ExportAllDeclaration;
	exports.ExportNamedDeclaration = ExportNamedDeclaration;
	exports.ExportDefaultDeclaration = ExportDefaultDeclaration;
	exports.ImportDeclaration = ImportDeclaration;
	exports.ImportNamespaceSpecifier = ImportNamespaceSpecifier;

	function t() {
	  const data = _interopRequireWildcard(__webpack_require__(2));

	  t = function () {
	    return data;
	  };

	  return data;
	}

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

	function ImportSpecifier(node) {
	  if (node.importKind === "type" || node.importKind === "typeof") {
	    this.word(node.importKind);
	    this.space();
	  }

	  this.print(node.imported, node);

	  if (node.local && node.local.name !== node.imported.name) {
	    this.space();
	    this.word("as");
	    this.space();
	    this.print(node.local, node);
	  }
	}

	function ImportDefaultSpecifier(node) {
	  this.print(node.local, node);
	}

	function ExportDefaultSpecifier(node) {
	  this.print(node.exported, node);
	}

	function ExportSpecifier(node) {
	  this.print(node.local, node);

	  if (node.exported && node.local.name !== node.exported.name) {
	    this.space();
	    this.word("as");
	    this.space();
	    this.print(node.exported, node);
	  }
	}

	function ExportNamespaceSpecifier(node) {
	  this.token("*");
	  this.space();
	  this.word("as");
	  this.space();
	  this.print(node.exported, node);
	}

	function ExportAllDeclaration(node) {
	  this.word("export");
	  this.space();

	  if (node.exportKind === "type") {
	    this.word("type");
	    this.space();
	  }

	  this.token("*");
	  this.space();
	  this.word("from");
	  this.space();
	  this.print(node.source, node);
	  this.semicolon();
	}

	function ExportNamedDeclaration(node) {
	  if (this.format.decoratorsBeforeExport && t().isClassDeclaration(node.declaration)) {
	    this.printJoin(node.declaration.decorators, node);
	  }

	  this.word("export");
	  this.space();
	  ExportDeclaration.apply(this, arguments);
	}

	function ExportDefaultDeclaration(node) {
	  if (this.format.decoratorsBeforeExport && t().isClassDeclaration(node.declaration)) {
	    this.printJoin(node.declaration.decorators, node);
	  }

	  this.word("export");
	  this.space();
	  this.word("default");
	  this.space();
	  ExportDeclaration.apply(this, arguments);
	}

	function ExportDeclaration(node) {
	  if (node.declaration) {
	    const declar = node.declaration;
	    this.print(declar, node);
	    if (!t().isStatement(declar)) this.semicolon();
	  } else {
	    if (node.exportKind === "type") {
	      this.word("type");
	      this.space();
	    }

	    const specifiers = node.specifiers.slice(0);
	    let hasSpecial = false;

	    while (true) {
	      const first = specifiers[0];

	      if (t().isExportDefaultSpecifier(first) || t().isExportNamespaceSpecifier(first)) {
	        hasSpecial = true;
	        this.print(specifiers.shift(), node);

	        if (specifiers.length) {
	          this.token(",");
	          this.space();
	        }
	      } else {
	        break;
	      }
	    }

	    if (specifiers.length || !specifiers.length && !hasSpecial) {
	      this.token("{");

	      if (specifiers.length) {
	        this.space();
	        this.printList(specifiers, node);
	        this.space();
	      }

	      this.token("}");
	    }

	    if (node.source) {
	      this.space();
	      this.word("from");
	      this.space();
	      this.print(node.source, node);
	    }

	    this.semicolon();
	  }
	}

	function ImportDeclaration(node) {
	  this.word("import");
	  this.space();

	  if (node.importKind === "type" || node.importKind === "typeof") {
	    this.word(node.importKind);
	    this.space();
	  }

	  const specifiers = node.specifiers.slice(0);

	  if (specifiers && specifiers.length) {
	    while (true) {
	      const first = specifiers[0];

	      if (t().isImportDefaultSpecifier(first) || t().isImportNamespaceSpecifier(first)) {
	        this.print(specifiers.shift(), node);

	        if (specifiers.length) {
	          this.token(",");
	          this.space();
	        }
	      } else {
	        break;
	      }
	    }

	    if (specifiers.length) {
	      this.token("{");
	      this.space();
	      this.printList(specifiers, node);
	      this.space();
	      this.token("}");
	    }

	    this.space();
	    this.word("from");
	    this.space();
	  }

	  this.print(node.source, node);
	  this.semicolon();
	}

	function ImportNamespaceSpecifier(node) {
	  this.token("*");
	  this.space();
	  this.word("as");
	  this.space();
	  this.print(node.local, node);
	}

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.needsWhitespace = needsWhitespace;
	exports.needsWhitespaceBefore = needsWhitespaceBefore;
	exports.needsWhitespaceAfter = needsWhitespaceAfter;
	exports.needsParens = needsParens;

	var whitespace = _interopRequireWildcard(__webpack_require__(97));

	var parens = _interopRequireWildcard(__webpack_require__(96));

	function t() {
	  const data = _interopRequireWildcard(__webpack_require__(2));

	  t = function () {
	    return data;
	  };

	  return data;
	}

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

	function expandAliases(obj) {
	  const newObj = {};

	  function add(type, func) {
	    const fn = newObj[type];
	    newObj[type] = fn ? function (node, parent, stack) {
	      const result = fn(node, parent, stack);
	      return result == null ? func(node, parent, stack) : result;
	    } : func;
	  }

	  for (const type of Object.keys(obj)) {
	    const aliases = t().FLIPPED_ALIAS_KEYS[type];

	    if (aliases) {
	      for (const alias of aliases) {
	        add(alias, obj[type]);
	      }
	    } else {
	      add(type, obj[type]);
	    }
	  }

	  return newObj;
	}

	const expandedParens = expandAliases(parens);
	const expandedWhitespaceNodes = expandAliases(whitespace.nodes);
	const expandedWhitespaceList = expandAliases(whitespace.list);

	function find(obj, node, parent, printStack) {
	  const fn = obj[node.type];
	  return fn ? fn(node, parent, printStack) : null;
	}

	function isOrHasCallExpression(node) {
	  if (t().isCallExpression(node)) {
	    return true;
	  }

	  if (t().isMemberExpression(node)) {
	    return isOrHasCallExpression(node.object) || !node.computed && isOrHasCallExpression(node.property);
	  } else {
	    return false;
	  }
	}

	function needsWhitespace(node, parent, type) {
	  if (!node) return 0;

	  if (t().isExpressionStatement(node)) {
	    node = node.expression;
	  }

	  let linesInfo = find(expandedWhitespaceNodes, node, parent);

	  if (!linesInfo) {
	    const items = find(expandedWhitespaceList, node, parent);

	    if (items) {
	      for (let i = 0; i < items.length; i++) {
	        linesInfo = needsWhitespace(items[i], node, type);
	        if (linesInfo) break;
	      }
	    }
	  }

	  if (typeof linesInfo === "object" && linesInfo !== null) {
	    return linesInfo[type] || 0;
	  }

	  return 0;
	}

	function needsWhitespaceBefore(node, parent) {
	  return needsWhitespace(node, parent, "before");
	}

	function needsWhitespaceAfter(node, parent) {
	  return needsWhitespace(node, parent, "after");
	}

	function needsParens(node, parent, printStack) {
	  if (!parent) return false;

	  if (t().isNewExpression(parent) && parent.callee === node) {
	    if (isOrHasCallExpression(node)) return true;
	  }

	  return find(expandedParens, node, parent, printStack);
	}

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = clone;

	var _cloneNode = _interopRequireDefault(__webpack_require__(19));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function clone(node) {
	  return (0, _cloneNode.default)(node, false);
	}

/***/ }),
/* 45 */
/***/ (function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = addComments;

	function addComments(node, type, comments) {
	  if (!comments || !node) return node;
	  const key = `${type}Comments`;

	  if (node[key]) {
	    if (type === "leading") {
	      node[key] = comments.concat(node[key]);
	    } else {
	      node[key] = node[key].concat(comments);
	    }
	  } else {
	    node[key] = comments;
	  }

	  return node;
	}

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = inheritInnerComments;

	var _inherit = _interopRequireDefault(__webpack_require__(29));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function inheritInnerComments(child, parent) {
	  (0, _inherit.default)("innerComments", child, parent);
	}

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = inheritLeadingComments;

	var _inherit = _interopRequireDefault(__webpack_require__(29));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function inheritLeadingComments(child, parent) {
	  (0, _inherit.default)("leadingComments", child, parent);
	}

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = inheritTrailingComments;

	var _inherit = _interopRequireDefault(__webpack_require__(29));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function inheritTrailingComments(child, parent) {
	  (0, _inherit.default)("trailingComments", child, parent);
	}

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = inheritsComments;

	var _inheritTrailingComments = _interopRequireDefault(__webpack_require__(48));

	var _inheritLeadingComments = _interopRequireDefault(__webpack_require__(47));

	var _inheritInnerComments = _interopRequireDefault(__webpack_require__(46));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function inheritsComments(child, parent) {
	  (0, _inheritTrailingComments.default)(child, parent);
	  (0, _inheritLeadingComments.default)(child, parent);
	  (0, _inheritInnerComments.default)(child, parent);
	  return child;
	}

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = toBlock;

	var _generated = __webpack_require__(8);

	var _generated2 = __webpack_require__(12);

	function toBlock(node, parent) {
	  if ((0, _generated.isBlockStatement)(node)) {
	    return node;
	  }

	  let blockNodes = [];

	  if ((0, _generated.isEmptyStatement)(node)) {
	    blockNodes = [];
	  } else {
	    if (!(0, _generated.isStatement)(node)) {
	      if ((0, _generated.isFunction)(parent)) {
	        node = (0, _generated2.returnStatement)(node);
	      } else {
	        node = (0, _generated2.expressionStatement)(node);
	      }
	    }

	    blockNodes = [node];
	  }

	  return (0, _generated2.blockStatement)(blockNodes);
	}

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = toIdentifier;

	var _isValidIdentifier = _interopRequireDefault(__webpack_require__(20));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function toIdentifier(name) {
	  name = name + "";
	  name = name.replace(/[^a-zA-Z0-9$_]/g, "-");
	  name = name.replace(/^[-0-9]+/, "");
	  name = name.replace(/[-\s]+(.)?/g, function (match, c) {
	    return c ? c.toUpperCase() : "";
	  });

	  if (!(0, _isValidIdentifier.default)(name)) {
	    name = `_${name}`;
	  }

	  return name || "_";
	}

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = removeTypeDuplicates;

	var _generated = __webpack_require__(8);

	function removeTypeDuplicates(nodes) {
	  const generics = {};
	  const bases = {};
	  const typeGroups = [];
	  const types = [];

	  for (let i = 0; i < nodes.length; i++) {
	    const node = nodes[i];
	    if (!node) continue;

	    if (types.indexOf(node) >= 0) {
	      continue;
	    }

	    if ((0, _generated.isAnyTypeAnnotation)(node)) {
	      return [node];
	    }

	    if ((0, _generated.isFlowBaseAnnotation)(node)) {
	      bases[node.type] = node;
	      continue;
	    }

	    if ((0, _generated.isUnionTypeAnnotation)(node)) {
	      if (typeGroups.indexOf(node.types) < 0) {
	        nodes = nodes.concat(node.types);
	        typeGroups.push(node.types);
	      }

	      continue;
	    }

	    if ((0, _generated.isGenericTypeAnnotation)(node)) {
	      const name = node.id.name;

	      if (generics[name]) {
	        let existing = generics[name];

	        if (existing.typeParameters) {
	          if (node.typeParameters) {
	            existing.typeParameters.params = removeTypeDuplicates(existing.typeParameters.params.concat(node.typeParameters.params));
	          }
	        } else {
	          existing = node.typeParameters;
	        }
	      } else {
	        generics[name] = node;
	      }

	      continue;
	    }

	    types.push(node);
	  }

	  for (const type in bases) {
	    types.push(bases[type]);
	  }

	  for (const name in generics) {
	    types.push(generics[name]);
	  }

	  return types;
	}

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = removeProperties;

	var _constants = __webpack_require__(16);

	const CLEAR_KEYS = ["tokens", "start", "end", "loc", "raw", "rawValue"];

	const CLEAR_KEYS_PLUS_COMMENTS = _constants.COMMENT_KEYS.concat(["comments"]).concat(CLEAR_KEYS);

	function removeProperties(node, opts = {}) {
	  const map = opts.preserveComments ? CLEAR_KEYS : CLEAR_KEYS_PLUS_COMMENTS;

	  for (const key of map) {
	    if (node[key] != null) node[key] = undefined;
	  }

	  for (const key in node) {
	    if (key[0] === "_" && node[key] != null) node[key] = undefined;
	  }

	  const symbols = Object.getOwnPropertySymbols(node);

	  for (const sym of symbols) {
	    node[sym] = null;
	  }
	}

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = removePropertiesDeep;

	var _traverseFast = _interopRequireDefault(__webpack_require__(55));

	var _removeProperties = _interopRequireDefault(__webpack_require__(53));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function removePropertiesDeep(tree, opts) {
	  (0, _traverseFast.default)(tree, _removeProperties.default, opts);
	  return tree;
	}

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = traverseFast;

	var _definitions = __webpack_require__(14);

	function traverseFast(node, enter, opts) {
	  if (!node) return;
	  const keys = _definitions.VISITOR_KEYS[node.type];
	  if (!keys) return;
	  opts = opts || {};
	  enter(node, opts);

	  for (const key of keys) {
	    const subNode = node[key];

	    if (Array.isArray(subNode)) {
	      for (const node of subNode) {
	        traverseFast(node, enter, opts);
	      }
	    } else {
	      traverseFast(subNode, enter, opts);
	    }
	  }
	}

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = buildMatchMemberExpression;

	var _matchesPattern = _interopRequireDefault(__webpack_require__(59));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function buildMatchMemberExpression(match, allowPartial) {
	  const parts = match.split(".");
	  return member => (0, _matchesPattern.default)(member, parts, allowPartial);
	}

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = isLet;

	var _generated = __webpack_require__(8);

	var _constants = __webpack_require__(16);

	function isLet(node) {
	  return (0, _generated.isVariableDeclaration)(node) && (node.kind !== "var" || node[_constants.BLOCK_SCOPED_SYMBOL]);
	}

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = isNode;

	var _definitions = __webpack_require__(14);

	function isNode(node) {
	  return !!(node && _definitions.VISITOR_KEYS[node.type]);
	}

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = matchesPattern;

	var _generated = __webpack_require__(8);

	function matchesPattern(member, match, allowPartial) {
	  if (!(0, _generated.isMemberExpression)(member)) return false;
	  const parts = Array.isArray(match) ? match : match.split(".");
	  const nodes = [];
	  let node;

	  for (node = member; (0, _generated.isMemberExpression)(node); node = node.object) {
	    nodes.push(node.property);
	  }

	  nodes.push(node);
	  if (nodes.length < parts.length) return false;
	  if (!allowPartial && nodes.length > parts.length) return false;

	  for (let i = 0, j = nodes.length - 1; i < parts.length; i++, j--) {
	    const node = nodes[j];
	    let value;

	    if ((0, _generated.isIdentifier)(node)) {
	      value = node.name;
	    } else if ((0, _generated.isStringLiteral)(node)) {
	      value = node.value;
	    } else {
	      return false;
	    }

	    if (parts[i] !== value) return false;
	  }

	  return true;
	}

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = validate;

	var _definitions = __webpack_require__(14);

	function validate(node, key, val) {
	  if (!node) return;
	  const fields = _definitions.NODE_FIELDS[node.type];
	  if (!fields) return;
	  const field = fields[key];
	  if (!field || !field.validate) return;
	  if (field.optional && val == null) return;
	  field.validate(node, key, val);
	}

/***/ }),
/* 61 */
/***/ (function(module, exports) {

	module.exports = require("os");

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 * @format
	 */

	'use strict';

	// Attempt to be as inclusive as possible of source text.
	var BABYLON_OPTIONS = {
	  allowImportExportEverywhere: true,
	  allowReturnOutsideFunction: true,
	  allowSuperOutsideMethod: true,
	  sourceType: 'module',
	  plugins: [
	  // Previously "*"
	  'asyncGenerators', 'classProperties', 'decorators', 'doExpressions', 'dynamicImport', 'exportExtensions', 'flow', 'functionBind', 'functionSent', 'jsx', 'nullishCoalescingOperator', 'objectRestSpread', 'optionalChaining', 'optionalCatchBinding'],
	  strictMode: false
	};

	function find(text) {
	  var result = [];
	  var ast = __webpack_require__(100).parse(text, BABYLON_OPTIONS);

	  var visitors = {
	    CallExpression: function CallExpression(node) {
	      var callee = node.callee;
	      if (!(callee.type === 'Identifier' && CREATE_CONTAINER_FUNCTIONS[callee.name] || callee.kind === 'MemberExpression' && callee.object.type === 'Identifier' && callee.object.value === 'Relay' && callee.property.type === 'Identifier' && CREATE_CONTAINER_FUNCTIONS[callee.property.name])) {
	        traverse(node, visitors);
	        return;
	      }
	      var fragments = node.arguments[1];
	      if (fragments.type === 'ObjectExpression') {
	        fragments.properties.forEach(function (property) {
	          !(property.type === 'ObjectProperty' && property.key.type === 'Identifier' && property.value.type === 'TaggedTemplateExpression') ?  true ? invariant(false, 'FindGraphQLTags: `%s` expects fragment definitions to be ' + '`key: graphql`.', node.callee.name) : invariant(false) : void 0;
	          !isGraphQLTag(property.value.tag) ?  true ? invariant(false, 'FindGraphQLTags: `%s` expects fragment definitions to be tagged ' + 'with `graphql`, got `%s`.', node.callee.name, getSourceTextForLocation(text, property.value.tag.loc)) : invariant(false) : void 0;
	          result.push({
	            keyName: property.key.name,
	            template: getGraphQLText(property.value.quasi),
	            sourceLocationOffset: getSourceLocationOffset(property.value.quasi)
	          });
	        });
	      } else {
	        !(fragments && fragments.type === 'TaggedTemplateExpression') ?  true ? invariant(false, 'FindGraphQLTags: `%s` expects a second argument of fragment ' + 'definitions.', node.callee.name) : invariant(false) : void 0;
	        !isGraphQLTag(fragments.tag) ?  true ? invariant(false, 'FindGraphQLTags: `%s` expects fragment definitions to be tagged ' + 'with `graphql`, got `%s`.', node.callee.name, getSourceTextForLocation(text, fragments.tag.loc)) : invariant(false) : void 0;
	        result.push({
	          keyName: null,
	          template: getGraphQLText(fragments.quasi),
	          sourceLocationOffset: getSourceLocationOffset(fragments.quasi)
	        });
	      }

	      // Visit remaining arguments
	      for (var ii = 2; ii < node.arguments.length; ii++) {
	        visit(node.arguments[ii], visitors);
	      }
	    },
	    TaggedTemplateExpression: function TaggedTemplateExpression(node) {
	      if (isGraphQLTag(node.tag)) {
	        result.push({
	          keyName: null,
	          template: node.quasi.quasis[0].value.raw,
	          sourceLocationOffset: getSourceLocationOffset(node.quasi)
	        });
	      }
	    }
	  };
	  visit(ast, visitors);
	  return result;
	}

	var CREATE_CONTAINER_FUNCTIONS = Object.create(null, {
	  createFragmentContainer: { value: true },
	  createPaginationContainer: { value: true },
	  createRefetchContainer: { value: true }
	});

	var IGNORED_KEYS = {
	  comments: true,
	  end: true,
	  leadingComments: true,
	  loc: true,
	  name: true,
	  start: true,
	  trailingComments: true,
	  type: true
	};

	function isGraphQLTag(tag) {
	  return tag.type === 'Identifier' && tag.name === 'graphql';
	}

	function getTemplateNode(quasi) {
	  var quasis = quasi.quasis;
	  !(quasis && quasis.length === 1) ?  true ? invariant(false, 'FindGraphQLTags: Substitutions are not allowed in graphql tags.') : invariant(false) : void 0;
	  return quasis[0];
	}

	function getGraphQLText(quasi) {
	  return getTemplateNode(quasi).value.raw;
	}

	function getSourceLocationOffset(quasi) {
	  var loc = getTemplateNode(quasi).loc.start;
	  return {
	    line: loc.line,
	    column: loc.column + 1 // babylon is 0-indexed, graphql expects 1-indexed
	  };
	}

	function getSourceTextForLocation(text, loc) {
	  if (loc == null) {
	    return '(source unavailable)';
	  }
	  var lines = text.split('\n').slice(loc.start.line - 1, loc.end.line);
	  lines[0] = lines[0].slice(loc.start.column);
	  lines[lines.length - 1] = lines[lines.length - 1].slice(0, loc.end.column);
	  return lines.join('\n');
	}

	function invariant(condition, msg) {
	  if (!condition) {
	    for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
	      args[_key - 2] = arguments[_key];
	    }

	    throw new Error(__webpack_require__(22).format.apply(__webpack_require__(22), [msg].concat(args)));
	  }
	}

	function visit(node, visitors) {
	  var fn = visitors[node.type];
	  if (fn != null) {
	    fn(node);
	    return;
	  }
	  traverse(node, visitors);
	}

	function traverse(node, visitors) {
	  for (var key in node) {
	    if (IGNORED_KEYS[key]) {
	      continue;
	    }
	    var prop = node[key];
	    if (prop && typeof prop === 'object' && typeof prop.type === 'string') {
	      visit(prop, visitors);
	    } else if (Array.isArray(prop)) {
	      prop.forEach(function (item) {
	        if (item && typeof item === 'object' && typeof item.type === 'string') {
	          visit(item, visitors);
	        }
	      });
	    }
	  }
	}

	module.exports = {
	  find: __webpack_require__(1).Profiler.instrument(find, 'FindGraphQLTags.find')
	};

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 * @format
	 */

	'use strict';

	var _extends3 = _interopRequireDefault(__webpack_require__(9));

	var _toConsumableArray3 = _interopRequireDefault(__webpack_require__(10));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	/**
	 * A tranform that converts a set of documents containing fragments/fragment
	 * spreads *with* arguments to one where all arguments have been inlined. This
	 * is effectively static currying of functions. Nodes are changed as follows:
	 * - Fragment spreads with arguments are replaced with references to an inlined
	 *   version of the referenced fragment.
	 * - Fragments with argument definitions are cloned once per unique set of
	 *   arguments, with the name changed to original name + hash and all nested
	 *   variable references changed to the value of that variable given its
	 *   arguments.
	 * - Field & directive argument variables are replaced with the value of those
	 *   variables in context.
	 * - All nodes are cloned with updated children.
	 *
	 * The transform also handles statically passing/failing Condition nodes:
	 * - Literal Conditions with a passing value are elided and their selections
	 *   inlined in their parent.
	 * - Literal Conditions with a failing value are removed.
	 * - Nodes that would become empty as a result of the above are removed.
	 *
	 * Note that unreferenced fragments are not added to the output.
	 */
	function relayApplyFragmentArgumentTransform(context) {
	  var fragments = new Map();
	  var nextContext = __webpack_require__(1).IRTransformer.transform(context, {
	    Root: function Root(node) {
	      var scope = __webpack_require__(36).getRootScope(node.argumentDefinitions);
	      return transformNode(context, fragments, scope, node);
	    },
	    // Fragments are included below where referenced.
	    // Unreferenced fragments are not included.
	    Fragment: function Fragment() {
	      return null;
	    }
	  });

	  return Array.from(fragments.values()).reduce(function (ctx, fragment) {
	    return fragment ? ctx.add(fragment) : ctx;
	  }, nextContext);
	}

	function transformNode(context, fragments, scope, node) {
	  var selections = transformSelections(context, fragments, scope, node.selections);
	  if (!selections) {
	    return null;
	  }
	  if (node.hasOwnProperty('directives')) {
	    var directives = transformDirectives(scope, node.directives);
	    // $FlowIssue: this is a valid `Node`:
	    return (0, _extends3['default'])({}, node, {
	      directives: directives,
	      selections: selections
	    });
	  }
	  return (0, _extends3['default'])({}, node, {
	    selections: selections
	  });
	}

	function transformFragmentSpread(context, fragments, scope, spread) {
	  var directives = transformDirectives(scope, spread.directives);
	  var fragment = context.getFragment(spread.name);
	  var appliedFragment = transformFragment(context, fragments, scope, fragment, spread.args);
	  if (!appliedFragment) {
	    return null;
	  }
	  return (0, _extends3['default'])({}, spread, {
	    args: [],
	    directives: directives,
	    name: appliedFragment.name
	  });
	}

	function transformDeferrableFragmentSpread(context, fragments, scope, spread) {
	  var directives = transformDirectives(scope, spread.directives);
	  var fragment = context.getFragment(spread.name);
	  var appliedFragment = transformFragment(context, fragments, scope, fragment, spread.fragmentArgs);
	  if (!appliedFragment) {
	    return null;
	  }
	  return (0, _extends3['default'])({}, spread, {
	    fragmentArgs: [],
	    directives: directives,
	    name: appliedFragment.name
	  });
	}

	function transformField(context, fragments, scope, field) {
	  var args = transformArguments(scope, field.args);
	  var directives = transformDirectives(scope, field.directives);
	  if (field.kind === 'LinkedField') {
	    var selections = transformSelections(context, fragments, scope, field.selections);
	    if (!selections) {
	      return null;
	    }
	    // $FlowFixMe(>=0.28.0)
	    return (0, _extends3['default'])({}, field, {
	      args: args,
	      directives: directives,
	      selections: selections
	    });
	  } else {
	    return (0, _extends3['default'])({}, field, {
	      args: args,
	      directives: directives
	    });
	  }
	}

	function transformCondition(context, fragments, scope, node) {
	  var condition = transformValue(scope, node.condition);
	  !(condition.kind === 'Literal' || condition.kind === 'Variable') ?  true ? __webpack_require__(4)(false, 'RelayApplyFragmentArgumentTransform: A non-scalar value was applied to ' + 'an @include or @skip directive, the `if` argument value must be a ' + 'variable or a Boolean, got `%s`.', condition) : require('fbjs/lib/invariant')(false) : void 0;
	  if (condition.kind === 'Literal' && condition.value !== node.passingValue) {
	    // Dead code, no need to traverse further.
	    return null;
	  }
	  var selections = transformSelections(context, fragments, scope, node.selections);
	  if (!selections) {
	    return null;
	  }
	  if (condition.kind === 'Literal' && condition.value === node.passingValue) {
	    // Always passes, return inlined selections
	    return selections;
	  }
	  return [(0, _extends3['default'])({}, node, {
	    condition: condition,
	    selections: selections
	  })];
	}

	function transformSelections(context, fragments, scope, selections) {
	  var nextSelections = null;
	  selections.forEach(function (selection) {
	    var nextSelection = void 0;
	    if (selection.kind === 'InlineFragment') {
	      nextSelection = transformNode(context, fragments, scope, selection);
	    } else if (selection.kind === 'FragmentSpread') {
	      nextSelection = transformFragmentSpread(context, fragments, scope, selection);
	    } else if (selection.kind === 'DeferrableFragmentSpread') {
	      nextSelection = transformDeferrableFragmentSpread(context, fragments, scope, selection);
	    } else if (selection.kind === 'Condition') {
	      var conditionSelections = transformCondition(context, fragments, scope, selection);
	      if (conditionSelections) {
	        var _nextSelections;

	        nextSelections = nextSelections || [];
	        (_nextSelections = nextSelections).push.apply(_nextSelections, (0, _toConsumableArray3['default'])(conditionSelections));
	      }
	    } else {
	      nextSelection = transformField(context, fragments, scope, selection);
	    }
	    if (nextSelection) {
	      nextSelections = nextSelections || [];
	      nextSelections.push(nextSelection);
	    }
	  });
	  return nextSelections;
	}

	function transformDirectives(scope, directives) {
	  return directives.map(function (directive) {
	    var args = transformArguments(scope, directive.args);
	    return (0, _extends3['default'])({}, directive, {
	      args: args
	    });
	  });
	}

	function transformArguments(scope, args) {
	  return args.map(function (arg) {
	    var value = transformValue(scope, arg.value);
	    return value === arg.value ? arg : (0, _extends3['default'])({}, arg, { value: value });
	  });
	}

	function transformValue(scope, value) {
	  if (value.kind === 'Variable') {
	    var scopeValue = scope[value.variableName];
	    !(scopeValue != null) ?  true ? __webpack_require__(4)(false, 'RelayApplyFragmentArgumentTransform: variable `%s` is not in scope.', value.variableName) : require('fbjs/lib/invariant')(false) : void 0;
	    return scopeValue;
	  } else if (value.kind === 'ListValue') {
	    return (0, _extends3['default'])({}, value, {
	      items: value.items.map(function (item) {
	        return transformValue(scope, item);
	      })
	    });
	  } else if (value.kind === 'ObjectValue') {
	    return (0, _extends3['default'])({}, value, {
	      fields: value.fields.map(function (field) {
	        return (0, _extends3['default'])({}, field, {
	          value: transformValue(scope, field.value)
	        });
	      })
	    });
	  }
	  return value;
	}

	/**
	 * Apply arguments to a fragment, creating a new fragment (with the given name)
	 * with all values recursively applied.
	 */
	function transformFragment(context, fragments, parentScope, fragment, args) {
	  var argumentsHash = hashArguments(args, parentScope);
	  var fragmentName = argumentsHash ? fragment.name + '_' + argumentsHash : fragment.name;
	  var appliedFragment = fragments.get(fragmentName);
	  if (appliedFragment) {
	    return appliedFragment;
	  }
	  var fragmentScope = __webpack_require__(36).getFragmentScope(fragment.argumentDefinitions, args, parentScope, fragment.name);
	  !(!fragments.has(fragmentName) || fragments.get(fragmentName) != null) ?  true ? __webpack_require__(4)(false, 'RelayApplyFragmentArgumentTransform: Found a circular reference from ' + 'fragment `%s`.', fragment.name) : require('fbjs/lib/invariant')(false) : void 0;
	  fragments.set(fragmentName, undefined); // to detect circular references
	  var transformedFragment = null;
	  var selections = transformSelections(context, fragments, fragmentScope, fragment.selections);
	  if (selections) {
	    transformedFragment = (0, _extends3['default'])({}, fragment, {
	      selections: selections,
	      name: fragmentName,
	      argumentDefinitions: []
	    });
	  }
	  fragments.set(fragmentName, transformedFragment);
	  return transformedFragment;
	}

	function hashArguments(args, scope) {
	  if (!args.length) {
	    return null;
	  }
	  var sortedArgs = [].concat((0, _toConsumableArray3['default'])(args)).sort(function (a, b) {
	    return a.name < b.name ? -1 : a.name > b.name ? 1 : 0;
	  });
	  var printedArgs = JSON.stringify(sortedArgs.map(function (arg) {
	    var value = void 0;
	    if (arg.value.kind === 'Variable') {
	      value = scope[arg.value.variableName];
	      !(value != null) ?  true ? __webpack_require__(4)(false, 'RelayApplyFragmentArgumentTransform: variable `%s` is not in scope.', arg.value.variableName) : require('fbjs/lib/invariant')(false) : void 0;
	    } else {
	      value = arg.value;
	    }
	    return {
	      name: arg.name,
	      value: __webpack_require__(1).getIdentifierForArgumentValue(value)
	    };
	  }));
	  return __webpack_require__(81)(printedArgs);
	}

	module.exports = {
	  transform: relayApplyFragmentArgumentTransform
	};

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 * @format
	 */

	'use strict';

	var getRawType = __webpack_require__(1).SchemaUtils.getRawType,
	    isAbstractType = __webpack_require__(1).SchemaUtils.isAbstractType,
	    getNullableType = __webpack_require__(1).SchemaUtils.getNullableType;

	/**
	 * @public
	 *
	 * Converts a GraphQLIR node into a plain JS object representation that can be
	 * used at runtime.
	 */
	function generate(node) {
	  !(['Batch', 'Fragment'].indexOf(node.kind) >= 0) ?  true ? __webpack_require__(4)(false, 'RelayCodeGenerator: Unknown AST kind `%s`. Source: %s.', node.kind, getErrorMessage(node)) : require('fbjs/lib/invariant')(false) : void 0;
	  return __webpack_require__(1).IRVisitor.visit(node, RelayCodeGenVisitor);
	}

	var RelayCodeGenVisitor = {
	  leave: {
	    Batch: function Batch(node) {
	      !(node.requests.length !== 0) ?  true ? __webpack_require__(4)(false, 'Batch must contain Requests.') : require('fbjs/lib/invariant')(false) : void 0;
	      if (isSingleRequest(node)) {
	        var request = node.requests[0];
	        return {
	          kind: 'Request',
	          operationKind: request.root.operation,
	          name: node.name,
	          id: request.id,
	          text: request.text,
	          metadata: node.metadata,
	          fragment: node.fragment,
	          operation: {
	            kind: 'Operation',
	            name: request.root.name,
	            argumentDefinitions: request.root.argumentDefinitions,
	            selections: flattenArray(request.root.selections)
	          }
	        };
	      } else {
	        return {
	          kind: 'BatchRequest',
	          operationKind: node.requests[0].root.operation,
	          name: node.name,
	          metadata: node.metadata,
	          fragment: node.fragment,
	          requests: node.requests.map(function (request) {
	            var isDeferrableFragment = request.metadata && request.metadata.deferrable;
	            var operation = isDeferrableFragment ? {
	              kind: 'DeferrableOperation',
	              name: request.root.name,
	              argumentDefinitions: request.root.argumentDefinitions,
	              selections: flattenArray(request.root.selections),
	              fragmentName: request.metadata.fragmentName,
	              rootFieldVariable: request.metadata.rootFieldVariable
	            } : {
	              kind: 'Operation',
	              name: request.root.name,
	              argumentDefinitions: request.root.argumentDefinitions,
	              selections: flattenArray(request.root.selections)
	            };

	            return {
	              name: request.name,
	              id: request.id,
	              text: request.text,
	              argumentDependencies: request.argumentDependencies.map(function (dependency) {
	                return {
	                  name: dependency.argumentName,
	                  fromRequestName: dependency.fromName,
	                  fromRequestPath: dependency.fromPath,
	                  ifList: dependency.ifList,
	                  ifNull: dependency.ifNull,
	                  maxRecurse: dependency.maxRecurse
	                };
	              }),
	              operation: operation
	            };
	          })
	        };
	      }
	    },
	    Fragment: function Fragment(node) {
	      return {
	        kind: 'Fragment',
	        name: node.name,
	        type: node.type.toString(),
	        metadata: node.metadata || null,
	        argumentDefinitions: node.argumentDefinitions,
	        selections: flattenArray(node.selections)
	      };
	    },
	    LocalArgumentDefinition: function LocalArgumentDefinition(node) {
	      return {
	        kind: 'LocalArgument',
	        name: node.name,
	        type: node.type.toString(),
	        defaultValue: node.defaultValue
	      };
	    },
	    RootArgumentDefinition: function RootArgumentDefinition(node) {
	      return {
	        kind: 'RootArgument',
	        name: node.name,
	        type: node.type ? node.type.toString() : null
	      };
	    },
	    Condition: function Condition(node, key, parent, ancestors) {
	      !(node.condition.kind === 'Variable') ?  true ? __webpack_require__(4)(false, 'RelayCodeGenerator: Expected static `Condition` node to be ' + 'pruned or inlined. Source: %s.', getErrorMessage(ancestors[0])) : require('fbjs/lib/invariant')(false) : void 0;
	      return {
	        kind: 'Condition',
	        passingValue: node.passingValue,
	        condition: node.condition.variableName,
	        selections: flattenArray(node.selections)
	      };
	    },
	    FragmentSpread: function FragmentSpread(node) {
	      return {
	        kind: 'FragmentSpread',
	        name: node.name,
	        args: valuesOrNull(sortByName(node.args))
	      };
	    },
	    DeferrableFragmentSpread: function DeferrableFragmentSpread(node) {
	      return {
	        kind: 'DeferrableFragmentSpread',
	        name: node.name,
	        args: valuesOrNull(sortByName(node.args)),
	        rootFieldVariable: node.rootFieldVariable,
	        storageKey: node.storageKey
	      };
	    },
	    InlineFragment: function InlineFragment(node) {
	      return {
	        kind: 'InlineFragment',
	        type: node.typeCondition.toString(),
	        selections: flattenArray(node.selections)
	      };
	    },
	    LinkedField: function LinkedField(node) {
	      // Note: it is important that the arguments of this field be sorted to
	      // ensure stable generation of storage keys for equivalent arguments
	      // which may have originally appeared in different orders across an app.
	      var handles = node.handles && node.handles.map(function (handle) {
	        return {
	          kind: 'LinkedHandle',
	          alias: node.alias,
	          name: node.name,
	          args: valuesOrNull(sortByName(node.args)),
	          handle: handle.name,
	          key: handle.key,
	          filters: handle.filters
	        };
	      }) || [];
	      var type = getRawType(node.type);
	      var field = {
	        kind: 'LinkedField',
	        alias: node.alias,
	        name: node.name,
	        storageKey: null,
	        args: valuesOrNull(sortByName(node.args)),
	        concreteType: !isAbstractType(type) ? type.toString() : null,
	        plural: isPlural(node.type),
	        selections: flattenArray(node.selections)
	      };
	      // Precompute storageKey if possible
	      field.storageKey = getStaticStorageKey(field);
	      return [field].concat(handles);
	    },
	    ScalarField: function ScalarField(node) {
	      // Note: it is important that the arguments of this field be sorted to
	      // ensure stable generation of storage keys for equivalent arguments
	      // which may have originally appeared in different orders across an app.
	      var handles = node.handles && node.handles.map(function (handle) {
	        return {
	          kind: 'ScalarHandle',
	          alias: node.alias,
	          name: node.name,
	          args: valuesOrNull(sortByName(node.args)),
	          handle: handle.name,
	          key: handle.key,
	          filters: handle.filters
	        };
	      }) || [];
	      var field = {
	        kind: 'ScalarField',
	        alias: node.alias,
	        name: node.name,
	        args: valuesOrNull(sortByName(node.args)),
	        selections: valuesOrUndefined(flattenArray(node.selections)),
	        storageKey: null
	      };
	      // Precompute storageKey if possible
	      field.storageKey = getStaticStorageKey(field);
	      return [field].concat(handles);
	    },
	    Variable: function Variable(node, key, parent) {
	      return {
	        kind: 'Variable',
	        name: parent.name,
	        variableName: node.variableName,
	        type: parent.type ? parent.type.toString() : null
	      };
	    },
	    Literal: function Literal(node, key, parent) {
	      return {
	        kind: 'Literal',
	        name: parent.name,
	        value: __webpack_require__(7).stableCopy(node.value),
	        type: parent.type ? parent.type.toString() : null
	      };
	    },
	    Argument: function Argument(node, key, parent, ancestors) {
	      if (['Variable', 'Literal'].indexOf(node.value.kind) < 0) {
	        var valueString = JSON.stringify(node.value, null, 2);
	        throw new Error('RelayCodeGenerator: Complex argument values (Lists or ' + 'InputObjects with nested variables) are not supported, argument ' + ('`' + node.name + '` had value `' + valueString + '`. ') + ('Source: ' + getErrorMessage(ancestors[0]) + '.'));
	      }
	      return node.value.value !== null ? node.value : null;
	    }
	  }
	};

	function isSingleRequest(batch) {
	  return batch.requests.length === 1 && batch.requests[0].argumentDependencies.length === 0;
	}

	function isPlural(type) {
	  return getNullableType(type) instanceof __webpack_require__(3).GraphQLList;
	}

	function valuesOrUndefined(array) {
	  return !array || array.length === 0 ? undefined : array;
	}

	function valuesOrNull(array) {
	  return !array || array.length === 0 ? null : array;
	}

	function flattenArray(array) {
	  return array ? Array.prototype.concat.apply([], array) : [];
	}

	function sortByName(array) {
	  return array instanceof Array ? array.sort(function (a, b) {
	    return a.name < b.name ? -1 : a.name > b.name ? 1 : 0;
	  }) : array;
	}

	function getErrorMessage(node) {
	  return 'document ' + node.name;
	}

	/**
	 * Pre-computes storage key if possible and advantageous. Storage keys are
	 * generated for fields with supplied arguments that are all statically known
	 * (ie. literals, no variables) at build time.
	 */
	function getStaticStorageKey(field) {
	  if (!field.args || field.args.length === 0 || field.args.some(function (arg) {
	    return arg.kind !== 'Literal';
	  })) {
	    return null;
	  }
	  return __webpack_require__(7).getStorageKey(field, {});
	}

	module.exports = { generate: generate };

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 *  strict-local
	 * @format
	 */

	'use strict';

	var _classCallCheck3 = _interopRequireDefault(__webpack_require__(34));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	/**
	 * A file backed cache. Values are JSON encoded on disk, so only JSON
	 * serializable values should be used.
	 */
	var RelayCompilerCache = function () {

	  /**
	   * @param name         Human readable identifier for the cache
	   * @param cacheBreaker This should be changed in order to invalidate existing
	   *                     caches.
	   */
	  function RelayCompilerCache(name, cacheBreaker) {
	    (0, _classCallCheck3['default'])(this, RelayCompilerCache);
	    this._dir = null;

	    this._name = name;
	    this._cacheBreaker = cacheBreaker;
	  }

	  RelayCompilerCache.prototype._getFile = function _getFile(key) {
	    if (this._dir == null) {
	      // Include username in the cache dir to avoid issues with directories being
	      // owned by a different user.
	      var username = __webpack_require__(61).userInfo().username;
	      var cacheID = __webpack_require__(35).createHash('md5').update(this._cacheBreaker).update(username).digest('hex');
	      var dir = __webpack_require__(6).join(__webpack_require__(61).tmpdir(), this._name + '-' + cacheID);
	      if (!__webpack_require__(11).existsSync(dir)) {
	        __webpack_require__(11).mkdirSync(dir);
	      }
	      this._dir = dir;
	    }
	    return __webpack_require__(6).join(this._dir, key);
	  };

	  RelayCompilerCache.prototype.getOrCompute = function getOrCompute(key, compute) {
	    var _this = this;

	    return __webpack_require__(1).Profiler.run('RelayCompilerCache.getOrCompute', function () {
	      var cacheFile = _this._getFile(key);
	      if (__webpack_require__(11).existsSync(cacheFile)) {
	        try {
	          return JSON.parse(__webpack_require__(11).readFileSync(cacheFile, 'utf8'));
	        } catch (e) {
	          // ignore
	        }
	      }
	      var value = compute();
	      try {
	        __webpack_require__(11).writeFileSync(cacheFile, JSON.stringify(value), 'utf8');
	      } catch (e) {
	        // ignore
	      }
	      return value;
	    });
	  };

	  return RelayCompilerCache;
	}();

	module.exports = RelayCompilerCache;

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 * @format
	 */

	'use strict';

	var _extends3 = _interopRequireDefault(__webpack_require__(9));

	var _toConsumableArray3 = _interopRequireDefault(__webpack_require__(10));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var DEFERRABLE_ARGUMENT_NAME = 'deferrableID';

	/**
	 * Deferrable fragment spreads are transformed into a series of individual
	 * dependent operation requests, expected to be executed as part of a batch
	 * operation.
	 *
	 * To achieve this transform, two steps are performed:
	 *
	 *   1) `transformOperations` is responsible for identifying which fragments
	 *      are deferrable and creating new root operations for them, as well as
	 *      creating the "dependent request" associations between them.
	 *
	 *   2) `transformSpreads` is responsible for replacing deferrable fragment
	 *      spreads with an `id` field. This step should only apply to the "query"
	 *      compiler phase, so that the request sent to the GraphQL server does not
	 *      contain the deferrable fragment and in its place has the information
	 *      necessary to later fulfill that fragment.
	 *
	 */
	function transform(context) {
	  // First, in an initial pass over all definitions, collect the path to each
	  // fragment spread from within a fragment or operation, as well as the set of
	  var spreadUsesWithin = new Map();
	  var deferrableFragments = new Set();
	  context.forEachDocument(function (document) {
	    var pathParts = [];
	    var spreadUses = [];
	    spreadUsesWithin.set(document, spreadUses);
	    __webpack_require__(1).IRVisitor.visit(document, {
	      LinkedField: {
	        enter: function enter(field) {
	          var pathPart = field.alias || field.name;
	          var fieldType = field.type;
	          while (fieldType.ofType) {
	            if (fieldType instanceof __webpack_require__(3).GraphQLList) {
	              pathPart += '[*]';
	            }
	            fieldType = fieldType.ofType;
	          }
	          pathParts.push(pathPart);
	        },
	        leave: function leave() {
	          pathParts.pop();
	        }
	      },
	      FragmentSpread: function FragmentSpread(spread) {
	        spreadUses.push({ spread: spread, path: pathParts.join('.') });
	        if (isDeferrable(spread)) {
	          deferrableFragments.add(context.getFragment(spread.name));
	        }
	      }
	    });
	  });

	  // If no fragments have been deferrable, then no transformation is necessary.
	  if (deferrableFragments.size === 0) {
	    return context;
	  }

	  // Next, transform any existing root operations to include references to
	  // their dependent requests.
	  var transformedContext = __webpack_require__(1).IRTransformer.transform(context, {
	    Root: function Root(root) {
	      var dependentRequests = createDependentRequests(context, spreadUsesWithin, root);
	      // If this operation contains deferrable spreads, then it will have
	      // additional dependent requests.
	      return dependentRequests.length === 0 ? root : (0, _extends3['default'])({}, root, {
	        dependentRequests: [].concat((0, _toConsumableArray3['default'])(root.dependentRequests), dependentRequests)
	      });
	    }
	  });

	  // Finally, add new operations representing each deferrable fragment.
	  var deferrableOperations = Array.from(deferrableFragments).map(function (fragment) {
	    // Create the deferrable operation.
	    var deferrableOperation = createDeferrableOperation(context, fragment);

	    // Include the deferrable operation along with the necessary
	    // additional variable definitions and dependent requests.
	    var argumentDefinitions = createArgumentDefinitions(context, spreadUsesWithin, fragment);
	    var dependentRequests = createDependentRequests(context, spreadUsesWithin, fragment);
	    var completeDeferrableOperation = (0, _extends3['default'])({}, deferrableOperation, {
	      argumentDefinitions: [].concat((0, _toConsumableArray3['default'])(deferrableOperation.argumentDefinitions), argumentDefinitions),
	      dependentRequests: [].concat((0, _toConsumableArray3['default'])(deferrableOperation.dependentRequests), dependentRequests)
	    });
	    return completeDeferrableOperation;
	  });

	  return transformSpreads(transformedContext, spreadUsesWithin).addAll(deferrableOperations);
	}

	/**
	 * The second step of the Deferrable transform, replacing deferrable spreads
	 * with deferrable refetch references which correspond to the dependent requests
	 */
	function transformSpreads(context, spreadUsesWithin) {
	  // Next, transform the definitions:
	  //  - Replacing deferrable spreads with refetch references.
	  //  - Adding dependent requests to operations.
	  return __webpack_require__(1).IRTransformer.transform(context, {
	    FragmentSpread: function FragmentSpread(spread) {
	      if (!isDeferrable(spread)) {
	        return spread;
	      }
	      // If this spread is deferrable, replace it with a refetch reference.
	      // The deferrable reference is definitionally not a FragmentSpread,
	      // though the transformer expects functions to return the same type.
	      return createDeferrableReference(context, spreadUsesWithin, spread);
	    }
	  });
	}

	// True if the FragmentSpread is marked as deferrable.
	function isDeferrable(spread) {
	  return Boolean(spread.metadata && spread.metadata.deferrable);
	}

	// Given a fragment, return the variable definitions necessary for all
	// variables used across deeply within.
	function createArgumentDefinitions(context, spreadUsesWithin, fragment) {
	  // Collect all recursively included definitions from the root.
	  var includedFragments = new Set([fragment]);
	  var nodesToVisit = [fragment];
	  while (nodesToVisit.length !== 0) {
	    var spreadUses = __webpack_require__(18)(spreadUsesWithin.get(nodesToVisit.pop()));
	    for (var i = 0; i < spreadUses.length; i++) {
	      var includedFragment = context.getFragment(spreadUses[i].spread.name);
	      if (!includedFragments.has(includedFragment)) {
	        includedFragments.add(includedFragment);
	        nodesToVisit.push(includedFragment);
	      }
	    }
	  }

	  // Then get all variables used in all included fragments to determine
	  // additional variable definitions, ensuring one definition per variable.
	  var variableDefinitions = new Map();
	  var _iteratorNormalCompletion = true;
	  var _didIteratorError = false;
	  var _iteratorError = undefined;

	  try {
	    for (var _iterator = includedFragments[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	      var _includedFragment = _step.value;
	      var _iteratorNormalCompletion2 = true;
	      var _didIteratorError2 = false;
	      var _iteratorError2 = undefined;

	      try {
	        for (var _iterator2 = _includedFragment.argumentDefinitions[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	          var argumentDefinition = _step2.value;

	          if (!variableDefinitions.has(argumentDefinition.name)) {
	            variableDefinitions.set(argumentDefinition.name, {
	              kind: 'LocalArgumentDefinition',
	              metadata: argumentDefinition.metadata,
	              name: argumentDefinition.name,
	              type: argumentDefinition.type,
	              defaultValue: argumentDefinition.kind === 'LocalArgumentDefinition' ? argumentDefinition.defaultValue : null
	            });
	          }
	        }
	      } catch (err) {
	        _didIteratorError2 = true;
	        _iteratorError2 = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion2 && _iterator2['return']) {
	            _iterator2['return']();
	          }
	        } finally {
	          if (_didIteratorError2) {
	            throw _iteratorError2;
	          }
	        }
	      }
	    }
	  } catch (err) {
	    _didIteratorError = true;
	    _iteratorError = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion && _iterator['return']) {
	        _iterator['return']();
	      }
	    } finally {
	      if (_didIteratorError) {
	        throw _iteratorError;
	      }
	    }
	  }

	  return Array.from(variableDefinitions.values());
	}

	// Given a fragment or node, return the set of dependent requests to fulfill.
	// Defines the relationship between deferrable reference selections (above) and
	// the deferrable operations dependent on them (below).
	function createDependentRequests(context, spreadUsesWithin, from) {
	  var spreadUses = getDeferrableSpreadUses(context, spreadUsesWithin, from);
	  return spreadUses.map(function (_ref) {
	    var spread = _ref.spread,
	        path = _ref.path;
	    return {
	      operationName: spread.name + '_Deferrable',
	      metadata: {
	        deferrable: true,
	        fragmentName: spread.name,
	        rootFieldVariable: DEFERRABLE_ARGUMENT_NAME
	      },
	      argumentDependencies: [{
	        kind: 'ArgumentDependency',
	        argumentName: DEFERRABLE_ARGUMENT_NAME,
	        fromName: from.name,
	        fromPath: path + '.' + deferrableAlias(spread.name),
	        ifList: 'each',
	        ifNull: 'skip'
	      }]
	    };
	  });
	}

	// A utility function which collects the paths to deferrable spreads from
	// a given starting Root or Fragment definition. Used above to determine the
	// dependent requests from an operation.
	var memoizedDeferrableSpreadUses = new WeakMap();
	function getDeferrableSpreadUses(context, spreadUsesWithin, node) {
	  var deferrableSpreadUses = memoizedDeferrableSpreadUses.get(node);
	  if (!deferrableSpreadUses) {
	    deferrableSpreadUses = [];
	    var _iteratorNormalCompletion3 = true;
	    var _didIteratorError3 = false;
	    var _iteratorError3 = undefined;

	    try {
	      for (var _iterator3 = __webpack_require__(18)(spreadUsesWithin.get(node))[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
	        var spreadUse = _step3.value;

	        if (isDeferrable(spreadUse.spread)) {
	          deferrableSpreadUses.push(spreadUse);
	        } else {
	          var nestedSpreadUses = getDeferrableSpreadUses(context, spreadUsesWithin, context.getFragment(spreadUse.spread.name));
	          var _iteratorNormalCompletion4 = true;
	          var _didIteratorError4 = false;
	          var _iteratorError4 = undefined;

	          try {
	            for (var _iterator4 = nestedSpreadUses[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
	              var nestedSpreadUse = _step4.value;

	              var separator = spreadUse.path === '' || nestedSpreadUse.path === '' ? '' : '.';
	              deferrableSpreadUses.push({
	                spread: nestedSpreadUse.spread,
	                path: spreadUse.path + separator + nestedSpreadUse.path
	              });
	            }
	          } catch (err) {
	            _didIteratorError4 = true;
	            _iteratorError4 = err;
	          } finally {
	            try {
	              if (!_iteratorNormalCompletion4 && _iterator4['return']) {
	                _iterator4['return']();
	              }
	            } finally {
	              if (_didIteratorError4) {
	                throw _iteratorError4;
	              }
	            }
	          }
	        }
	      }
	    } catch (err) {
	      _didIteratorError3 = true;
	      _iteratorError3 = err;
	    } finally {
	      try {
	        if (!_iteratorNormalCompletion3 && _iterator3['return']) {
	          _iterator3['return']();
	        }
	      } finally {
	        if (_didIteratorError3) {
	          throw _iteratorError3;
	        }
	      }
	    }

	    memoizedDeferrableSpreadUses.set(node, deferrableSpreadUses);
	  }
	  return deferrableSpreadUses;
	}

	// Utility function for creating a deferrable reference selection from a
	// deferrable fragment spread. This selection will be depended upon by another
	// operation in a batch request to fulfill the deferrable fragment.
	function createDeferrableReference(context, spreadUsesWithin, spread) {
	  var schema = context.clientSchema;
	  var nodeType = getNodeType(schema);
	  var idType = getIdType(schema);
	  var fragment = context.getFragment(spread.name);
	  var fragmentType = fragment.type;
	  !__webpack_require__(3).doTypesOverlap(schema, fragmentType, nodeType) ?  true ? __webpack_require__(4)(false, 'RelayDeferrableFragmentsTransform: Cannot defer %s since objects of ' + 'type %s can never also be of type Node.', spread.name, fragmentType) : require('fbjs/lib/invariant')(false) : void 0;
	  !(spread.args.length === 0) ?  true ? __webpack_require__(4)(false, 'RelayDeferrableFragmentsTransform: Cannot defer %s with arguments.', spread.name) : require('fbjs/lib/invariant')(false) : void 0;

	  var argumentDefinitions = createArgumentDefinitions(context, spreadUsesWithin, fragment);
	  // The deferrable fragment spread is replaced with two nested inline
	  // fragments. The outer of which ensures the type condition of the original
	  // fragment applies, while the inner specfically conditions on Node, so
	  // id may be safely queried. This is a conservative application known to
	  // always be safe, however the "FlattenTransform" may remove these if they
	  // are unnecessary.
	  //
	  // The metadata and directives of the deferrable fragment spread are
	  // transferred to the deferrable id field.
	  return {
	    kind: 'InlineFragment',
	    metadata: null,
	    typeCondition: fragmentType,
	    directives: [],
	    selections: [{
	      kind: 'InlineFragment',
	      metadata: null,
	      typeCondition: nodeType,
	      directives: [],
	      selections: [deferrableFragmentSpread(spread, idType, argumentDefinitions)]
	    }]
	  };
	}

	// Utility function for creating an operation from a deferrable fragment.
	function createDeferrableOperation(context, fragment) {
	  var schema = context.clientSchema;
	  var queryType = schema.getQueryType();
	  !queryType ?  true ? __webpack_require__(4)(false, 'RelayDeferrableFragmentTransform: "Query" must be a defined type') : require('fbjs/lib/invariant')(false) : void 0;
	  var nodeField = queryType.getFields().node;
	  !nodeField ?  true ? __webpack_require__(4)(false, 'RelayDeferrableFragmentTransform: "Query" must define the field "node"') : require('fbjs/lib/invariant')(false) : void 0;
	  var idArg = nodeField.args.find(function (arg) {
	    return arg.name === 'id';
	  });
	  !(idArg && __webpack_require__(3).isInputType(idArg.type)) ?  true ? __webpack_require__(4)(false, 'RelayDeferrableFragmentTransform: "node" field must define the argument "id"') : require('fbjs/lib/invariant')(false) : void 0;
	  var idType = idArg.type;
	  return {
	    kind: 'Root',
	    operation: 'query',
	    metadata: { deferred: true },
	    name: fragment.name + '_Deferrable',
	    dependentRequests: [],
	    argumentDefinitions: [{
	      kind: 'LocalArgumentDefinition',
	      metadata: null,
	      name: DEFERRABLE_ARGUMENT_NAME,
	      defaultValue: null,
	      type: idType
	    }],
	    directives: [],
	    selections: [{
	      kind: 'LinkedField',
	      name: 'node',
	      alias: null,
	      args: [{
	        kind: 'Argument',
	        name: 'id',
	        metadata: null,
	        value: {
	          kind: 'Variable',
	          variableName: DEFERRABLE_ARGUMENT_NAME,
	          metadata: null,
	          type: idType
	        },
	        type: idType
	      }],
	      directives: [],
	      metadata: null,
	      handles: null,
	      selections: [{
	        kind: 'FragmentSpread',
	        args: [],
	        name: fragment.name,
	        metadata: null,
	        directives: []
	      }],
	      type: nodeField.type
	    }],
	    type: queryType
	  };
	}

	function deferrableAlias(name) {
	  return name + '_' + DEFERRABLE_ARGUMENT_NAME;
	}

	function deferrableFragmentSpread(spread, idType, argumentDefinitions) {
	  return {
	    kind: 'DeferrableFragmentSpread',
	    name: spread.name,
	    directives: [],
	    fragmentArgs: spread.args,
	    args: argumentDefinitions.map(function (x) {
	      return {
	        kind: 'Argument',
	        metadata: null,
	        name: x.name,
	        type: x.type,
	        value: {
	          kind: 'Variable',
	          metadata: null,
	          type: x.type,
	          variableName: x.name
	        }
	      };
	    }).concat([{
	      kind: 'Argument',
	      metadata: null,
	      name: DEFERRABLE_ARGUMENT_NAME,
	      type: idType,
	      value: {
	        kind: 'Variable',
	        metadata: null,
	        type: idType,
	        variableName: DEFERRABLE_ARGUMENT_NAME
	      }
	    }]),
	    rootFieldVariable: DEFERRABLE_ARGUMENT_NAME,
	    storageKey: 'id',
	    alias: deferrableAlias(spread.name)
	  };
	}

	function getNodeType(schema) {
	  var nodeType = schema.getType('Node');
	  !(nodeType instanceof __webpack_require__(3).GraphQLInterfaceType) ?  true ? __webpack_require__(4)(false, 'RelayDeferrableFragmentTransform: Schema must define the interface "Node".') : require('fbjs/lib/invariant')(false) : void 0;
	  return nodeType;
	}

	function getIdType(schema) {
	  var nodeType = getNodeType(schema);
	  var idField = nodeType.getFields().id;
	  !idField ?  true ? __webpack_require__(4)(false, 'RelayDeferrableFragmentTransform: "Node" must define the field "id"') : require('fbjs/lib/invariant')(false) : void 0;
	  var idType = __webpack_require__(3).getNamedType(idField.type);
	  !__webpack_require__(3).isInputType(idType) ?  true ? __webpack_require__(4)(false, 'RelayDeferrableFragmentTransform: "Node" must define the scalar field "id"') : require('fbjs/lib/invariant')(false) : void 0;
	  return idType;
	}

	module.exports = { transform: transform };

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 * @format
	 */

	'use strict';

	var _extends3 = _interopRequireDefault(__webpack_require__(9));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function relayFieldHandleTransform(context) {
	  return __webpack_require__(1).IRTransformer.transform(context, {
	    LinkedField: visitField,
	    ScalarField: visitField
	  });
	}

	/**
	 * @internal
	 */
	function visitField(field) {
	  if (field.kind === 'LinkedField') {
	    field = this.traverse(field);
	  }
	  var handles = field.handles;
	  if (!handles || !handles.length) {
	    return field;
	  }
	  // ensure exactly one handle
	  !(handles.length === 1) ?  true ? __webpack_require__(4)(false, 'RelayFieldHandleTransform: Expected fields to have at most one ' + '"handle" property, got `%s`.', handles.join(', ')) : require('fbjs/lib/invariant')(false) : void 0;
	  var alias = field.alias || field.name;
	  var handle = handles[0];
	  var name = __webpack_require__(7).getRelayHandleKey(handle.name, handle.key, field.name);
	  var filters = handle.filters;
	  var args = filters ? field.args.filter(function (arg) {
	    return filters.indexOf(arg.name) > -1;
	  }) : [];

	  return (0, _extends3['default'])({}, field, {
	    args: args,
	    alias: alias,
	    name: name,
	    handles: null
	  });
	}

	module.exports = {
	  transform: relayFieldHandleTransform
	};

/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 * @format
	 */

	'use strict';

	var _asyncToGenerator2 = __webpack_require__(33);

	var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

	var _classCallCheck3 = _interopRequireDefault(__webpack_require__(34));

	var _toConsumableArray3 = _interopRequireDefault(__webpack_require__(10));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var isExecutableDefinitionAST = __webpack_require__(1).SchemaUtils.isExecutableDefinitionAST;

	var RelayFileWriter = function () {
	  function RelayFileWriter(_ref) {
	    var config = _ref.config,
	        onlyValidate = _ref.onlyValidate,
	        baseDocuments = _ref.baseDocuments,
	        documents = _ref.documents,
	        schema = _ref.schema,
	        reporter = _ref.reporter,
	        sourceControl = _ref.sourceControl;
	    (0, _classCallCheck3['default'])(this, RelayFileWriter);

	    this._baseDocuments = baseDocuments || __webpack_require__(149).Map();
	    this._baseSchema = schema;
	    this._config = config;
	    this._documents = documents;
	    this._onlyValidate = onlyValidate;
	    this._reporter = reporter;
	    this._sourceControl = sourceControl;

	    validateConfig(this._config);
	  }

	  RelayFileWriter.prototype.writeAll = function writeAll() {
	    var _this = this;

	    return __webpack_require__(1).Profiler.asyncContext('RelayFileWriter.writeAll', (0, _asyncToGenerator3.default)(function* () {
	      // Can't convert to IR unless the schema already has Relay-local extensions
	      var transformedSchema = __webpack_require__(1).ASTConvert.transformASTSchema(_this._baseSchema, _this._config.schemaExtensions);
	      var extendedSchema = __webpack_require__(1).ASTConvert.extendASTSchema(transformedSchema, _this._baseDocuments.merge(_this._documents).valueSeq().toArray());

	      // Build a context from all the documents
	      var baseDefinitionNames = new Set();
	      _this._baseDocuments.forEach(function (doc) {
	        doc.definitions.forEach(function (def) {
	          if (isExecutableDefinitionAST(def) && def.name) {
	            baseDefinitionNames.add(def.name.value);
	          }
	        });
	      });
	      var definitionsMeta = new Map();
	      var getDefinitionMeta = function getDefinitionMeta(definitionName) {
	        var definitionMeta = definitionsMeta.get(definitionName);
	        !definitionMeta ?  true ? __webpack_require__(4)(false, 'RelayFileWriter: Could not determine source for definition: `%s`.', definitionName) : require('fbjs/lib/invariant')(false) : void 0;
	        return definitionMeta;
	      };
	      var allOutputDirectories = new Map();
	      var addCodegenDir = function addCodegenDir(dirPath) {
	        var codegenDir = new (__webpack_require__(1).CodegenDirectory)(dirPath, {
	          onlyValidate: _this._onlyValidate
	        });
	        allOutputDirectories.set(dirPath, codegenDir);
	        return codegenDir;
	      };

	      var _iteratorNormalCompletion = true;
	      var _didIteratorError = false;
	      var _iteratorError = undefined;

	      try {
	        for (var _iterator = (_this._config.generatedDirectories || [])[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	          var existingDirectory = _step.value;

	          addCodegenDir(existingDirectory);
	        }
	      } catch (err) {
	        _didIteratorError = true;
	        _iteratorError = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion && _iterator['return']) {
	            _iterator['return']();
	          }
	        } finally {
	          if (_didIteratorError) {
	            throw _iteratorError;
	          }
	        }
	      }

	      var configOutputDirectory = void 0;
	      if (_this._config.outputDir) {
	        configOutputDirectory = addCodegenDir(_this._config.outputDir);
	      }

	      _this._documents.forEach(function (doc, filePath) {
	        doc.definitions.forEach(function (def) {
	          if (def.name) {
	            definitionsMeta.set(def.name.value, {
	              dir: __webpack_require__(6).join(_this._config.baseDir, __webpack_require__(6).dirname(filePath)),
	              ast: def
	            });
	          }
	        });
	      });

	      // Verify using local and global rules, can run global verifications here
	      // because all files are processed together
	      var validationRules = [].concat((0, _toConsumableArray3['default'])(__webpack_require__(41).LOCAL_RULES), (0, _toConsumableArray3['default'])(__webpack_require__(41).GLOBAL_RULES));
	      var customizedValidationRules = _this._config.validationRules;
	      if (customizedValidationRules) {
	        validationRules = [].concat((0, _toConsumableArray3['default'])(validationRules), (0, _toConsumableArray3['default'])(customizedValidationRules.LOCAL_RULES || []), (0, _toConsumableArray3['default'])(customizedValidationRules.GLOBAL_RULES || []));
	      }

	      var definitions = __webpack_require__(1).ASTConvert.convertASTDocumentsWithBase(extendedSchema, _this._baseDocuments.valueSeq().toArray(), _this._documents.valueSeq().toArray(), validationRules, __webpack_require__(24).transform.bind(__webpack_require__(24)));

	      var compilerContext = new (__webpack_require__(1).CompilerContext)(_this._baseSchema, extendedSchema).addAll(definitions);

	      var getGeneratedDirectory = function getGeneratedDirectory(definitionName) {
	        if (configOutputDirectory) {
	          return configOutputDirectory;
	        }
	        var generatedPath = __webpack_require__(6).join(getDefinitionMeta(definitionName).dir, '__generated__');
	        var cachedDir = allOutputDirectories.get(generatedPath);
	        if (!cachedDir) {
	          cachedDir = addCodegenDir(generatedPath);
	        }
	        return cachedDir;
	      };

	      var transformedFlowContext = compilerContext.applyTransforms(_this._config.typeGenerator.transforms, _this._reporter);
	      var transformedQueryContext = compilerContext.applyTransforms([].concat((0, _toConsumableArray3['default'])(_this._config.compilerTransforms.commonTransforms), (0, _toConsumableArray3['default'])(_this._config.compilerTransforms.queryTransforms)), _this._reporter);
	      var artifacts = __webpack_require__(76)(compilerContext, _this._config.compilerTransforms, _this._reporter);

	      var existingFragmentNames = new Set(definitions.map(function (definition) {
	        return definition.name;
	      }));

	      // TODO(T22651734): improve this to correctly account for fragments that
	      // have generated flow types.
	      baseDefinitionNames.forEach(function (baseDefinitionName) {
	        existingFragmentNames['delete'](baseDefinitionName);
	      });

	      var formatModule = __webpack_require__(1).Profiler.instrument(_this._config.formatModule, 'RelayFileWriter:formatModule');

	      var persistQuery = _this._config.persistQuery ? __webpack_require__(1).Profiler.instrumentWait(_this._config.persistQuery, 'RelayFileWriter:persistQuery') : null;

	      try {
	        yield Promise.all(artifacts.map((() => {
	          var _ref3 = (0, _asyncToGenerator3.default)(function* (node) {
	            if (baseDefinitionNames.has(node.name)) {
	              // don't add definitions that were part of base context
	              return;
	            }
	            if (node.metadata && node.metadata.deferred) {
	              // don't write deferred operations, the batch request is
	              // responsible for them
	              return;
	            }
	            var relayRuntimeModule = _this._config.relayRuntimeModule || 'relay-runtime';

	            var typeNode = transformedFlowContext.get(node.name);
	            !typeNode ?  true ? __webpack_require__(4)(false, 'RelayFileWriter: did not compile types for: %s', node.name) : require('fbjs/lib/invariant')(false) : void 0;

	            var typeText = _this._config.typeGenerator.generate(typeNode, {
	              customScalars: _this._config.customScalars,
	              enumsHasteModule: _this._config.enumsHasteModule,
	              existingFragmentNames: existingFragmentNames,
	              inputFieldWhiteList: _this._config.inputFieldWhiteListForFlow,
	              relayRuntimeModule: relayRuntimeModule,
	              useHaste: _this._config.useHaste,
	              useSingleArtifactDirectory: !!_this._config.outputDir,
	              noFutureProofEnums: _this._config.noFutureProofEnums
	            });

	            var sourceHash = __webpack_require__(1).Profiler.run('hashGraphQL', function () {
	              return md5(__webpack_require__(3).print(getDefinitionMeta(node.name).ast));
	            });

	            yield __webpack_require__(83)(getGeneratedDirectory(node.name), node, formatModule, typeText, persistQuery, _this._config.platform, relayRuntimeModule, sourceHash, _this._config.extension);
	          });

	          return function (_x) {
	            return _ref3.apply(this, arguments);
	          };
	        })()));

	        var _generateExtraFiles = _this._config.generateExtraFiles;
	        if (_generateExtraFiles) {
	          __webpack_require__(1).Profiler.run('RelayFileWriter:generateExtraFiles', function () {
	            var configDirectory = _this._config.outputDir;
	            _generateExtraFiles(function (dir) {
	              var outputDirectory = dir || configDirectory;
	              !outputDirectory ?  true ? __webpack_require__(4)(false, 'RelayFileWriter: cannot generate extra files without specifying ' + 'an outputDir in the config or passing it in.') : require('fbjs/lib/invariant')(false) : void 0;
	              var outputDir = allOutputDirectories.get(outputDirectory);
	              if (!outputDir) {
	                outputDir = addCodegenDir(outputDirectory);
	              }
	              return outputDir;
	            }, transformedQueryContext, getGeneratedDirectory);
	          });
	        }

	        // clean output directories
	        allOutputDirectories.forEach(function (dir) {
	          dir.deleteExtraFiles();
	        });
	        if (_this._sourceControl && !_this._onlyValidate) {
	          yield __webpack_require__(1).CodegenDirectory.sourceControlAddRemove(_this._sourceControl, Array.from(allOutputDirectories.values()));
	        }
	      } catch (error) {
	        var details = void 0;
	        try {
	          details = JSON.parse(error.message);
	        } catch (_) {} // eslint-disable-line lint/no-unused-catch-bindings
	        if (details && details.name === 'GraphQL2Exception' && details.message) {
	          throw new Error('GraphQL error writing modules:\n' + details.message);
	        }
	        throw new Error('Error writing modules:\n' + String(error.stack || error));
	      }

	      return allOutputDirectories;
	    }));
	  };

	  return RelayFileWriter;
	}();

	function md5(x) {
	  return __webpack_require__(35).createHash('md5').update(x, 'utf8').digest('hex');
	}

	function validateConfig(config) {
	  if (config.buildCommand) {
	    process.stderr.write('WARNING: RelayFileWriter: For RelayFileWriter to work you must ' + 'replace config.buildCommand with config.formatModule.\n');
	  }
	}

	module.exports = RelayFileWriter;

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 * @format
	 */

	'use strict';

	var cache = new (__webpack_require__(65))('RelayFindGraphQLTags', 'v1');

	function memoizedFind(tagFinder, text, baseDir, file, options) {
	  !file.exists ?  true ? invariant(false, 'RelayFindGraphQLTags: Called with non-existent file `%s`', file.relPath) : invariant(false) : void 0;
	  return cache.getOrCompute(file.hash + (options.validateNames ? '1' : '0'), find.bind(null, tagFinder, text, __webpack_require__(6).join(baseDir, file.relPath), options));
	}

	function find(tagFinder, text, absPath, _ref) {
	  var validateNames = _ref.validateNames;

	  var tags = tagFinder(text, absPath);
	  if (validateNames) {
	    var moduleName = __webpack_require__(80)(absPath);
	    tags.forEach(function (tag) {
	      return validateTemplate(tag, moduleName, absPath);
	    });
	  }
	  return tags.map(function (tag) {
	    return tag.template;
	  });
	}

	function validateTemplate(_ref2, moduleName, filePath) {
	  var template = _ref2.template,
	      keyName = _ref2.keyName,
	      sourceLocationOffset = _ref2.sourceLocationOffset;

	  var ast = __webpack_require__(3).parse(new (__webpack_require__(3).Source)(template, filePath, sourceLocationOffset));
	  ast.definitions.forEach(function (def) {
	    !def.name ?  true ? invariant(false, 'RelayFindGraphQLTags: In module `%s`, a definition of kind `%s` requires a name.', moduleName, def.kind) : invariant(false) : void 0;
	    var definitionName = def.name.value;
	    if (def.kind === 'OperationDefinition') {
	      var operationNameParts = definitionName.match(/^(.*)(Mutation|Query|Subscription)$/);
	      !(operationNameParts && definitionName.startsWith(moduleName)) ?  true ? invariant(false, 'RelayFindGraphQLTags: Operation names in graphql tags must be prefixed ' + 'with the module name and end in "Mutation", "Query", or ' + '"Subscription". Got `%s` in module `%s`.', definitionName, moduleName) : invariant(false) : void 0;
	    } else if (def.kind === 'FragmentDefinition') {
	      if (keyName) {
	        !(definitionName === moduleName + '_' + keyName) ?  true ? invariant(false, 'RelayFindGraphQLTags: Container fragment names must be ' + '`<ModuleName>_<propName>`. Got `%s`, expected `%s`.', definitionName, moduleName + '_' + keyName) : invariant(false) : void 0;
	      } else {
	        !definitionName.startsWith(moduleName) ?  true ? invariant(false, 'RelayFindGraphQLTags: Fragment names in graphql tags must be prefixed ' + 'with the module name. Got `%s` in module `%s`.', definitionName, moduleName) : invariant(false) : void 0;
	      }
	    }
	  });
	}

	// TODO: Not sure why this is defined here rather than imported, is it so that it doesn’t get stripped in prod?
	function invariant(condition, msg) {
	  if (!condition) {
	    for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
	      args[_key - 2] = arguments[_key];
	    }

	    throw new Error(__webpack_require__(22).format.apply(__webpack_require__(22), [msg].concat(args)));
	  }
	}

	module.exports = {
	  find: find, // Exported for testing only.
	  memoizedFind: memoizedFind
	};

/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 * @format
	 */

	'use strict';

	var _extends3 = _interopRequireDefault(__webpack_require__(9));

	var _toConsumableArray3 = _interopRequireDefault(__webpack_require__(10));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var isAbstractType = __webpack_require__(1).SchemaUtils.isAbstractType;

	function generate(node, options) {
	  var ast = __webpack_require__(1).IRVisitor.visit(node, createVisitor(options));
	  return __webpack_require__(95)['default'](ast).code;
	}

	function makeProp(_ref, state, unmasked, concreteType) {
	  var key = _ref.key,
	      schemaName = _ref.schemaName,
	      value = _ref.value,
	      conditional = _ref.conditional,
	      nodeType = _ref.nodeType,
	      nodeSelections = _ref.nodeSelections;

	  if (nodeType) {
	    value = __webpack_require__(23).transformScalarType(nodeType, state, selectionsToBabel([Array.from(__webpack_require__(18)(nodeSelections).values())], state, unmasked));
	  }
	  if (schemaName === '__typename' && concreteType) {
	    value = __webpack_require__(2).stringLiteralTypeAnnotation(concreteType);
	  }
	  var typeProperty = __webpack_require__(5).readOnlyObjectTypeProperty(key, value);
	  if (conditional) {
	    typeProperty.optional = true;
	  }
	  return typeProperty;
	}

	var isTypenameSelection = function isTypenameSelection(selection) {
	  return selection.schemaName === '__typename';
	};
	var hasTypenameSelection = function hasTypenameSelection(selections) {
	  return selections.some(isTypenameSelection);
	};
	var onlySelectsTypename = function onlySelectsTypename(selections) {
	  return selections.every(isTypenameSelection);
	};

	function selectionsToBabel(selections, state, unmasked, refTypeName) {
	  var baseFields = new Map();
	  var byConcreteType = {};

	  flattenArray(selections).forEach(function (selection) {
	    var concreteType = selection.concreteType;

	    if (concreteType) {
	      byConcreteType[concreteType] = byConcreteType[concreteType] || [];
	      byConcreteType[concreteType].push(selection);
	    } else {
	      var previousSel = baseFields.get(selection.key);

	      baseFields.set(selection.key, previousSel ? mergeSelection(selection, previousSel) : selection);
	    }
	  });

	  var types = [];

	  if (Object.keys(byConcreteType).length && onlySelectsTypename(Array.from(baseFields.values())) && (hasTypenameSelection(Array.from(baseFields.values())) || Object.keys(byConcreteType).every(function (type) {
	    return hasTypenameSelection(byConcreteType[type]);
	  }))) {
	    (function () {
	      var typenameAliases = new Set();

	      var _loop = function _loop(_concreteType) {
	        types.push(groupRefs([].concat((0, _toConsumableArray3['default'])(Array.from(baseFields.values())), (0, _toConsumableArray3['default'])(byConcreteType[_concreteType]))).map(function (selection) {
	          if (selection.schemaName === '__typename') {
	            typenameAliases.add(selection.key);
	          }
	          return makeProp(selection, state, unmasked, _concreteType);
	        }));
	      };

	      for (var _concreteType in byConcreteType) {
	        _loop(_concreteType);
	      }
	      // It might be some other type then the listed concrete types. Ideally, we
	      // would set the type to diff(string, set of listed concrete types), but
	      // this doesn't exist in Flow at the time.
	      types.push(Array.from(typenameAliases).map(function (typenameAlias) {
	        var otherProp = __webpack_require__(5).readOnlyObjectTypeProperty(typenameAlias, __webpack_require__(2).stringLiteralTypeAnnotation('%other'));
	        otherProp.leadingComments = __webpack_require__(5).lineComments("This will never be '%other', but we need some", 'value in case none of the concrete values match.');
	        return otherProp;
	      }));
	    })();
	  } else {
	    var selectionMap = selectionsToMap(Array.from(baseFields.values()));
	    for (var _concreteType2 in byConcreteType) {
	      selectionMap = mergeSelections(selectionMap, selectionsToMap(byConcreteType[_concreteType2].map(function (sel) {
	        return (0, _extends3['default'])({}, sel, {
	          conditional: true
	        });
	      })));
	    }
	    var selectionMapValues = groupRefs(Array.from(selectionMap.values())).map(function (sel) {
	      return isTypenameSelection(sel) && sel.concreteType ? makeProp((0, _extends3['default'])({}, sel, { conditional: false }), state, unmasked, sel.concreteType) : makeProp(sel, state, unmasked);
	    });
	    types.push(selectionMapValues);
	  }

	  return __webpack_require__(5).unionTypeAnnotation(types.map(function (props) {
	    if (refTypeName) {
	      props.push(__webpack_require__(5).readOnlyObjectTypeProperty('$refType', __webpack_require__(2).genericTypeAnnotation(__webpack_require__(2).identifier(refTypeName))));
	    }
	    return unmasked ? __webpack_require__(2).objectTypeAnnotation(props) : __webpack_require__(5).exactObjectTypeAnnotation(props);
	  }));
	}

	function mergeSelection(a, b) {
	  if (!a) {
	    return (0, _extends3['default'])({}, b, {
	      conditional: true
	    });
	  }
	  return (0, _extends3['default'])({}, a, {
	    nodeSelections: a.nodeSelections ? mergeSelections(a.nodeSelections, __webpack_require__(18)(b.nodeSelections)) : null,
	    conditional: a.conditional && b.conditional
	  });
	}

	function mergeSelections(a, b) {
	  var merged = new Map();
	  var _iteratorNormalCompletion = true;
	  var _didIteratorError = false;
	  var _iteratorError = undefined;

	  try {
	    for (var _iterator = a.entries()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	      var _step$value = _step.value,
	          _key = _step$value[0],
	          _value = _step$value[1];

	      merged.set(_key, _value);
	    }
	  } catch (err) {
	    _didIteratorError = true;
	    _iteratorError = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion && _iterator['return']) {
	        _iterator['return']();
	      }
	    } finally {
	      if (_didIteratorError) {
	        throw _iteratorError;
	      }
	    }
	  }

	  var _iteratorNormalCompletion2 = true;
	  var _didIteratorError2 = false;
	  var _iteratorError2 = undefined;

	  try {
	    for (var _iterator2 = b.entries()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	      var _step2$value = _step2.value,
	          _key2 = _step2$value[0],
	          _value2 = _step2$value[1];

	      merged.set(_key2, mergeSelection(a.get(_key2), _value2));
	    }
	  } catch (err) {
	    _didIteratorError2 = true;
	    _iteratorError2 = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion2 && _iterator2['return']) {
	        _iterator2['return']();
	      }
	    } finally {
	      if (_didIteratorError2) {
	        throw _iteratorError2;
	      }
	    }
	  }

	  return merged;
	}

	function isPlural(node) {
	  return Boolean(node.metadata && node.metadata.plural);
	}

	function createVisitor(options) {
	  var state = {
	    customScalars: options.customScalars,
	    enumsHasteModule: options.enumsHasteModule,
	    existingFragmentNames: options.existingFragmentNames,
	    generatedFragments: new Set(),
	    generatedInputObjectTypes: {},
	    inputFieldWhiteList: options.inputFieldWhiteList,
	    relayRuntimeModule: options.relayRuntimeModule,
	    usedEnums: {},
	    usedFragments: new Set(),
	    useHaste: options.useHaste,
	    useSingleArtifactDirectory: options.useSingleArtifactDirectory,
	    noFutureProofEnums: options.noFutureProofEnums
	  };

	  return {
	    leave: {
	      Root: function Root(node) {
	        var inputVariablesType = generateInputVariablesType(node, state);
	        var inputObjectTypes = generateInputObjectTypes(state);
	        var responseType = __webpack_require__(5).exportType(node.name + 'Response', selectionsToBabel(node.selections, state, false));
	        var operationType = __webpack_require__(5).exportType(node.name, __webpack_require__(5).exactObjectTypeAnnotation([__webpack_require__(2).objectTypeProperty(__webpack_require__(2).identifier('variables'), __webpack_require__(2).genericTypeAnnotation(__webpack_require__(2).identifier(node.name + 'Variables'))), __webpack_require__(2).objectTypeProperty(__webpack_require__(2).identifier('response'), __webpack_require__(2).genericTypeAnnotation(__webpack_require__(2).identifier(node.name + 'Response')))]));
	        return __webpack_require__(2).program([].concat((0, _toConsumableArray3['default'])(getFragmentImports(state)), (0, _toConsumableArray3['default'])(getEnumDefinitions(state)), (0, _toConsumableArray3['default'])(inputObjectTypes), [inputVariablesType, responseType, operationType]));
	      },
	      Fragment: function Fragment(node) {
	        var selections = flattenArray(node.selections);
	        var numConecreteSelections = selections.filter(function (s) {
	          return s.concreteType;
	        }).length;
	        selections = selections.map(function (selection) {
	          if (numConecreteSelections <= 1 && isTypenameSelection(selection) && !isAbstractType(node.type)) {
	            return [(0, _extends3['default'])({}, selection, {
	              concreteType: node.type.toString()
	            })];
	          }
	          return [selection];
	        });
	        state.generatedFragments.add(node.name);
	        var refTypeName = getRefTypeName(node.name);
	        var refType = __webpack_require__(2).declareExportDeclaration(__webpack_require__(2).declareOpaqueType(__webpack_require__(2).identifier(refTypeName), null, __webpack_require__(2).genericTypeAnnotation(__webpack_require__(2).identifier('FragmentReference'))));
	        var unmasked = node.metadata && node.metadata.mask === false;
	        var baseType = selectionsToBabel(selections, state, unmasked, unmasked ? undefined : refTypeName);
	        var type = isPlural(node) ? __webpack_require__(5).readOnlyArrayOfType(baseType) : baseType;
	        return __webpack_require__(2).program([].concat((0, _toConsumableArray3['default'])(getFragmentImports(state)), (0, _toConsumableArray3['default'])(getEnumDefinitions(state)), [__webpack_require__(5).importTypes(['FragmentReference'], state.relayRuntimeModule), refType, __webpack_require__(5).exportType(node.name, type)]));
	      },
	      InlineFragment: function InlineFragment(node) {
	        var typeCondition = node.typeCondition;
	        return flattenArray(node.selections).map(function (typeSelection) {
	          return isAbstractType(typeCondition) ? (0, _extends3['default'])({}, typeSelection, {
	            conditional: true
	          }) : (0, _extends3['default'])({}, typeSelection, {
	            concreteType: typeCondition.toString()
	          });
	        });
	      },
	      Condition: function Condition(node) {
	        return flattenArray(node.selections).map(function (selection) {
	          return (0, _extends3['default'])({}, selection, {
	            conditional: true
	          });
	        });
	      },
	      ScalarField: function ScalarField(node) {
	        return [{
	          key: node.alias || node.name,
	          schemaName: node.name,
	          value: __webpack_require__(23).transformScalarType(node.type, state)
	        }];
	      },
	      LinkedField: function LinkedField(node) {
	        return [{
	          key: node.alias || node.name,
	          schemaName: node.name,
	          nodeType: node.type,
	          nodeSelections: selectionsToMap(flattenArray(node.selections))
	        }];
	      },
	      FragmentSpread: function FragmentSpread(node) {
	        state.usedFragments.add(node.name);
	        return [{
	          key: '__fragments_' + node.name,
	          ref: node.name
	        }];
	      }
	    }
	  };
	}

	function selectionsToMap(selections) {
	  var map = new Map();
	  selections.forEach(function (selection) {
	    var previousSel = map.get(selection.key);
	    map.set(selection.key, previousSel ? mergeSelection(previousSel, selection) : selection);
	  });
	  return map;
	}

	function flattenArray(arrayOfArrays) {
	  var result = [];
	  arrayOfArrays.forEach(function (array) {
	    return result.push.apply(result, (0, _toConsumableArray3['default'])(array));
	  });
	  return result;
	}

	function generateInputObjectTypes(state) {
	  return Object.keys(state.generatedInputObjectTypes).map(function (typeIdentifier) {
	    var inputObjectType = state.generatedInputObjectTypes[typeIdentifier];
	    !(typeof inputObjectType !== 'string') ?  true ? __webpack_require__(4)(false, 'RelayCompilerFlowGenerator: Expected input object type to have been' + ' defined before calling `generateInputObjectTypes`') : require('fbjs/lib/invariant')(false) : void 0;
	    return __webpack_require__(5).exportType(typeIdentifier, inputObjectType);
	  });
	}

	function generateInputVariablesType(node, state) {
	  return __webpack_require__(5).exportType(node.name + 'Variables', __webpack_require__(5).exactObjectTypeAnnotation(node.argumentDefinitions.map(function (arg) {
	    var property = __webpack_require__(2).objectTypeProperty(__webpack_require__(2).identifier(arg.name), __webpack_require__(23).transformInputType(arg.type, state));
	    if (!(arg.type instanceof __webpack_require__(3).GraphQLNonNull)) {
	      property.optional = true;
	    }
	    return property;
	  })));
	}

	function groupRefs(props) {
	  var result = [];
	  var refs = [];
	  props.forEach(function (prop) {
	    if (prop.ref) {
	      refs.push(prop.ref);
	    } else {
	      result.push(prop);
	    }
	  });
	  if (refs.length > 0) {
	    var _value3 = __webpack_require__(5).intersectionTypeAnnotation(refs.map(function (ref) {
	      return __webpack_require__(2).genericTypeAnnotation(__webpack_require__(2).identifier(getRefTypeName(ref)));
	    }));
	    result.push({
	      key: '$fragmentRefs',
	      conditional: false,
	      value: _value3
	    });
	  }
	  return result;
	}

	function getFragmentImports(state) {
	  var imports = [];
	  if (state.usedFragments.size > 0) {
	    var _usedFragments = Array.from(state.usedFragments).sort();
	    var _iteratorNormalCompletion3 = true;
	    var _didIteratorError3 = false;
	    var _iteratorError3 = undefined;

	    try {
	      for (var _iterator3 = _usedFragments[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
	        var usedFragment = _step3.value;

	        var refTypeName = getRefTypeName(usedFragment);
	        if (!state.generatedFragments.has(usedFragment)) {
	          if (state.useHaste && state.existingFragmentNames.has(usedFragment)) {
	            // TODO(T22653277) support non-haste environments when importing
	            // fragments
	            imports.push(__webpack_require__(5).importTypes([refTypeName], usedFragment + '.graphql'));
	          } else if (state.useSingleArtifactDirectory && state.existingFragmentNames.has(usedFragment)) {
	            imports.push(__webpack_require__(5).importTypes([refTypeName], './' + usedFragment + '.graphql'));
	          } else {
	            imports.push(__webpack_require__(5).anyTypeAlias(refTypeName));
	          }
	        }
	      }
	    } catch (err) {
	      _didIteratorError3 = true;
	      _iteratorError3 = err;
	    } finally {
	      try {
	        if (!_iteratorNormalCompletion3 && _iterator3['return']) {
	          _iterator3['return']();
	        }
	      } finally {
	        if (_didIteratorError3) {
	          throw _iteratorError3;
	        }
	      }
	    }
	  }
	  return imports;
	}

	function getEnumDefinitions(_ref2) {
	  var enumsHasteModule = _ref2.enumsHasteModule,
	      usedEnums = _ref2.usedEnums,
	      noFutureProofEnums = _ref2.noFutureProofEnums;

	  var enumNames = Object.keys(usedEnums).sort();
	  if (enumNames.length === 0) {
	    return [];
	  }
	  if (enumsHasteModule) {
	    return [__webpack_require__(5).importTypes(enumNames, enumsHasteModule)];
	  }
	  return enumNames.map(function (name) {
	    var values = usedEnums[name].getValues().map(function (_ref3) {
	      var value = _ref3.value;
	      return value;
	    });
	    values.sort();
	    if (!noFutureProofEnums) {
	      values.push('%future added value');
	    }
	    return __webpack_require__(5).exportType(name, __webpack_require__(2).unionTypeAnnotation(values.map(function (value) {
	      return __webpack_require__(2).stringLiteralTypeAnnotation(value);
	    })));
	  });
	}

	function getRefTypeName(name) {
	  return name + '$ref';
	}

	var FLOW_TRANSFORMS = [__webpack_require__(25).transform, __webpack_require__(39).transform, __webpack_require__(1).FlattenTransform.transformWithOptions({})];

	module.exports = {
	  generate: __webpack_require__(1).Profiler.instrument(generate, 'RelayFlowGenerator.generate'),
	  transforms: FLOW_TRANSFORMS
	};

/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 *  strict-local
	 * @format
	 */

	'use strict';

	var _extends3 = _interopRequireDefault(__webpack_require__(9));

	var _toConsumableArray3 = _interopRequireDefault(__webpack_require__(10));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var canHaveSelections = __webpack_require__(1).SchemaUtils.canHaveSelections,
	    getRawType = __webpack_require__(1).SchemaUtils.getRawType,
	    hasID = __webpack_require__(1).SchemaUtils.hasID,
	    implementsInterface = __webpack_require__(1).SchemaUtils.implementsInterface,
	    isAbstractType = __webpack_require__(1).SchemaUtils.isAbstractType,
	    mayImplement = __webpack_require__(1).SchemaUtils.mayImplement;

	var ID = 'id';
	var ID_TYPE = 'ID';
	var NODE_TYPE = 'Node';

	/**
	 * A transform that adds an `id` field on any type that has an id field but
	 * where there is no unaliased `id` selection.
	 */
	function relayGenerateIDFieldTransform(context) {
	  var idType = __webpack_require__(3).assertLeafType(context.serverSchema.getType(ID_TYPE));
	  var idField = {
	    kind: 'ScalarField',
	    alias: null,
	    args: [],
	    directives: [],
	    handles: null,
	    metadata: null,
	    name: ID,
	    type: idType
	  };
	  var state = {
	    idField: idField
	  };
	  return __webpack_require__(1).IRTransformer.transform(context, {
	    LinkedField: visitLinkedField
	  }, function () {
	    return state;
	  });
	}

	function visitLinkedField(field, state) {
	  var transformedNode = this.traverse(field, state);

	  // If the field already has an unaliased `id` field, do nothing
	  if (__webpack_require__(40).hasUnaliasedSelection(field, ID)) {
	    return transformedNode;
	  }

	  var context = this.getContext();
	  var schema = context.serverSchema;
	  var unmodifiedType = __webpack_require__(3).assertCompositeType(getRawType(field.type));

	  // If the field type has an `id` subfield add an `id` selection
	  if (canHaveSelections(unmodifiedType) && hasID(schema, unmodifiedType)) {
	    return (0, _extends3['default'])({}, transformedNode, {
	      selections: [].concat((0, _toConsumableArray3['default'])(transformedNode.selections), [state.idField])
	    });
	  }

	  // If the field type is abstract, then generate a `... on Node { id }`
	  // fragment if *any* concrete type implements Node. Then generate a
	  // `... on PossibleType { id }` for every concrete type that does *not*
	  // implement `Node`
	  if (isAbstractType(unmodifiedType)) {
	    var selections = [].concat((0, _toConsumableArray3['default'])(transformedNode.selections));
	    if (mayImplement(schema, unmodifiedType, NODE_TYPE)) {
	      var nodeType = __webpack_require__(3).assertCompositeType(schema.getType(NODE_TYPE));
	      selections.push(buildIDFragment(nodeType, state.idField));
	    }
	    var abstractType = __webpack_require__(3).assertAbstractType(unmodifiedType);
	    schema.getPossibleTypes(abstractType).forEach(function (possibleType) {
	      if (!implementsInterface(possibleType, NODE_TYPE) && hasID(schema, possibleType)) {
	        selections.push(buildIDFragment(possibleType, state.idField));
	      }
	    });
	    return (0, _extends3['default'])({}, transformedNode, {
	      selections: selections
	    });
	  }

	  return transformedNode;
	}

	/**
	 * @internal
	 *
	 * Returns IR for `... on FRAGMENT_TYPE { id }`
	 */
	function buildIDFragment(fragmentType, idField) {
	  return {
	    kind: 'InlineFragment',
	    directives: [],
	    metadata: null,
	    typeCondition: fragmentType,
	    selections: [idField]
	  };
	}

	module.exports = {
	  transform: relayGenerateIDFieldTransform
	};

/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 *  strict-local
	 * @format
	 */

	'use strict';

	module.exports = function () {
	  return {
	    inputExtensions: ['js', 'jsx'],
	    outputExtension: 'js',
	    typeGenerator: __webpack_require__(70),
	    formatModule: __webpack_require__(79),
	    findGraphQLTags: __webpack_require__(62).find
	  };
	};

/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 *  strict-local
	 * @format
	 */

	'use strict';

	var _extends3 = _interopRequireDefault(__webpack_require__(9));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	/**
	 * A transform that removes field `handles`. Intended for use when e.g.
	 * printing queries to send to a GraphQL server.
	 */
	function relaySkipHandleFieldTransform(context) {
	  return __webpack_require__(1).IRTransformer.transform(context, {
	    LinkedField: visitField,
	    ScalarField: visitField
	  });
	}

	function visitField(field) {
	  var transformedNode = this.traverse(field);
	  if (transformedNode.handles) {
	    return (0, _extends3['default'])({}, transformedNode, {
	      handles: null
	    });
	  }
	  return transformedNode;
	}

	module.exports = {
	  transform: relaySkipHandleFieldTransform
	};

/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 *  strict-local
	 * @format
	 */

	'use strict';

	var _toConsumableArray3 = _interopRequireDefault(__webpack_require__(10));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var parseGraphQL = __webpack_require__(1).Profiler.instrument(__webpack_require__(3).parse, 'GraphQL.parse');

	var FIND_OPTIONS = {
	  validateNames: true
	};

	module.exports = function (tagFinder) {
	  var memoizedTagFinder = __webpack_require__(69).memoizedFind.bind(null, tagFinder);

	  // Throws an error if parsing the file fails
	  function parseFile(baseDir, file) {
	    var text = __webpack_require__(11).readFileSync(__webpack_require__(6).join(baseDir, file.relPath), 'utf8');

	    !(text.indexOf('graphql') >= 0) ?  true ? __webpack_require__(4)(false, 'RelaySourceModuleParser: Files should be filtered before passed to the ' + 'parser, got unfiltered file `%s`.', file.relPath) : require('fbjs/lib/invariant')(false) : void 0;

	    var astDefinitions = [];
	    memoizedTagFinder(text, baseDir, file, FIND_OPTIONS).forEach(function (template) {
	      var ast = parseGraphQL(new (__webpack_require__(3).Source)(template, file.relPath));
	      !ast.definitions.length ?  true ? __webpack_require__(4)(false, 'RelaySourceModuleParser: Expected GraphQL text to contain at least one ' + 'definition (fragment, mutation, query, subscription), got `%s`.', template) : require('fbjs/lib/invariant')(false) : void 0;
	      astDefinitions.push.apply(astDefinitions, (0, _toConsumableArray3['default'])(ast.definitions));
	    });

	    return {
	      kind: 'Document',
	      definitions: astDefinitions
	    };
	  }

	  function getParser(baseDir) {
	    return new (__webpack_require__(1).ASTCache)({
	      baseDir: baseDir,
	      parse: parseFile
	    });
	  }

	  function getFileFilter(baseDir) {
	    return function (file) {
	      var text = __webpack_require__(11).readFileSync(__webpack_require__(6).join(baseDir, file.relPath), 'utf8');
	      return text.indexOf('graphql') >= 0;
	    };
	  }

	  return {
	    getParser: getParser,
	    getFileFilter: getFileFilter,
	    parseFile: parseFile
	  };
	};

/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 *  strict-local
	 * @format
	 */

	'use strict';

	var _extends3 = _interopRequireDefault(__webpack_require__(9));

	var _toConsumableArray3 = _interopRequireDefault(__webpack_require__(10));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var getRawType = __webpack_require__(1).SchemaUtils.getRawType;

	var ID = 'id';
	var VIEWER_HANDLE = 'viewer';
	var VIEWER_TYPE = 'Viewer';

	/**
	 * A transform that adds a "viewer" handle to all fields whose type is `Viewer`.
	 */
	function relayViewerHandleTransform(context) {
	  var viewerType = context.serverSchema.getType(VIEWER_TYPE);
	  if (viewerType == null || !(viewerType instanceof __webpack_require__(3).GraphQLObjectType) || viewerType.getFields()[ID] != null) {
	    return context;
	  }
	  return __webpack_require__(1).IRTransformer.transform(context, {
	    LinkedField: visitLinkedField
	  });
	}

	function visitLinkedField(field) {
	  var transformedNode = this.traverse(field);
	  if (getRawType(field.type).name !== VIEWER_TYPE) {
	    return transformedNode;
	  }
	  var handles = transformedNode.handles;
	  var viewerHandle = {
	    name: VIEWER_HANDLE,
	    key: __webpack_require__(7).DEFAULT_HANDLE_KEY,
	    filters: null
	  };

	  if (handles && !handles.find(function (handle) {
	    return handle.name === VIEWER_HANDLE;
	  })) {
	    handles = [].concat((0, _toConsumableArray3['default'])(handles), [viewerHandle]);
	  } else if (!handles) {
	    handles = [viewerHandle];
	  }
	  return handles !== transformedNode.handles ? (0, _extends3['default'])({}, transformedNode, { handles: handles }) : transformedNode;
	}

	module.exports = {
	  transform: relayViewerHandleTransform
	};

/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 *  strict-local
	 * @format
	 */

	'use strict';

	var _toConsumableArray3 = _interopRequireDefault(__webpack_require__(10));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	/**
	 * Transforms the provided compiler context
	 *
	 * compileRelayArtifacts generates artifacts for Relay's runtime as a result of
	 * applying a series of transforms. Each kind of artifact is dependent on
	 * transforms being applied in the following order:
	 *
	 *   - Fragment Readers: commonTransforms, fragmentTransforms
	 *   - Operation Writers: commonTransforms, queryTransforms, codegenTransforms
	 *   - GraphQL Text: commonTransforms, queryTransforms, printTransforms
	 *
	 * The order of the transforms applied for each artifact below is important.
	 * CompilerContext will memoize applying each transform, so while
	 * `commonTransforms` appears in each artifacts' application, it will not result
	 * in repeated work as long as the order remains consistent across each context.
	 */
	function compileRelayArtifacts(context, transforms, reporter) {
	  return __webpack_require__(1).Profiler.run('GraphQLCompiler.compile', function () {
	    // The fragment is used for reading data from the normalized store.
	    var fragmentContext = context.applyTransforms([].concat((0, _toConsumableArray3['default'])(transforms.commonTransforms), (0, _toConsumableArray3['default'])(transforms.fragmentTransforms)), reporter);

	    // The unflattened query is used for printing, since flattening creates an
	    // invalid query.
	    var printContext = context.applyTransforms([].concat((0, _toConsumableArray3['default'])(transforms.commonTransforms), (0, _toConsumableArray3['default'])(transforms.queryTransforms), (0, _toConsumableArray3['default'])(transforms.printTransforms)), reporter);

	    // The flattened query is used for codegen in order to reduce the number of
	    // duplicate fields that must be processed during response normalization.
	    var codeGenContext = context.applyTransforms([].concat((0, _toConsumableArray3['default'])(transforms.commonTransforms), (0, _toConsumableArray3['default'])(transforms.queryTransforms), (0, _toConsumableArray3['default'])(transforms.codegenTransforms)), reporter);

	    return fragmentContext.documents().map(function (node) {
	      return __webpack_require__(64).generate(node.kind === 'Fragment' ? node : {
	        kind: 'Batch',
	        metadata: codeGenContext.getRoot(node.name).metadata || {},
	        name: node.name,
	        fragment: {
	          kind: 'Fragment',
	          argumentDefinitions: node.argumentDefinitions,
	          directives: node.directives,
	          metadata: null,
	          name: node.name,
	          selections: node.selections,
	          type: node.type
	        },
	        requests: __webpack_require__(82)(printContext, codeGenContext, node.name)
	      });
	    });
	  });
	}

	module.exports = compileRelayArtifacts;

/***/ }),
/* 77 */
/***/ (function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 * @format
	 */

	'use strict';

	/**
	 * This function works similar to JSON.stringify except that for the case there
	 * are multiple common subtrees, it generates a string for a IIFE that re-uses
	 * the same objects for the duplicate subtrees.
	 */

	function dedupeJSONStringify(jsonValue) {
	  // Clone the object to convert references to the same object instance into
	  // copies. This is needed for the WeakMap/Map to recognize them as duplicates.
	  jsonValue = JSON.parse(JSON.stringify(jsonValue));
	  var metadataForHash = new Map();
	  var metadataForVal = new WeakMap();
	  var varDefs = [];
	  collectMetadata(jsonValue);
	  collectDuplicates(jsonValue);
	  var code = printJSCode(false, '', jsonValue);
	  return varDefs.length === 0 ? code : '(function(){\nvar ' + varDefs.join(',\n') + ';\nreturn ' + code + ';\n})()';

	  // Collect common metadata for each object in the value tree, ensuring that
	  // equivalent values have the *same reference* to the same metadata. Note that
	  // the hashes generated are not exactly JSON, but still identify equivalent
	  // values. Runs in linear time due to hashing in a bottom-up recursion.
	  function collectMetadata(value) {
	    if (value == null || typeof value !== 'object') {
	      return JSON.stringify(value);
	    }
	    var hash = void 0;
	    if (Array.isArray(value)) {
	      hash = '[';
	      for (var i = 0; i < value.length; i++) {
	        hash += collectMetadata(value[i]) + ',';
	      }
	    } else {
	      hash = '{';
	      for (var k in value) {
	        if (value.hasOwnProperty(k) && value[k] !== undefined) {
	          hash += k + ':' + collectMetadata(value[k]) + ',';
	        }
	      }
	    }
	    var metadata = metadataForHash.get(hash);
	    if (!metadata) {
	      metadata = { value: value, hash: hash, isDuplicate: false };
	      metadataForHash.set(hash, metadata);
	    }
	    metadataForVal.set(value, metadata);
	    return hash;
	  }

	  // Using top-down recursion, linearly scan the JSON tree to determine which
	  // values should be deduplicated.
	  function collectDuplicates(value) {
	    if (value == null || typeof value !== 'object') {
	      return;
	    }
	    var metadata = metadataForVal.get(value);
	    // Only consider duplicates with hashes longer than 2 (excludes [] and {}).
	    if (metadata && metadata.value !== value && metadata.hash.length > 2) {
	      metadata.isDuplicate = true;
	      return;
	    }
	    if (Array.isArray(value)) {
	      for (var i = 0; i < value.length; i++) {
	        collectDuplicates(value[i]);
	      }
	    } else {
	      for (var k in value) {
	        if (value.hasOwnProperty(k) && value[k] !== undefined) {
	          collectDuplicates(value[k]);
	        }
	      }
	    }
	  }

	  // Stringify JS, replacing duplicates with variable references.
	  function printJSCode(isDupedVar, depth, value) {
	    if (value == null || typeof value !== 'object') {
	      return JSON.stringify(value);
	    }
	    // Only use variable references at depth beyond the top level.
	    if (depth !== '') {
	      var metadata = metadataForVal.get(value);
	      if (metadata && metadata.isDuplicate) {
	        if (!metadata.varName) {
	          var refCode = printJSCode(true, '', value);
	          metadata.varName = 'v' + varDefs.length;
	          varDefs.push(metadata.varName + ' = ' + refCode);
	        }
	        return metadata.varName;
	      }
	    }
	    var str = void 0;
	    var isEmpty = true;
	    var depth2 = depth + '  ';
	    if (Array.isArray(value)) {
	      // Empty arrays can only have one inferred flow type and then conflict if
	      // used in different places, this is unsound if we would write to them but
	      // this whole module is based on the idea of a read only JSON tree.
	      if (isDupedVar && value.length === 0) {
	        return '([]/*: any*/)';
	      }
	      str = '[';
	      for (var i = 0; i < value.length; i++) {
	        str += (isEmpty ? '\n' : ',\n') + depth2 + printJSCode(isDupedVar, depth2, value[i]);
	        isEmpty = false;
	      }
	      str += isEmpty ? ']' : '\n' + depth + ']';
	    } else {
	      str = '{';
	      for (var k in value) {
	        if (value.hasOwnProperty(k) && value[k] !== undefined) {
	          str += (isEmpty ? '\n' : ',\n') + depth2 + JSON.stringify(k) + ': ' + printJSCode(isDupedVar, depth2, value[k]);
	          isEmpty = false;
	        }
	      }
	      str += isEmpty ? '}' : '\n' + depth + '}';
	    }
	    return str;
	  }
	}

	module.exports = dedupeJSONStringify;

/***/ }),
/* 78 */
/***/ (function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 * @format
	 */

	'use strict';

	/**
	 * Given a object of nested properties, return JavaScript text that would merge
	 * in an object named `objectName` by a series of individual assignments.
	 */

	function deepMergeAssignments(objectName, properties) {
	  var assignments = [];
	  collectAssignmentsInto(assignments, [], properties);
	  var jsAssignments = assignments.map(function (_ref) {
	    var path = _ref.path,
	        value = _ref.value;
	    return formatJSAssignment(objectName, path, value);
	  });
	  return jsAssignments.length === 0 ? '' : jsAssignments.join('\n');
	}

	// Recursively collect assignments
	function collectAssignmentsInto(assignments, parentPath, parentValue) {
	  // Iterate over the entries in the array or object.
	  forEach(parentValue, function (value, key) {
	    // The "path" is the sequence of keys to arrive at this assignment.
	    var path = parentPath.concat(key);
	    // For each entry, either add an assignment or recurse.
	    if (typeof value === 'object' && value !== null) {
	      collectAssignmentsInto(assignments, path, value);
	    } else {
	      assignments.push({ path: path, value: value });
	    }
	  });
	}

	// Print a path/value pair as a JS assignment expression.
	function formatJSAssignment(objectName, path, value) {
	  var assignmentPath = path.map(function (p) {
	    return typeof p === 'string' ? '.' + p : '[' + p + ']';
	  }).join('');
	  var jsValue = value === undefined ? 'undefined' : JSON.stringify(value);
	  return '' + objectName + assignmentPath + ' = ' + jsValue + ';';
	}

	// Utility for looping over entries in both Arrays and Objects.
	function forEach(value, fn) {
	  if (Array.isArray(value)) {
	    for (var i = 0; i < value.length; i++) {
	      fn(value[i], i);
	    }
	  } else {
	    for (var k in value) {
	      if (value.hasOwnProperty(k)) {
	        fn(value[k], k);
	      }
	    }
	  }
	}

	module.exports = deepMergeAssignments;

/***/ }),
/* 79 */
/***/ (function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 * @format
	 */

	'use strict';

	var formatGeneratedModule = function formatGeneratedModule(_ref) {
	  var moduleName = _ref.moduleName,
	      documentType = _ref.documentType,
	      docText = _ref.docText,
	      concreteText = _ref.concreteText,
	      typeText = _ref.typeText,
	      hash = _ref.hash,
	      relayRuntimeModule = _ref.relayRuntimeModule,
	      sourceHash = _ref.sourceHash;

	  var documentTypeImport = documentType ? 'import type { ' + documentType + ' } from \'' + relayRuntimeModule + '\';' : '';
	  var docTextComment = docText ? '\n/*\n' + docText.trim() + '\n*/\n' : '';
	  var hashText = hash ? '\n * ' + hash : '';
	  return '/**\n * ' + '@' + 'flow' + hashText + '\n */\n\n/* eslint-disable */\n\n\'use strict\';\n\n/*::\n' + documentTypeImport + '\n' + (typeText || '') + '\n*/\n\n' + docTextComment + '\nconst node/*: ' + (documentType || 'empty') + '*/ = ' + concreteText + ';\n// prettier-ignore\n(node/*: any*/).hash = \'' + sourceHash + '\';\nmodule.exports = node;\n';
	};

	module.exports = formatGeneratedModule;

/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 *  strict
	 * @format
	 */

	'use strict';

	function getModuleName(filePath) {
	  // index.js -> index
	  // index.js.flow -> index.js
	  var filename = __webpack_require__(6).basename(filePath, __webpack_require__(6).extname(filePath));

	  // index.js -> index (when extension has multiple segments)
	  filename = filename.replace(/(?:\.\w+)+/, '');

	  // /path/to/button/index.js -> button
	  var moduleName = filename === 'index' ? __webpack_require__(6).basename(__webpack_require__(6).dirname(filePath)) : filename;

	  // Example.ios -> Example
	  // Example.product.android -> Example
	  moduleName = moduleName.replace(/(?:\.\w+)+/, '');

	  // foo-bar -> fooBar
	  // Relay compatibility mode splits on _, so we can't use that here.
	  moduleName = moduleName.replace(/[^a-zA-Z0-9]+(\w?)/g, function (match, next) {
	    return next.toUpperCase();
	  });

	  return moduleName;
	}

	module.exports = getModuleName;

/***/ }),
/* 81 */
/***/ (function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * Based on implementations by Gary Court and Austin Appleby, 2011, MIT.
	 *
	 *  strict
	 * @format
	 */

	'use strict';

	var BASE62 = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';

	/**
	 * @param {string} key A UTF-16 or ASCII string
	 * @return {string} a base62 murmur hash
	 */
	function murmurHash(str) {
	  /* eslint-disable no-bitwise */
	  var length = str.length;
	  var rem = length & 3;
	  var len = length ^ rem;

	  var h = 0;
	  var i = 0;
	  var k = void 0;

	  while (i !== len) {
	    var ch4 = str.charCodeAt(i + 3);

	    k = str.charCodeAt(i) ^ str.charCodeAt(i + 1) << 8 ^ str.charCodeAt(i + 2) << 16 ^ (ch4 & 0xff) << 24 ^ (ch4 & 0xff00) >> 8;

	    i += 4;

	    k = k * 0x2d51 + (k & 0xffff) * 0xcc9e0000 >>> 0;
	    k = k << 15 | k >>> 17;
	    k = k * 0x3593 + (k & 0xffff) * 0x1b870000 >>> 0;
	    h ^= k;
	    h = h << 13 | h >>> 19;
	    h = h * 5 + 0xe6546b64 >>> 0;
	  }

	  k = 0;
	  switch (rem) {
	    /* eslint-disable no-fallthrough */
	    case 3:
	      k ^= str.charCodeAt(len + 2) << 16;
	    case 2:
	      k ^= str.charCodeAt(len + 1) << 8;
	    case 1:
	      k ^= str.charCodeAt(len);

	      k = k * 0x2d51 + (k & 0xffff) * 0xcc9e0000 >>> 0;
	      k = k << 15 | k >>> 17;
	      k = k * 0x3593 + (k & 0xffff) * 0x1b870000 >>> 0;
	      h ^= k;
	  }

	  h ^= length;
	  h ^= h >>> 16;
	  h = h * 0xca6b + (h & 0xffff) * 0x85eb0000 >>> 0;
	  h ^= h >>> 13;
	  h = h * 0xae35 + (h & 0xffff) * 0xc2b20000 >>> 0;
	  h ^= h >>> 16;

	  h >>>= 0;

	  if (!h) {
	    return '0';
	  }

	  var s = '';
	  while (h) {
	    var d = h % 62;
	    s = BASE62[d] + s;
	    h = (h - d) / 62;
	  }
	  return s;
	}

	module.exports = murmurHash;

/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 *  strict-local
	 * @format
	 */

	'use strict';

	var _extends3 = _interopRequireDefault(__webpack_require__(9));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function requestsForOperation(printContext, codeGenContext, initialRootName) {
	  var operationToRequestName = new Map();
	  return requestsInto([], {
	    operationName: initialRootName,
	    argumentDependencies: []
	  });
	  function requestsInto(requests, dependent) {
	    var name = dependent.operationName;
	    // Create a unique name for this request.
	    var num = 0;
	    var requestName = void 0;
	    do {
	      requestName = name + (++num > 1 ? num : '');
	    } while (requests.some(function (request) {
	      return request.name === requestName;
	    }));
	    operationToRequestName.set(name, requestName);
	    // Collect the dependent arguments for this request.
	    var codeGenRoot = codeGenContext.getRoot(name);
	    var argumentDependencies = dependent.argumentDependencies;
	    var dependentRequests = codeGenRoot.dependentRequests;
	    var rerunDependency = dependentRequests.find(function (next) {
	      return next.operationName === dependent.operationName;
	    });
	    if (rerunDependency) {
	      dependentRequests = dependentRequests.filter(function (next) {
	        return next !== rerunDependency;
	      });
	      argumentDependencies = argumentDependencies.concat(rerunDependency.argumentDependencies);
	    }
	    // Create a request for this operation.
	    requests.push({
	      kind: 'Request',
	      name: requestName,
	      id: null,
	      text: printOperation(printContext, name),
	      argumentDependencies: argumentDependencies.map(function (argDep) {
	        return (0, _extends3['default'])({}, argDep, {
	          fromName: operationToRequestName.get(argDep.fromName)
	        });
	      }),
	      root: codeGenRoot,
	      /* $FlowFixMe(>=0.68.0 site=react_native_fb,react_native_oss) This comment
	       * suppresses an error found when Flow v0.68 was deployed. To see the
	       * error delete this comment and run Flow. */
	      metadata: dependent.metadata || undefined
	    });
	    // Collect any requests that were dependent on this one as well.
	    return dependentRequests.reduce(requestsInto, requests);
	  }
	}

	function printOperation(printContext, name) {
	  var printableRoot = printContext.getRoot(name);
	  return __webpack_require__(1).filterContextForNode(printableRoot, printContext).documents().map(__webpack_require__(1).Printer.print).join('\n');
	}

	module.exports = requestsForOperation;

/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 * @format
	 */

	'use strict';

	var _asyncToGenerator2 = __webpack_require__(33);

	var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

	var _extends3 = _interopRequireDefault(__webpack_require__(9));

	let writeRelayGeneratedFile = (() => {
	  var _ref = (0, _asyncToGenerator3.default)(function* (codegenDir, generatedNode, formatModule, typeText, _persistQuery, platform, relayRuntimeModule, sourceHash, extension) {
	    // Copy to const so Flow can refine.
	    var persistQuery = _persistQuery;
	    var moduleName = generatedNode.name + '.graphql';
	    var platformName = platform ? moduleName + '.' + platform : moduleName;
	    var filename = platformName + '.' + extension;
	    var typeName = generatedNode.kind === __webpack_require__(7).RelayConcreteNode.FRAGMENT ? 'ConcreteFragment' : generatedNode.kind === __webpack_require__(7).RelayConcreteNode.REQUEST ? 'ConcreteRequest' : generatedNode.kind === __webpack_require__(7).RelayConcreteNode.BATCH_REQUEST ? 'ConcreteBatchRequest' : null;
	    var devOnlyProperties = {};

	    var docText = void 0;
	    if (generatedNode.kind === __webpack_require__(7).RelayConcreteNode.REQUEST) {
	      docText = generatedNode.text;
	    } else if (generatedNode.kind === __webpack_require__(7).RelayConcreteNode.BATCH_REQUEST) {
	      docText = generatedNode.requests.map(function (request) {
	        return request.text;
	      }).join('\n\n');
	    }

	    var hash = null;
	    if (generatedNode.kind === __webpack_require__(7).RelayConcreteNode.REQUEST || generatedNode.kind === __webpack_require__(7).RelayConcreteNode.BATCH_REQUEST) {
	      var oldHash = __webpack_require__(1).Profiler.run('RelayFileWriter:compareHash', function () {
	        var oldContent = codegenDir.read(filename);
	        // Hash the concrete node including the query text.
	        var hasher = __webpack_require__(35).createHash('md5');
	        hasher.update('cache-breaker-7');
	        hasher.update(JSON.stringify(generatedNode));
	        hasher.update(sourceHash);
	        if (typeText) {
	          hasher.update(typeText);
	        }
	        if (persistQuery) {
	          hasher.update('persisted');
	        }
	        hash = hasher.digest('hex');
	        return extractHash(oldContent);
	      });
	      if (hash === oldHash) {
	        codegenDir.markUnchanged(filename);
	        return null;
	      }
	      if (codegenDir.onlyValidate) {
	        codegenDir.markUpdated(filename);
	        return null;
	      }
	      if (persistQuery) {
	        switch (generatedNode.kind) {
	          case __webpack_require__(7).RelayConcreteNode.REQUEST:
	            devOnlyProperties.text = generatedNode.text;
	            generatedNode = (0, _extends3['default'])({}, generatedNode, {
	              text: null,
	              id: yield persistQuery(__webpack_require__(18)(generatedNode.text))
	            });
	            break;
	          case __webpack_require__(7).RelayConcreteNode.BATCH_REQUEST:
	            devOnlyProperties.requests = generatedNode.requests.map(function (request) {
	              return {
	                text: request.text
	              };
	            });
	            generatedNode = (0, _extends3['default'])({}, generatedNode, {
	              requests: yield Promise.all(generatedNode.requests.map((() => {
	                var _ref2 = (0, _asyncToGenerator3.default)(function* (request) {
	                  return (0, _extends3['default'])({}, request, {
	                    text: null,
	                    id: yield persistQuery(__webpack_require__(18)(request.text))
	                  });
	                });

	                return function (_x10) {
	                  return _ref2.apply(this, arguments);
	                };
	              })()))
	            });
	            break;
	          case __webpack_require__(7).RelayConcreteNode.FRAGMENT:
	            // Do not persist fragments.
	            break;
	          default:
	            generatedNode.kind;
	        }
	      }
	    }

	    var devOnlyAssignments = __webpack_require__(78)('node', devOnlyProperties);

	    var moduleText = formatModule({
	      moduleName: moduleName,
	      documentType: typeName,
	      docText: docText,
	      typeText: typeText,
	      hash: hash ? '@relayHash ' + hash : null,
	      concreteText: __webpack_require__(77)(generatedNode),
	      devOnlyAssignments: devOnlyAssignments,
	      relayRuntimeModule: relayRuntimeModule,
	      sourceHash: sourceHash
	    });

	    codegenDir.writeFile(filename, moduleText);
	    return generatedNode;
	  });

	  return function writeRelayGeneratedFile(_x, _x2, _x3, _x4, _x5, _x6, _x7, _x8, _x9) {
	    return _ref.apply(this, arguments);
	  };
	})();

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function extractHash(text) {
	  if (!text) {
	    return null;
	  }
	  if (/<<<<<|>>>>>/.test(text)) {
	    // looks like a merge conflict
	    return null;
	  }
	  var match = text.match(/@relayHash (\w{32})\b/m);
	  return match && match[1];
	}

	module.exports = writeRelayGeneratedFile;

/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;

	function _trimRight() {
	  const data = _interopRequireDefault(__webpack_require__(159));

	  _trimRight = function () {
	    return data;
	  };

	  return data;
	}

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	const SPACES_RE = /^[ \t]+$/;

	class Buffer {
	  constructor(map) {
	    this._map = null;
	    this._buf = [];
	    this._last = "";
	    this._queue = [];
	    this._position = {
	      line: 1,
	      column: 0
	    };
	    this._sourcePosition = {
	      identifierName: null,
	      line: null,
	      column: null,
	      filename: null
	    };
	    this._disallowedPop = null;
	    this._map = map;
	  }

	  get() {
	    this._flush();

	    const map = this._map;
	    const result = {
	      code: (0, _trimRight().default)(this._buf.join("")),
	      map: null,
	      rawMappings: map && map.getRawMappings()
	    };

	    if (map) {
	      Object.defineProperty(result, "map", {
	        configurable: true,
	        enumerable: true,

	        get() {
	          return this.map = map.get();
	        },

	        set(value) {
	          Object.defineProperty(this, "map", {
	            value,
	            writable: true
	          });
	        }

	      });
	    }

	    return result;
	  }

	  append(str) {
	    this._flush();

	    const {
	      line,
	      column,
	      filename,
	      identifierName,
	      force
	    } = this._sourcePosition;

	    this._append(str, line, column, identifierName, filename, force);
	  }

	  queue(str) {
	    if (str === "\n") {
	      while (this._queue.length > 0 && SPACES_RE.test(this._queue[0][0])) {
	        this._queue.shift();
	      }
	    }

	    const {
	      line,
	      column,
	      filename,
	      identifierName,
	      force
	    } = this._sourcePosition;

	    this._queue.unshift([str, line, column, identifierName, filename, force]);
	  }

	  _flush() {
	    let item;

	    while (item = this._queue.pop()) this._append(...item);
	  }

	  _append(str, line, column, identifierName, filename, force) {
	    if (this._map && str[0] !== "\n") {
	      this._map.mark(this._position.line, this._position.column, line, column, identifierName, filename, force);
	    }

	    this._buf.push(str);

	    this._last = str[str.length - 1];

	    for (let i = 0; i < str.length; i++) {
	      if (str[i] === "\n") {
	        this._position.line++;
	        this._position.column = 0;
	      } else {
	        this._position.column++;
	      }
	    }
	  }

	  removeTrailingNewline() {
	    if (this._queue.length > 0 && this._queue[0][0] === "\n") {
	      this._queue.shift();
	    }
	  }

	  removeLastSemicolon() {
	    if (this._queue.length > 0 && this._queue[0][0] === ";") {
	      this._queue.shift();
	    }
	  }

	  endsWith(suffix) {
	    if (suffix.length === 1) {
	      let last;

	      if (this._queue.length > 0) {
	        const str = this._queue[0][0];
	        last = str[str.length - 1];
	      } else {
	        last = this._last;
	      }

	      return last === suffix;
	    }

	    const end = this._last + this._queue.reduce((acc, item) => item[0] + acc, "");

	    if (suffix.length <= end.length) {
	      return end.slice(-suffix.length) === suffix;
	    }

	    return false;
	  }

	  hasContent() {
	    return this._queue.length > 0 || !!this._last;
	  }

	  exactSource(loc, cb) {
	    this.source("start", loc, true);
	    cb();
	    this.source("end", loc);

	    this._disallowPop("start", loc);
	  }

	  source(prop, loc, force) {
	    if (prop && !loc) return;

	    this._normalizePosition(prop, loc, this._sourcePosition, force);
	  }

	  withSource(prop, loc, cb) {
	    if (!this._map) return cb();
	    const originalLine = this._sourcePosition.line;
	    const originalColumn = this._sourcePosition.column;
	    const originalFilename = this._sourcePosition.filename;
	    const originalIdentifierName = this._sourcePosition.identifierName;
	    this.source(prop, loc);
	    cb();

	    if ((!this._sourcePosition.force || this._sourcePosition.line !== originalLine || this._sourcePosition.column !== originalColumn || this._sourcePosition.filename !== originalFilename) && (!this._disallowedPop || this._disallowedPop.line !== originalLine || this._disallowedPop.column !== originalColumn || this._disallowedPop.filename !== originalFilename)) {
	      this._sourcePosition.line = originalLine;
	      this._sourcePosition.column = originalColumn;
	      this._sourcePosition.filename = originalFilename;
	      this._sourcePosition.identifierName = originalIdentifierName;
	      this._sourcePosition.force = false;
	      this._disallowedPop = null;
	    }
	  }

	  _disallowPop(prop, loc) {
	    if (prop && !loc) return;
	    this._disallowedPop = this._normalizePosition(prop, loc);
	  }

	  _normalizePosition(prop, loc, targetObj, force) {
	    const pos = loc ? loc[prop] : null;

	    if (targetObj === undefined) {
	      targetObj = {
	        identifierName: null,
	        line: null,
	        column: null,
	        filename: null,
	        force: false
	      };
	    }

	    const origLine = targetObj.line;
	    const origColumn = targetObj.column;
	    const origFilename = targetObj.filename;
	    targetObj.identifierName = prop === "start" && loc && loc.identifierName || null;
	    targetObj.line = pos ? pos.line : null;
	    targetObj.column = pos ? pos.column : null;
	    targetObj.filename = loc && loc.filename || null;

	    if (force || targetObj.line !== origLine || targetObj.column !== origColumn || targetObj.filename !== origFilename) {
	      targetObj.force = force;
	    }

	    return targetObj;
	  }

	  getCurrentColumn() {
	    const extra = this._queue.reduce((acc, item) => item[0] + acc, "");

	    const lastIndex = extra.lastIndexOf("\n");
	    return lastIndex === -1 ? this._position.column + extra.length : extra.length - 1 - lastIndex;
	  }

	  getCurrentLine() {
	    const extra = this._queue.reduce((acc, item) => item[0] + acc, "");

	    let count = 0;

	    for (let i = 0; i < extra.length; i++) {
	      if (extra[i] === "\n") count++;
	    }

	    return this._position.line + count;
	  }

	}

	exports.default = Buffer;

/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.File = File;
	exports.Program = Program;
	exports.BlockStatement = BlockStatement;
	exports.Noop = Noop;
	exports.Directive = Directive;
	exports.InterpreterDirective = InterpreterDirective;
	Object.defineProperty(exports, "DirectiveLiteral", {
	  enumerable: true,
	  get: function () {
	    return _types.StringLiteral;
	  }
	});

	var _types = __webpack_require__(26);

	function File(node) {
	  if (node.program) {
	    this.print(node.program.interpreter, node);
	  }

	  this.print(node.program, node);
	}

	function Program(node) {
	  this.printInnerComments(node, false);
	  this.printSequence(node.directives, node);
	  if (node.directives && node.directives.length) this.newline();
	  this.printSequence(node.body, node);
	}

	function BlockStatement(node) {
	  this.token("{");
	  this.printInnerComments(node);
	  const hasDirectives = node.directives && node.directives.length;

	  if (node.body.length || hasDirectives) {
	    this.newline();
	    this.printSequence(node.directives, node, {
	      indent: true
	    });
	    if (hasDirectives) this.newline();
	    this.printSequence(node.body, node, {
	      indent: true
	    });
	    this.removeTrailingNewline();
	    this.source("end", node.loc);
	    if (!this.endsWith("\n")) this.newline();
	    this.rightBrace();
	  } else {
	    this.source("end", node.loc);
	    this.token("}");
	  }
	}

	function Noop() {}

	function Directive(node) {
	  this.print(node.value, node);
	  this.semicolon();
	}

	function InterpreterDirective(node) {
	  this.token(`#!${node.value}\n`);
	}

/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.ClassExpression = exports.ClassDeclaration = ClassDeclaration;
	exports.ClassBody = ClassBody;
	exports.ClassProperty = ClassProperty;
	exports.ClassPrivateProperty = ClassPrivateProperty;
	exports.ClassMethod = ClassMethod;
	exports._classMethodHead = _classMethodHead;

	function t() {
	  const data = _interopRequireWildcard(__webpack_require__(2));

	  t = function () {
	    return data;
	  };

	  return data;
	}

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

	function ClassDeclaration(node, parent) {
	  if (!this.format.decoratorsBeforeExport || !t().isExportDefaultDeclaration(parent) && !t().isExportNamedDeclaration(parent)) {
	    this.printJoin(node.decorators, node);
	  }

	  if (node.declare) {
	    this.word("declare");
	    this.space();
	  }

	  if (node.abstract) {
	    this.word("abstract");
	    this.space();
	  }

	  this.word("class");

	  if (node.id) {
	    this.space();
	    this.print(node.id, node);
	  }

	  this.print(node.typeParameters, node);

	  if (node.superClass) {
	    this.space();
	    this.word("extends");
	    this.space();
	    this.print(node.superClass, node);
	    this.print(node.superTypeParameters, node);
	  }

	  if (node.implements) {
	    this.space();
	    this.word("implements");
	    this.space();
	    this.printList(node.implements, node);
	  }

	  this.space();
	  this.print(node.body, node);
	}

	function ClassBody(node) {
	  this.token("{");
	  this.printInnerComments(node);

	  if (node.body.length === 0) {
	    this.token("}");
	  } else {
	    this.newline();
	    this.indent();
	    this.printSequence(node.body, node);
	    this.dedent();
	    if (!this.endsWith("\n")) this.newline();
	    this.rightBrace();
	  }
	}

	function ClassProperty(node) {
	  this.printJoin(node.decorators, node);

	  if (node.accessibility) {
	    this.word(node.accessibility);
	    this.space();
	  }

	  if (node.static) {
	    this.word("static");
	    this.space();
	  }

	  if (node.abstract) {
	    this.word("abstract");
	    this.space();
	  }

	  if (node.readonly) {
	    this.word("readonly");
	    this.space();
	  }

	  if (node.computed) {
	    this.token("[");
	    this.print(node.key, node);
	    this.token("]");
	  } else {
	    this._variance(node);

	    this.print(node.key, node);
	  }

	  if (node.optional) {
	    this.token("?");
	  }

	  if (node.definite) {
	    this.token("!");
	  }

	  this.print(node.typeAnnotation, node);

	  if (node.value) {
	    this.space();
	    this.token("=");
	    this.space();
	    this.print(node.value, node);
	  }

	  this.semicolon();
	}

	function ClassPrivateProperty(node) {
	  if (node.static) {
	    this.word("static");
	    this.space();
	  }

	  this.print(node.key, node);
	  this.print(node.typeAnnotation, node);

	  if (node.value) {
	    this.space();
	    this.token("=");
	    this.space();
	    this.print(node.value, node);
	  }

	  this.semicolon();
	}

	function ClassMethod(node) {
	  this._classMethodHead(node);

	  this.space();
	  this.print(node.body, node);
	}

	function _classMethodHead(node) {
	  this.printJoin(node.decorators, node);

	  if (node.accessibility) {
	    this.word(node.accessibility);
	    this.space();
	  }

	  if (node.abstract) {
	    this.word("abstract");
	    this.space();
	  }

	  if (node.static) {
	    this.word("static");
	    this.space();
	  }

	  this._methodHead(node);
	}

/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.UnaryExpression = UnaryExpression;
	exports.DoExpression = DoExpression;
	exports.ParenthesizedExpression = ParenthesizedExpression;
	exports.UpdateExpression = UpdateExpression;
	exports.ConditionalExpression = ConditionalExpression;
	exports.NewExpression = NewExpression;
	exports.SequenceExpression = SequenceExpression;
	exports.ThisExpression = ThisExpression;
	exports.Super = Super;
	exports.Decorator = Decorator;
	exports.OptionalMemberExpression = OptionalMemberExpression;
	exports.OptionalCallExpression = OptionalCallExpression;
	exports.CallExpression = CallExpression;
	exports.Import = Import;
	exports.EmptyStatement = EmptyStatement;
	exports.ExpressionStatement = ExpressionStatement;
	exports.AssignmentPattern = AssignmentPattern;
	exports.LogicalExpression = exports.BinaryExpression = exports.AssignmentExpression = AssignmentExpression;
	exports.BindExpression = BindExpression;
	exports.MemberExpression = MemberExpression;
	exports.MetaProperty = MetaProperty;
	exports.PrivateName = PrivateName;
	exports.AwaitExpression = exports.YieldExpression = void 0;

	function t() {
	  const data = _interopRequireWildcard(__webpack_require__(2));

	  t = function () {
	    return data;
	  };

	  return data;
	}

	var n = _interopRequireWildcard(__webpack_require__(43));

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

	function UnaryExpression(node) {
	  if (node.operator === "void" || node.operator === "delete" || node.operator === "typeof") {
	    this.word(node.operator);
	    this.space();
	  } else {
	    this.token(node.operator);
	  }

	  this.print(node.argument, node);
	}

	function DoExpression(node) {
	  this.word("do");
	  this.space();
	  this.print(node.body, node);
	}

	function ParenthesizedExpression(node) {
	  this.token("(");
	  this.print(node.expression, node);
	  this.token(")");
	}

	function UpdateExpression(node) {
	  if (node.prefix) {
	    this.token(node.operator);
	    this.print(node.argument, node);
	  } else {
	    this.startTerminatorless(true);
	    this.print(node.argument, node);
	    this.endTerminatorless();
	    this.token(node.operator);
	  }
	}

	function ConditionalExpression(node) {
	  this.print(node.test, node);
	  this.space();
	  this.token("?");
	  this.space();
	  this.print(node.consequent, node);
	  this.space();
	  this.token(":");
	  this.space();
	  this.print(node.alternate, node);
	}

	function NewExpression(node, parent) {
	  this.word("new");
	  this.space();
	  this.print(node.callee, node);

	  if (this.format.minified && node.arguments.length === 0 && !node.optional && !t().isCallExpression(parent, {
	    callee: node
	  }) && !t().isMemberExpression(parent) && !t().isNewExpression(parent)) {
	    return;
	  }

	  this.print(node.typeArguments, node);
	  this.print(node.typeParameters, node);

	  if (node.optional) {
	    this.token("?.");
	  }

	  this.token("(");
	  this.printList(node.arguments, node);
	  this.token(")");
	}

	function SequenceExpression(node) {
	  this.printList(node.expressions, node);
	}

	function ThisExpression() {
	  this.word("this");
	}

	function Super() {
	  this.word("super");
	}

	function Decorator(node) {
	  this.token("@");
	  this.print(node.expression, node);
	  this.newline();
	}

	function OptionalMemberExpression(node) {
	  this.print(node.object, node);

	  if (!node.computed && t().isMemberExpression(node.property)) {
	    throw new TypeError("Got a MemberExpression for MemberExpression property");
	  }

	  let computed = node.computed;

	  if (t().isLiteral(node.property) && typeof node.property.value === "number") {
	    computed = true;
	  }

	  if (node.optional) {
	    this.token("?.");
	  }

	  if (computed) {
	    this.token("[");
	    this.print(node.property, node);
	    this.token("]");
	  } else {
	    if (!node.optional) {
	      this.token(".");
	    }

	    this.print(node.property, node);
	  }
	}

	function OptionalCallExpression(node) {
	  this.print(node.callee, node);
	  this.print(node.typeArguments, node);
	  this.print(node.typeParameters, node);

	  if (node.optional) {
	    this.token("?.");
	  }

	  this.token("(");
	  this.printList(node.arguments, node);
	  this.token(")");
	}

	function CallExpression(node) {
	  this.print(node.callee, node);
	  this.print(node.typeArguments, node);
	  this.print(node.typeParameters, node);
	  this.token("(");
	  this.printList(node.arguments, node);
	  this.token(")");
	}

	function Import() {
	  this.word("import");
	}

	function buildYieldAwait(keyword) {
	  return function (node) {
	    this.word(keyword);

	    if (node.delegate) {
	      this.token("*");
	    }

	    if (node.argument) {
	      this.space();
	      const terminatorState = this.startTerminatorless();
	      this.print(node.argument, node);
	      this.endTerminatorless(terminatorState);
	    }
	  };
	}

	const YieldExpression = buildYieldAwait("yield");
	exports.YieldExpression = YieldExpression;
	const AwaitExpression = buildYieldAwait("await");
	exports.AwaitExpression = AwaitExpression;

	function EmptyStatement() {
	  this.semicolon(true);
	}

	function ExpressionStatement(node) {
	  this.print(node.expression, node);
	  this.semicolon();
	}

	function AssignmentPattern(node) {
	  this.print(node.left, node);
	  if (node.left.optional) this.token("?");
	  this.print(node.left.typeAnnotation, node);
	  this.space();
	  this.token("=");
	  this.space();
	  this.print(node.right, node);
	}

	function AssignmentExpression(node, parent) {
	  const parens = this.inForStatementInitCounter && node.operator === "in" && !n.needsParens(node, parent);

	  if (parens) {
	    this.token("(");
	  }

	  this.print(node.left, node);
	  this.space();

	  if (node.operator === "in" || node.operator === "instanceof") {
	    this.word(node.operator);
	  } else {
	    this.token(node.operator);
	  }

	  this.space();
	  this.print(node.right, node);

	  if (parens) {
	    this.token(")");
	  }
	}

	function BindExpression(node) {
	  this.print(node.object, node);
	  this.token("::");
	  this.print(node.callee, node);
	}

	function MemberExpression(node) {
	  this.print(node.object, node);

	  if (!node.computed && t().isMemberExpression(node.property)) {
	    throw new TypeError("Got a MemberExpression for MemberExpression property");
	  }

	  let computed = node.computed;

	  if (t().isLiteral(node.property) && typeof node.property.value === "number") {
	    computed = true;
	  }

	  if (computed) {
	    this.token("[");
	    this.print(node.property, node);
	    this.token("]");
	  } else {
	    this.token(".");
	    this.print(node.property, node);
	  }
	}

	function MetaProperty(node) {
	  this.print(node.meta, node);
	  this.token(".");
	  this.print(node.property, node);
	}

	function PrivateName(node) {
	  this.token("#");
	  this.print(node.id, node);
	}

/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.AnyTypeAnnotation = AnyTypeAnnotation;
	exports.ArrayTypeAnnotation = ArrayTypeAnnotation;
	exports.BooleanTypeAnnotation = BooleanTypeAnnotation;
	exports.BooleanLiteralTypeAnnotation = BooleanLiteralTypeAnnotation;
	exports.NullLiteralTypeAnnotation = NullLiteralTypeAnnotation;
	exports.DeclareClass = DeclareClass;
	exports.DeclareFunction = DeclareFunction;
	exports.InferredPredicate = InferredPredicate;
	exports.DeclaredPredicate = DeclaredPredicate;
	exports.DeclareInterface = DeclareInterface;
	exports.DeclareModule = DeclareModule;
	exports.DeclareModuleExports = DeclareModuleExports;
	exports.DeclareTypeAlias = DeclareTypeAlias;
	exports.DeclareOpaqueType = DeclareOpaqueType;
	exports.DeclareVariable = DeclareVariable;
	exports.DeclareExportDeclaration = DeclareExportDeclaration;
	exports.DeclareExportAllDeclaration = DeclareExportAllDeclaration;
	exports.ExistsTypeAnnotation = ExistsTypeAnnotation;
	exports.FunctionTypeAnnotation = FunctionTypeAnnotation;
	exports.FunctionTypeParam = FunctionTypeParam;
	exports.GenericTypeAnnotation = exports.ClassImplements = exports.InterfaceExtends = InterfaceExtends;
	exports._interfaceish = _interfaceish;
	exports._variance = _variance;
	exports.InterfaceDeclaration = InterfaceDeclaration;
	exports.InterfaceTypeAnnotation = InterfaceTypeAnnotation;
	exports.IntersectionTypeAnnotation = IntersectionTypeAnnotation;
	exports.MixedTypeAnnotation = MixedTypeAnnotation;
	exports.EmptyTypeAnnotation = EmptyTypeAnnotation;
	exports.NullableTypeAnnotation = NullableTypeAnnotation;
	exports.NumberTypeAnnotation = NumberTypeAnnotation;
	exports.StringTypeAnnotation = StringTypeAnnotation;
	exports.ThisTypeAnnotation = ThisTypeAnnotation;
	exports.TupleTypeAnnotation = TupleTypeAnnotation;
	exports.TypeofTypeAnnotation = TypeofTypeAnnotation;
	exports.TypeAlias = TypeAlias;
	exports.TypeAnnotation = TypeAnnotation;
	exports.TypeParameterDeclaration = exports.TypeParameterInstantiation = TypeParameterInstantiation;
	exports.TypeParameter = TypeParameter;
	exports.OpaqueType = OpaqueType;
	exports.ObjectTypeAnnotation = ObjectTypeAnnotation;
	exports.ObjectTypeInternalSlot = ObjectTypeInternalSlot;
	exports.ObjectTypeCallProperty = ObjectTypeCallProperty;
	exports.ObjectTypeIndexer = ObjectTypeIndexer;
	exports.ObjectTypeProperty = ObjectTypeProperty;
	exports.ObjectTypeSpreadProperty = ObjectTypeSpreadProperty;
	exports.QualifiedTypeIdentifier = QualifiedTypeIdentifier;
	exports.UnionTypeAnnotation = UnionTypeAnnotation;
	exports.TypeCastExpression = TypeCastExpression;
	exports.Variance = Variance;
	exports.VoidTypeAnnotation = VoidTypeAnnotation;
	Object.defineProperty(exports, "NumberLiteralTypeAnnotation", {
	  enumerable: true,
	  get: function () {
	    return _types2.NumericLiteral;
	  }
	});
	Object.defineProperty(exports, "StringLiteralTypeAnnotation", {
	  enumerable: true,
	  get: function () {
	    return _types2.StringLiteral;
	  }
	});

	function t() {
	  const data = _interopRequireWildcard(__webpack_require__(2));

	  t = function () {
	    return data;
	  };

	  return data;
	}

	var _modules = __webpack_require__(42);

	var _types2 = __webpack_require__(26);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

	function AnyTypeAnnotation() {
	  this.word("any");
	}

	function ArrayTypeAnnotation(node) {
	  this.print(node.elementType, node);
	  this.token("[");
	  this.token("]");
	}

	function BooleanTypeAnnotation() {
	  this.word("boolean");
	}

	function BooleanLiteralTypeAnnotation(node) {
	  this.word(node.value ? "true" : "false");
	}

	function NullLiteralTypeAnnotation() {
	  this.word("null");
	}

	function DeclareClass(node, parent) {
	  if (!t().isDeclareExportDeclaration(parent)) {
	    this.word("declare");
	    this.space();
	  }

	  this.word("class");
	  this.space();

	  this._interfaceish(node);
	}

	function DeclareFunction(node, parent) {
	  if (!t().isDeclareExportDeclaration(parent)) {
	    this.word("declare");
	    this.space();
	  }

	  this.word("function");
	  this.space();
	  this.print(node.id, node);
	  this.print(node.id.typeAnnotation.typeAnnotation, node);

	  if (node.predicate) {
	    this.space();
	    this.print(node.predicate, node);
	  }

	  this.semicolon();
	}

	function InferredPredicate() {
	  this.token("%");
	  this.word("checks");
	}

	function DeclaredPredicate(node) {
	  this.token("%");
	  this.word("checks");
	  this.token("(");
	  this.print(node.value, node);
	  this.token(")");
	}

	function DeclareInterface(node) {
	  this.word("declare");
	  this.space();
	  this.InterfaceDeclaration(node);
	}

	function DeclareModule(node) {
	  this.word("declare");
	  this.space();
	  this.word("module");
	  this.space();
	  this.print(node.id, node);
	  this.space();
	  this.print(node.body, node);
	}

	function DeclareModuleExports(node) {
	  this.word("declare");
	  this.space();
	  this.word("module");
	  this.token(".");
	  this.word("exports");
	  this.print(node.typeAnnotation, node);
	}

	function DeclareTypeAlias(node) {
	  this.word("declare");
	  this.space();
	  this.TypeAlias(node);
	}

	function DeclareOpaqueType(node, parent) {
	  if (!t().isDeclareExportDeclaration(parent)) {
	    this.word("declare");
	    this.space();
	  }

	  this.OpaqueType(node);
	}

	function DeclareVariable(node, parent) {
	  if (!t().isDeclareExportDeclaration(parent)) {
	    this.word("declare");
	    this.space();
	  }

	  this.word("var");
	  this.space();
	  this.print(node.id, node);
	  this.print(node.id.typeAnnotation, node);
	  this.semicolon();
	}

	function DeclareExportDeclaration(node) {
	  this.word("declare");
	  this.space();
	  this.word("export");
	  this.space();

	  if (node.default) {
	    this.word("default");
	    this.space();
	  }

	  FlowExportDeclaration.apply(this, arguments);
	}

	function DeclareExportAllDeclaration() {
	  this.word("declare");
	  this.space();

	  _modules.ExportAllDeclaration.apply(this, arguments);
	}

	function FlowExportDeclaration(node) {
	  if (node.declaration) {
	    const declar = node.declaration;
	    this.print(declar, node);
	    if (!t().isStatement(declar)) this.semicolon();
	  } else {
	    this.token("{");

	    if (node.specifiers.length) {
	      this.space();
	      this.printList(node.specifiers, node);
	      this.space();
	    }

	    this.token("}");

	    if (node.source) {
	      this.space();
	      this.word("from");
	      this.space();
	      this.print(node.source, node);
	    }

	    this.semicolon();
	  }
	}

	function ExistsTypeAnnotation() {
	  this.token("*");
	}

	function FunctionTypeAnnotation(node, parent) {
	  this.print(node.typeParameters, node);
	  this.token("(");
	  this.printList(node.params, node);

	  if (node.rest) {
	    if (node.params.length) {
	      this.token(",");
	      this.space();
	    }

	    this.token("...");
	    this.print(node.rest, node);
	  }

	  this.token(")");

	  if (parent.type === "ObjectTypeCallProperty" || parent.type === "DeclareFunction" || parent.type === "ObjectTypeProperty" && parent.method) {
	    this.token(":");
	  } else {
	    this.space();
	    this.token("=>");
	  }

	  this.space();
	  this.print(node.returnType, node);
	}

	function FunctionTypeParam(node) {
	  this.print(node.name, node);
	  if (node.optional) this.token("?");

	  if (node.name) {
	    this.token(":");
	    this.space();
	  }

	  this.print(node.typeAnnotation, node);
	}

	function InterfaceExtends(node) {
	  this.print(node.id, node);
	  this.print(node.typeParameters, node);
	}

	function _interfaceish(node) {
	  this.print(node.id, node);
	  this.print(node.typeParameters, node);

	  if (node.extends.length) {
	    this.space();
	    this.word("extends");
	    this.space();
	    this.printList(node.extends, node);
	  }

	  if (node.mixins && node.mixins.length) {
	    this.space();
	    this.word("mixins");
	    this.space();
	    this.printList(node.mixins, node);
	  }

	  if (node.implements && node.implements.length) {
	    this.space();
	    this.word("implements");
	    this.space();
	    this.printList(node.implements, node);
	  }

	  this.space();
	  this.print(node.body, node);
	}

	function _variance(node) {
	  if (node.variance) {
	    if (node.variance.kind === "plus") {
	      this.token("+");
	    } else if (node.variance.kind === "minus") {
	      this.token("-");
	    }
	  }
	}

	function InterfaceDeclaration(node) {
	  this.word("interface");
	  this.space();

	  this._interfaceish(node);
	}

	function andSeparator() {
	  this.space();
	  this.token("&");
	  this.space();
	}

	function InterfaceTypeAnnotation(node) {
	  this.word("interface");

	  if (node.extends && node.extends.length) {
	    this.space();
	    this.word("extends");
	    this.space();
	    this.printList(node.extends, node);
	  }

	  this.space();
	  this.print(node.body, node);
	}

	function IntersectionTypeAnnotation(node) {
	  this.printJoin(node.types, node, {
	    separator: andSeparator
	  });
	}

	function MixedTypeAnnotation() {
	  this.word("mixed");
	}

	function EmptyTypeAnnotation() {
	  this.word("empty");
	}

	function NullableTypeAnnotation(node) {
	  this.token("?");
	  this.print(node.typeAnnotation, node);
	}

	function NumberTypeAnnotation() {
	  this.word("number");
	}

	function StringTypeAnnotation() {
	  this.word("string");
	}

	function ThisTypeAnnotation() {
	  this.word("this");
	}

	function TupleTypeAnnotation(node) {
	  this.token("[");
	  this.printList(node.types, node);
	  this.token("]");
	}

	function TypeofTypeAnnotation(node) {
	  this.word("typeof");
	  this.space();
	  this.print(node.argument, node);
	}

	function TypeAlias(node) {
	  this.word("type");
	  this.space();
	  this.print(node.id, node);
	  this.print(node.typeParameters, node);
	  this.space();
	  this.token("=");
	  this.space();
	  this.print(node.right, node);
	  this.semicolon();
	}

	function TypeAnnotation(node) {
	  this.token(":");
	  this.space();
	  if (node.optional) this.token("?");
	  this.print(node.typeAnnotation, node);
	}

	function TypeParameterInstantiation(node) {
	  this.token("<");
	  this.printList(node.params, node, {});
	  this.token(">");
	}

	function TypeParameter(node) {
	  this._variance(node);

	  this.word(node.name);

	  if (node.bound) {
	    this.print(node.bound, node);
	  }

	  if (node.default) {
	    this.space();
	    this.token("=");
	    this.space();
	    this.print(node.default, node);
	  }
	}

	function OpaqueType(node) {
	  this.word("opaque");
	  this.space();
	  this.word("type");
	  this.space();
	  this.print(node.id, node);
	  this.print(node.typeParameters, node);

	  if (node.supertype) {
	    this.token(":");
	    this.space();
	    this.print(node.supertype, node);
	  }

	  if (node.impltype) {
	    this.space();
	    this.token("=");
	    this.space();
	    this.print(node.impltype, node);
	  }

	  this.semicolon();
	}

	function ObjectTypeAnnotation(node) {
	  if (node.exact) {
	    this.token("{|");
	  } else {
	    this.token("{");
	  }

	  const props = node.properties.concat(node.callProperties || [], node.indexers || [], node.internalSlots || []);

	  if (props.length) {
	    this.space();
	    this.printJoin(props, node, {
	      addNewlines(leading) {
	        if (leading && !props[0]) return 1;
	      },

	      indent: true,
	      statement: true,
	      iterator: () => {
	        if (props.length !== 1) {
	          this.token(",");
	          this.space();
	        }
	      }
	    });
	    this.space();
	  }

	  if (node.exact) {
	    this.token("|}");
	  } else {
	    this.token("}");
	  }
	}

	function ObjectTypeInternalSlot(node) {
	  if (node.static) {
	    this.word("static");
	    this.space();
	  }

	  this.token("[");
	  this.token("[");
	  this.print(node.id, node);
	  this.token("]");
	  this.token("]");
	  if (node.optional) this.token("?");

	  if (!node.method) {
	    this.token(":");
	    this.space();
	  }

	  this.print(node.value, node);
	}

	function ObjectTypeCallProperty(node) {
	  if (node.static) {
	    this.word("static");
	    this.space();
	  }

	  this.print(node.value, node);
	}

	function ObjectTypeIndexer(node) {
	  if (node.static) {
	    this.word("static");
	    this.space();
	  }

	  this._variance(node);

	  this.token("[");

	  if (node.id) {
	    this.print(node.id, node);
	    this.token(":");
	    this.space();
	  }

	  this.print(node.key, node);
	  this.token("]");
	  this.token(":");
	  this.space();
	  this.print(node.value, node);
	}

	function ObjectTypeProperty(node) {
	  if (node.proto) {
	    this.word("proto");
	    this.space();
	  }

	  if (node.static) {
	    this.word("static");
	    this.space();
	  }

	  this._variance(node);

	  this.print(node.key, node);
	  if (node.optional) this.token("?");

	  if (!node.method) {
	    this.token(":");
	    this.space();
	  }

	  this.print(node.value, node);
	}

	function ObjectTypeSpreadProperty(node) {
	  this.token("...");
	  this.print(node.argument, node);
	}

	function QualifiedTypeIdentifier(node) {
	  this.print(node.qualification, node);
	  this.token(".");
	  this.print(node.id, node);
	}

	function orSeparator() {
	  this.space();
	  this.token("|");
	  this.space();
	}

	function UnionTypeAnnotation(node) {
	  this.printJoin(node.types, node, {
	    separator: orSeparator
	  });
	}

	function TypeCastExpression(node) {
	  this.token("(");
	  this.print(node.expression, node);
	  this.print(node.typeAnnotation, node);
	  this.token(")");
	}

	function Variance(node) {
	  if (node.kind === "plus") {
	    this.token("+");
	  } else {
	    this.token("-");
	  }
	}

	function VoidTypeAnnotation() {
	  this.word("void");
	}

/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _templateLiterals = __webpack_require__(93);

	Object.keys(_templateLiterals).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function () {
	      return _templateLiterals[key];
	    }
	  });
	});

	var _expressions = __webpack_require__(87);

	Object.keys(_expressions).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function () {
	      return _expressions[key];
	    }
	  });
	});

	var _statements = __webpack_require__(92);

	Object.keys(_statements).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function () {
	      return _statements[key];
	    }
	  });
	});

	var _classes = __webpack_require__(86);

	Object.keys(_classes).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function () {
	      return _classes[key];
	    }
	  });
	});

	var _methods = __webpack_require__(91);

	Object.keys(_methods).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function () {
	      return _methods[key];
	    }
	  });
	});

	var _modules = __webpack_require__(42);

	Object.keys(_modules).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function () {
	      return _modules[key];
	    }
	  });
	});

	var _types = __webpack_require__(26);

	Object.keys(_types).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function () {
	      return _types[key];
	    }
	  });
	});

	var _flow = __webpack_require__(88);

	Object.keys(_flow).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function () {
	      return _flow[key];
	    }
	  });
	});

	var _base = __webpack_require__(85);

	Object.keys(_base).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function () {
	      return _base[key];
	    }
	  });
	});

	var _jsx = __webpack_require__(90);

	Object.keys(_jsx).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function () {
	      return _jsx[key];
	    }
	  });
	});

	var _typescript = __webpack_require__(94);

	Object.keys(_typescript).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function () {
	      return _typescript[key];
	    }
	  });
	});

/***/ }),
/* 90 */
/***/ (function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.JSXAttribute = JSXAttribute;
	exports.JSXIdentifier = JSXIdentifier;
	exports.JSXNamespacedName = JSXNamespacedName;
	exports.JSXMemberExpression = JSXMemberExpression;
	exports.JSXSpreadAttribute = JSXSpreadAttribute;
	exports.JSXExpressionContainer = JSXExpressionContainer;
	exports.JSXSpreadChild = JSXSpreadChild;
	exports.JSXText = JSXText;
	exports.JSXElement = JSXElement;
	exports.JSXOpeningElement = JSXOpeningElement;
	exports.JSXClosingElement = JSXClosingElement;
	exports.JSXEmptyExpression = JSXEmptyExpression;
	exports.JSXFragment = JSXFragment;
	exports.JSXOpeningFragment = JSXOpeningFragment;
	exports.JSXClosingFragment = JSXClosingFragment;

	function JSXAttribute(node) {
	  this.print(node.name, node);

	  if (node.value) {
	    this.token("=");
	    this.print(node.value, node);
	  }
	}

	function JSXIdentifier(node) {
	  this.word(node.name);
	}

	function JSXNamespacedName(node) {
	  this.print(node.namespace, node);
	  this.token(":");
	  this.print(node.name, node);
	}

	function JSXMemberExpression(node) {
	  this.print(node.object, node);
	  this.token(".");
	  this.print(node.property, node);
	}

	function JSXSpreadAttribute(node) {
	  this.token("{");
	  this.token("...");
	  this.print(node.argument, node);
	  this.token("}");
	}

	function JSXExpressionContainer(node) {
	  this.token("{");
	  this.print(node.expression, node);
	  this.token("}");
	}

	function JSXSpreadChild(node) {
	  this.token("{");
	  this.token("...");
	  this.print(node.expression, node);
	  this.token("}");
	}

	function JSXText(node) {
	  const raw = this.getPossibleRaw(node);

	  if (raw != null) {
	    this.token(raw);
	  } else {
	    this.token(node.value);
	  }
	}

	function JSXElement(node) {
	  const open = node.openingElement;
	  this.print(open, node);
	  if (open.selfClosing) return;
	  this.indent();

	  for (const child of node.children) {
	    this.print(child, node);
	  }

	  this.dedent();
	  this.print(node.closingElement, node);
	}

	function spaceSeparator() {
	  this.space();
	}

	function JSXOpeningElement(node) {
	  this.token("<");
	  this.print(node.name, node);
	  this.print(node.typeParameters, node);

	  if (node.attributes.length > 0) {
	    this.space();
	    this.printJoin(node.attributes, node, {
	      separator: spaceSeparator
	    });
	  }

	  if (node.selfClosing) {
	    this.space();
	    this.token("/>");
	  } else {
	    this.token(">");
	  }
	}

	function JSXClosingElement(node) {
	  this.token("</");
	  this.print(node.name, node);
	  this.token(">");
	}

	function JSXEmptyExpression(node) {
	  this.printInnerComments(node);
	}

	function JSXFragment(node) {
	  this.print(node.openingFragment, node);
	  this.indent();

	  for (const child of node.children) {
	    this.print(child, node);
	  }

	  this.dedent();
	  this.print(node.closingFragment, node);
	}

	function JSXOpeningFragment() {
	  this.token("<");
	  this.token(">");
	}

	function JSXClosingFragment() {
	  this.token("</");
	  this.token(">");
	}

/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports._params = _params;
	exports._parameters = _parameters;
	exports._param = _param;
	exports._methodHead = _methodHead;
	exports._predicate = _predicate;
	exports._functionHead = _functionHead;
	exports.FunctionDeclaration = exports.FunctionExpression = FunctionExpression;
	exports.ArrowFunctionExpression = ArrowFunctionExpression;

	function t() {
	  const data = _interopRequireWildcard(__webpack_require__(2));

	  t = function () {
	    return data;
	  };

	  return data;
	}

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

	function _params(node) {
	  this.print(node.typeParameters, node);
	  this.token("(");

	  this._parameters(node.params, node);

	  this.token(")");
	  this.print(node.returnType, node);
	}

	function _parameters(parameters, parent) {
	  for (let i = 0; i < parameters.length; i++) {
	    this._param(parameters[i], parent);

	    if (i < parameters.length - 1) {
	      this.token(",");
	      this.space();
	    }
	  }
	}

	function _param(parameter, parent) {
	  this.printJoin(parameter.decorators, parameter);
	  this.print(parameter, parent);
	  if (parameter.optional) this.token("?");
	  this.print(parameter.typeAnnotation, parameter);
	}

	function _methodHead(node) {
	  const kind = node.kind;
	  const key = node.key;

	  if (kind === "get" || kind === "set") {
	    this.word(kind);
	    this.space();
	  }

	  if (node.async) {
	    this.word("async");
	    this.space();
	  }

	  if (kind === "method" || kind === "init") {
	    if (node.generator) {
	      this.token("*");
	    }
	  }

	  if (node.computed) {
	    this.token("[");
	    this.print(key, node);
	    this.token("]");
	  } else {
	    this.print(key, node);
	  }

	  if (node.optional) {
	    this.token("?");
	  }

	  this._params(node);
	}

	function _predicate(node) {
	  if (node.predicate) {
	    if (!node.returnType) {
	      this.token(":");
	    }

	    this.space();
	    this.print(node.predicate, node);
	  }
	}

	function _functionHead(node) {
	  if (node.async) {
	    this.word("async");
	    this.space();
	  }

	  this.word("function");
	  if (node.generator) this.token("*");
	  this.space();

	  if (node.id) {
	    this.print(node.id, node);
	  }

	  this._params(node);

	  this._predicate(node);
	}

	function FunctionExpression(node) {
	  this._functionHead(node);

	  this.space();
	  this.print(node.body, node);
	}

	function ArrowFunctionExpression(node) {
	  if (node.async) {
	    this.word("async");
	    this.space();
	  }

	  const firstParam = node.params[0];

	  if (node.params.length === 1 && t().isIdentifier(firstParam) && !hasTypes(node, firstParam)) {
	    this.print(firstParam, node);
	  } else {
	    this._params(node);
	  }

	  this._predicate(node);

	  this.space();
	  this.token("=>");
	  this.space();
	  this.print(node.body, node);
	}

	function hasTypes(node, param) {
	  return node.typeParameters || node.returnType || param.typeAnnotation || param.optional || param.trailingComments;
	}

/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.WithStatement = WithStatement;
	exports.IfStatement = IfStatement;
	exports.ForStatement = ForStatement;
	exports.WhileStatement = WhileStatement;
	exports.DoWhileStatement = DoWhileStatement;
	exports.LabeledStatement = LabeledStatement;
	exports.TryStatement = TryStatement;
	exports.CatchClause = CatchClause;
	exports.SwitchStatement = SwitchStatement;
	exports.SwitchCase = SwitchCase;
	exports.DebuggerStatement = DebuggerStatement;
	exports.VariableDeclaration = VariableDeclaration;
	exports.VariableDeclarator = VariableDeclarator;
	exports.ThrowStatement = exports.BreakStatement = exports.ReturnStatement = exports.ContinueStatement = exports.ForOfStatement = exports.ForInStatement = void 0;

	function t() {
	  const data = _interopRequireWildcard(__webpack_require__(2));

	  t = function () {
	    return data;
	  };

	  return data;
	}

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

	function WithStatement(node) {
	  this.word("with");
	  this.space();
	  this.token("(");
	  this.print(node.object, node);
	  this.token(")");
	  this.printBlock(node);
	}

	function IfStatement(node) {
	  this.word("if");
	  this.space();
	  this.token("(");
	  this.print(node.test, node);
	  this.token(")");
	  this.space();
	  const needsBlock = node.alternate && t().isIfStatement(getLastStatement(node.consequent));

	  if (needsBlock) {
	    this.token("{");
	    this.newline();
	    this.indent();
	  }

	  this.printAndIndentOnComments(node.consequent, node);

	  if (needsBlock) {
	    this.dedent();
	    this.newline();
	    this.token("}");
	  }

	  if (node.alternate) {
	    if (this.endsWith("}")) this.space();
	    this.word("else");
	    this.space();
	    this.printAndIndentOnComments(node.alternate, node);
	  }
	}

	function getLastStatement(statement) {
	  if (!t().isStatement(statement.body)) return statement;
	  return getLastStatement(statement.body);
	}

	function ForStatement(node) {
	  this.word("for");
	  this.space();
	  this.token("(");
	  this.inForStatementInitCounter++;
	  this.print(node.init, node);
	  this.inForStatementInitCounter--;
	  this.token(";");

	  if (node.test) {
	    this.space();
	    this.print(node.test, node);
	  }

	  this.token(";");

	  if (node.update) {
	    this.space();
	    this.print(node.update, node);
	  }

	  this.token(")");
	  this.printBlock(node);
	}

	function WhileStatement(node) {
	  this.word("while");
	  this.space();
	  this.token("(");
	  this.print(node.test, node);
	  this.token(")");
	  this.printBlock(node);
	}

	const buildForXStatement = function (op) {
	  return function (node) {
	    this.word("for");
	    this.space();

	    if (op === "of" && node.await) {
	      this.word("await");
	      this.space();
	    }

	    this.token("(");
	    this.print(node.left, node);
	    this.space();
	    this.word(op);
	    this.space();
	    this.print(node.right, node);
	    this.token(")");
	    this.printBlock(node);
	  };
	};

	const ForInStatement = buildForXStatement("in");
	exports.ForInStatement = ForInStatement;
	const ForOfStatement = buildForXStatement("of");
	exports.ForOfStatement = ForOfStatement;

	function DoWhileStatement(node) {
	  this.word("do");
	  this.space();
	  this.print(node.body, node);
	  this.space();
	  this.word("while");
	  this.space();
	  this.token("(");
	  this.print(node.test, node);
	  this.token(")");
	  this.semicolon();
	}

	function buildLabelStatement(prefix, key = "label") {
	  return function (node) {
	    this.word(prefix);
	    const label = node[key];

	    if (label) {
	      this.space();
	      const isLabel = key == "label";
	      const terminatorState = this.startTerminatorless(isLabel);
	      this.print(label, node);
	      this.endTerminatorless(terminatorState);
	    }

	    this.semicolon();
	  };
	}

	const ContinueStatement = buildLabelStatement("continue");
	exports.ContinueStatement = ContinueStatement;
	const ReturnStatement = buildLabelStatement("return", "argument");
	exports.ReturnStatement = ReturnStatement;
	const BreakStatement = buildLabelStatement("break");
	exports.BreakStatement = BreakStatement;
	const ThrowStatement = buildLabelStatement("throw", "argument");
	exports.ThrowStatement = ThrowStatement;

	function LabeledStatement(node) {
	  this.print(node.label, node);
	  this.token(":");
	  this.space();
	  this.print(node.body, node);
	}

	function TryStatement(node) {
	  this.word("try");
	  this.space();
	  this.print(node.block, node);
	  this.space();

	  if (node.handlers) {
	    this.print(node.handlers[0], node);
	  } else {
	    this.print(node.handler, node);
	  }

	  if (node.finalizer) {
	    this.space();
	    this.word("finally");
	    this.space();
	    this.print(node.finalizer, node);
	  }
	}

	function CatchClause(node) {
	  this.word("catch");
	  this.space();

	  if (node.param) {
	    this.token("(");
	    this.print(node.param, node);
	    this.token(")");
	    this.space();
	  }

	  this.print(node.body, node);
	}

	function SwitchStatement(node) {
	  this.word("switch");
	  this.space();
	  this.token("(");
	  this.print(node.discriminant, node);
	  this.token(")");
	  this.space();
	  this.token("{");
	  this.printSequence(node.cases, node, {
	    indent: true,

	    addNewlines(leading, cas) {
	      if (!leading && node.cases[node.cases.length - 1] === cas) return -1;
	    }

	  });
	  this.token("}");
	}

	function SwitchCase(node) {
	  if (node.test) {
	    this.word("case");
	    this.space();
	    this.print(node.test, node);
	    this.token(":");
	  } else {
	    this.word("default");
	    this.token(":");
	  }

	  if (node.consequent.length) {
	    this.newline();
	    this.printSequence(node.consequent, node, {
	      indent: true
	    });
	  }
	}

	function DebuggerStatement() {
	  this.word("debugger");
	  this.semicolon();
	}

	function variableDeclarationIndent() {
	  this.token(",");
	  this.newline();
	  if (this.endsWith("\n")) for (let i = 0; i < 4; i++) this.space(true);
	}

	function constDeclarationIndent() {
	  this.token(",");
	  this.newline();
	  if (this.endsWith("\n")) for (let i = 0; i < 6; i++) this.space(true);
	}

	function VariableDeclaration(node, parent) {
	  if (node.declare) {
	    this.word("declare");
	    this.space();
	  }

	  this.word(node.kind);
	  this.space();
	  let hasInits = false;

	  if (!t().isFor(parent)) {
	    for (const declar of node.declarations) {
	      if (declar.init) {
	        hasInits = true;
	      }
	    }
	  }

	  let separator;

	  if (hasInits) {
	    separator = node.kind === "const" ? constDeclarationIndent : variableDeclarationIndent;
	  }

	  this.printList(node.declarations, node, {
	    separator
	  });

	  if (t().isFor(parent)) {
	    if (parent.left === node || parent.init === node) return;
	  }

	  this.semicolon();
	}

	function VariableDeclarator(node) {
	  this.print(node.id, node);
	  if (node.definite) this.token("!");
	  this.print(node.id.typeAnnotation, node);

	  if (node.init) {
	    this.space();
	    this.token("=");
	    this.space();
	    this.print(node.init, node);
	  }
	}

/***/ }),
/* 93 */
/***/ (function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.TaggedTemplateExpression = TaggedTemplateExpression;
	exports.TemplateElement = TemplateElement;
	exports.TemplateLiteral = TemplateLiteral;

	function TaggedTemplateExpression(node) {
	  this.print(node.tag, node);
	  this.print(node.typeParameters, node);
	  this.print(node.quasi, node);
	}

	function TemplateElement(node, parent) {
	  const isFirst = parent.quasis[0] === node;
	  const isLast = parent.quasis[parent.quasis.length - 1] === node;
	  const value = (isFirst ? "`" : "}") + node.value.raw + (isLast ? "`" : "${");
	  this.token(value);
	}

	function TemplateLiteral(node) {
	  const quasis = node.quasis;

	  for (let i = 0; i < quasis.length; i++) {
	    this.print(quasis[i], node);

	    if (i + 1 < quasis.length) {
	      this.print(node.expressions[i], node);
	    }
	  }
	}

/***/ }),
/* 94 */
/***/ (function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.TSTypeAnnotation = TSTypeAnnotation;
	exports.TSTypeParameterDeclaration = exports.TSTypeParameterInstantiation = TSTypeParameterInstantiation;
	exports.TSTypeParameter = TSTypeParameter;
	exports.TSParameterProperty = TSParameterProperty;
	exports.TSDeclareFunction = TSDeclareFunction;
	exports.TSDeclareMethod = TSDeclareMethod;
	exports.TSQualifiedName = TSQualifiedName;
	exports.TSCallSignatureDeclaration = TSCallSignatureDeclaration;
	exports.TSConstructSignatureDeclaration = TSConstructSignatureDeclaration;
	exports.TSPropertySignature = TSPropertySignature;
	exports.tsPrintPropertyOrMethodName = tsPrintPropertyOrMethodName;
	exports.TSMethodSignature = TSMethodSignature;
	exports.TSIndexSignature = TSIndexSignature;
	exports.TSAnyKeyword = TSAnyKeyword;
	exports.TSNumberKeyword = TSNumberKeyword;
	exports.TSObjectKeyword = TSObjectKeyword;
	exports.TSBooleanKeyword = TSBooleanKeyword;
	exports.TSStringKeyword = TSStringKeyword;
	exports.TSSymbolKeyword = TSSymbolKeyword;
	exports.TSVoidKeyword = TSVoidKeyword;
	exports.TSUndefinedKeyword = TSUndefinedKeyword;
	exports.TSNullKeyword = TSNullKeyword;
	exports.TSNeverKeyword = TSNeverKeyword;
	exports.TSThisType = TSThisType;
	exports.TSFunctionType = TSFunctionType;
	exports.TSConstructorType = TSConstructorType;
	exports.tsPrintFunctionOrConstructorType = tsPrintFunctionOrConstructorType;
	exports.TSTypeReference = TSTypeReference;
	exports.TSTypePredicate = TSTypePredicate;
	exports.TSTypeQuery = TSTypeQuery;
	exports.TSTypeLiteral = TSTypeLiteral;
	exports.tsPrintTypeLiteralOrInterfaceBody = tsPrintTypeLiteralOrInterfaceBody;
	exports.tsPrintBraced = tsPrintBraced;
	exports.TSArrayType = TSArrayType;
	exports.TSTupleType = TSTupleType;
	exports.TSUnionType = TSUnionType;
	exports.TSIntersectionType = TSIntersectionType;
	exports.tsPrintUnionOrIntersectionType = tsPrintUnionOrIntersectionType;
	exports.TSConditionalType = TSConditionalType;
	exports.TSInferType = TSInferType;
	exports.TSParenthesizedType = TSParenthesizedType;
	exports.TSTypeOperator = TSTypeOperator;
	exports.TSIndexedAccessType = TSIndexedAccessType;
	exports.TSMappedType = TSMappedType;
	exports.TSLiteralType = TSLiteralType;
	exports.TSExpressionWithTypeArguments = TSExpressionWithTypeArguments;
	exports.TSInterfaceDeclaration = TSInterfaceDeclaration;
	exports.TSInterfaceBody = TSInterfaceBody;
	exports.TSTypeAliasDeclaration = TSTypeAliasDeclaration;
	exports.TSAsExpression = TSAsExpression;
	exports.TSTypeAssertion = TSTypeAssertion;
	exports.TSEnumDeclaration = TSEnumDeclaration;
	exports.TSEnumMember = TSEnumMember;
	exports.TSModuleDeclaration = TSModuleDeclaration;
	exports.TSModuleBlock = TSModuleBlock;
	exports.TSImportEqualsDeclaration = TSImportEqualsDeclaration;
	exports.TSExternalModuleReference = TSExternalModuleReference;
	exports.TSNonNullExpression = TSNonNullExpression;
	exports.TSExportAssignment = TSExportAssignment;
	exports.TSNamespaceExportDeclaration = TSNamespaceExportDeclaration;
	exports.tsPrintSignatureDeclarationBase = tsPrintSignatureDeclarationBase;

	function TSTypeAnnotation(node) {
	  this.token(":");
	  this.space();
	  if (node.optional) this.token("?");
	  this.print(node.typeAnnotation, node);
	}

	function TSTypeParameterInstantiation(node) {
	  this.token("<");
	  this.printList(node.params, node, {});
	  this.token(">");
	}

	function TSTypeParameter(node) {
	  this.word(node.name);

	  if (node.constraint) {
	    this.space();
	    this.word("extends");
	    this.space();
	    this.print(node.constraint, node);
	  }

	  if (node.default) {
	    this.space();
	    this.token("=");
	    this.space();
	    this.print(node.default, node);
	  }
	}

	function TSParameterProperty(node) {
	  if (node.accessibility) {
	    this.word(node.accessibility);
	    this.space();
	  }

	  if (node.readonly) {
	    this.word("readonly");
	    this.space();
	  }

	  this._param(node.parameter);
	}

	function TSDeclareFunction(node) {
	  if (node.declare) {
	    this.word("declare");
	    this.space();
	  }

	  this._functionHead(node);

	  this.token(";");
	}

	function TSDeclareMethod(node) {
	  this._classMethodHead(node);

	  this.token(";");
	}

	function TSQualifiedName(node) {
	  this.print(node.left, node);
	  this.token(".");
	  this.print(node.right, node);
	}

	function TSCallSignatureDeclaration(node) {
	  this.tsPrintSignatureDeclarationBase(node);
	}

	function TSConstructSignatureDeclaration(node) {
	  this.word("new");
	  this.space();
	  this.tsPrintSignatureDeclarationBase(node);
	}

	function TSPropertySignature(node) {
	  const {
	    readonly,
	    initializer
	  } = node;

	  if (readonly) {
	    this.word("readonly");
	    this.space();
	  }

	  this.tsPrintPropertyOrMethodName(node);
	  this.print(node.typeAnnotation, node);

	  if (initializer) {
	    this.space();
	    this.token("=");
	    this.space();
	    this.print(initializer, node);
	  }

	  this.token(";");
	}

	function tsPrintPropertyOrMethodName(node) {
	  if (node.computed) {
	    this.token("[");
	  }

	  this.print(node.key, node);

	  if (node.computed) {
	    this.token("]");
	  }

	  if (node.optional) {
	    this.token("?");
	  }
	}

	function TSMethodSignature(node) {
	  this.tsPrintPropertyOrMethodName(node);
	  this.tsPrintSignatureDeclarationBase(node);
	  this.token(";");
	}

	function TSIndexSignature(node) {
	  const {
	    readonly
	  } = node;

	  if (readonly) {
	    this.word("readonly");
	    this.space();
	  }

	  this.token("[");

	  this._parameters(node.parameters, node);

	  this.token("]");
	  this.print(node.typeAnnotation, node);
	  this.token(";");
	}

	function TSAnyKeyword() {
	  this.word("any");
	}

	function TSNumberKeyword() {
	  this.word("number");
	}

	function TSObjectKeyword() {
	  this.word("object");
	}

	function TSBooleanKeyword() {
	  this.word("boolean");
	}

	function TSStringKeyword() {
	  this.word("string");
	}

	function TSSymbolKeyword() {
	  this.word("symbol");
	}

	function TSVoidKeyword() {
	  this.word("void");
	}

	function TSUndefinedKeyword() {
	  this.word("undefined");
	}

	function TSNullKeyword() {
	  this.word("null");
	}

	function TSNeverKeyword() {
	  this.word("never");
	}

	function TSThisType() {
	  this.word("this");
	}

	function TSFunctionType(node) {
	  this.tsPrintFunctionOrConstructorType(node);
	}

	function TSConstructorType(node) {
	  this.word("new");
	  this.space();
	  this.tsPrintFunctionOrConstructorType(node);
	}

	function tsPrintFunctionOrConstructorType(node) {
	  const {
	    typeParameters,
	    parameters
	  } = node;
	  this.print(typeParameters, node);
	  this.token("(");

	  this._parameters(parameters, node);

	  this.token(")");
	  this.space();
	  this.token("=>");
	  this.space();
	  this.print(node.typeAnnotation.typeAnnotation, node);
	}

	function TSTypeReference(node) {
	  this.print(node.typeName, node);
	  this.print(node.typeParameters, node);
	}

	function TSTypePredicate(node) {
	  this.print(node.parameterName);
	  this.space();
	  this.word("is");
	  this.space();
	  this.print(node.typeAnnotation.typeAnnotation);
	}

	function TSTypeQuery(node) {
	  this.word("typeof");
	  this.space();
	  this.print(node.exprName);
	}

	function TSTypeLiteral(node) {
	  this.tsPrintTypeLiteralOrInterfaceBody(node.members, node);
	}

	function tsPrintTypeLiteralOrInterfaceBody(members, node) {
	  this.tsPrintBraced(members, node);
	}

	function tsPrintBraced(members, node) {
	  this.token("{");

	  if (members.length) {
	    this.indent();
	    this.newline();

	    for (const member of members) {
	      this.print(member, node);
	      this.newline();
	    }

	    this.dedent();
	    this.rightBrace();
	  } else {
	    this.token("}");
	  }
	}

	function TSArrayType(node) {
	  this.print(node.elementType);
	  this.token("[]");
	}

	function TSTupleType(node) {
	  this.token("[");
	  this.printList(node.elementTypes, node);
	  this.token("]");
	}

	function TSUnionType(node) {
	  this.tsPrintUnionOrIntersectionType(node, "|");
	}

	function TSIntersectionType(node) {
	  this.tsPrintUnionOrIntersectionType(node, "&");
	}

	function tsPrintUnionOrIntersectionType(node, sep) {
	  this.printJoin(node.types, node, {
	    separator() {
	      this.space();
	      this.token(sep);
	      this.space();
	    }

	  });
	}

	function TSConditionalType(node) {
	  this.print(node.checkType);
	  this.space();
	  this.word("extends");
	  this.space();
	  this.print(node.extendsType);
	  this.space();
	  this.token("?");
	  this.space();
	  this.print(node.trueType);
	  this.space();
	  this.token(":");
	  this.space();
	  this.print(node.falseType);
	}

	function TSInferType(node) {
	  this.token("infer");
	  this.space();
	  this.print(node.typeParameter);
	}

	function TSParenthesizedType(node) {
	  this.token("(");
	  this.print(node.typeAnnotation, node);
	  this.token(")");
	}

	function TSTypeOperator(node) {
	  this.token(node.operator);
	  this.space();
	  this.print(node.typeAnnotation, node);
	}

	function TSIndexedAccessType(node) {
	  this.print(node.objectType, node);
	  this.token("[");
	  this.print(node.indexType, node);
	  this.token("]");
	}

	function TSMappedType(node) {
	  const {
	    readonly,
	    typeParameter,
	    optional
	  } = node;
	  this.token("{");
	  this.space();

	  if (readonly) {
	    tokenIfPlusMinus(this, readonly);
	    this.word("readonly");
	    this.space();
	  }

	  this.token("[");
	  this.word(typeParameter.name);
	  this.space();
	  this.word("in");
	  this.space();
	  this.print(typeParameter.constraint, typeParameter);
	  this.token("]");

	  if (optional) {
	    tokenIfPlusMinus(this, optional);
	    this.token("?");
	  }

	  this.token(":");
	  this.space();
	  this.print(node.typeAnnotation, node);
	  this.space();
	  this.token("}");
	}

	function tokenIfPlusMinus(self, tok) {
	  if (tok !== true) {
	    self.token(tok);
	  }
	}

	function TSLiteralType(node) {
	  this.print(node.literal, node);
	}

	function TSExpressionWithTypeArguments(node) {
	  this.print(node.expression, node);
	  this.print(node.typeParameters, node);
	}

	function TSInterfaceDeclaration(node) {
	  const {
	    declare,
	    id,
	    typeParameters,
	    extends: extendz,
	    body
	  } = node;

	  if (declare) {
	    this.word("declare");
	    this.space();
	  }

	  this.word("interface");
	  this.space();
	  this.print(id, node);
	  this.print(typeParameters, node);

	  if (extendz) {
	    this.space();
	    this.word("extends");
	    this.space();
	    this.printList(extendz, node);
	  }

	  this.space();
	  this.print(body, node);
	}

	function TSInterfaceBody(node) {
	  this.tsPrintTypeLiteralOrInterfaceBody(node.body, node);
	}

	function TSTypeAliasDeclaration(node) {
	  const {
	    declare,
	    id,
	    typeParameters,
	    typeAnnotation
	  } = node;

	  if (declare) {
	    this.word("declare");
	    this.space();
	  }

	  this.word("type");
	  this.space();
	  this.print(id, node);
	  this.print(typeParameters, node);
	  this.space();
	  this.token("=");
	  this.space();
	  this.print(typeAnnotation, node);
	  this.token(";");
	}

	function TSAsExpression(node) {
	  const {
	    expression,
	    typeAnnotation
	  } = node;
	  this.print(expression, node);
	  this.space();
	  this.word("as");
	  this.space();
	  this.print(typeAnnotation, node);
	}

	function TSTypeAssertion(node) {
	  const {
	    typeAnnotation,
	    expression
	  } = node;
	  this.token("<");
	  this.print(typeAnnotation, node);
	  this.token(">");
	  this.space();
	  this.print(expression, node);
	}

	function TSEnumDeclaration(node) {
	  const {
	    declare,
	    const: isConst,
	    id,
	    members
	  } = node;

	  if (declare) {
	    this.word("declare");
	    this.space();
	  }

	  if (isConst) {
	    this.word("const");
	    this.space();
	  }

	  this.word("enum");
	  this.space();
	  this.print(id, node);
	  this.space();
	  this.tsPrintBraced(members, node);
	}

	function TSEnumMember(node) {
	  const {
	    id,
	    initializer
	  } = node;
	  this.print(id, node);

	  if (initializer) {
	    this.space();
	    this.token("=");
	    this.space();
	    this.print(initializer, node);
	  }

	  this.token(",");
	}

	function TSModuleDeclaration(node) {
	  const {
	    declare,
	    id
	  } = node;

	  if (declare) {
	    this.word("declare");
	    this.space();
	  }

	  if (!node.global) {
	    this.word(id.type === "Identifier" ? "namespace" : "module");
	    this.space();
	  }

	  this.print(id, node);

	  if (!node.body) {
	    this.token(";");
	    return;
	  }

	  let body = node.body;

	  while (body.type === "TSModuleDeclaration") {
	    this.token(".");
	    this.print(body.id, body);
	    body = body.body;
	  }

	  this.space();
	  this.print(body, node);
	}

	function TSModuleBlock(node) {
	  this.tsPrintBraced(node.body, node);
	}

	function TSImportEqualsDeclaration(node) {
	  const {
	    isExport,
	    id,
	    moduleReference
	  } = node;

	  if (isExport) {
	    this.word("export");
	    this.space();
	  }

	  this.word("import");
	  this.space();
	  this.print(id, node);
	  this.space();
	  this.token("=");
	  this.space();
	  this.print(moduleReference, node);
	  this.token(";");
	}

	function TSExternalModuleReference(node) {
	  this.token("require(");
	  this.print(node.expression, node);
	  this.token(")");
	}

	function TSNonNullExpression(node) {
	  this.print(node.expression, node);
	  this.token("!");
	}

	function TSExportAssignment(node) {
	  this.word("export");
	  this.space();
	  this.token("=");
	  this.space();
	  this.print(node.expression, node);
	  this.token(";");
	}

	function TSNamespaceExportDeclaration(node) {
	  this.word("export");
	  this.space();
	  this.word("as");
	  this.space();
	  this.word("namespace");
	  this.space();
	  this.print(node.id, node);
	}

	function tsPrintSignatureDeclarationBase(node) {
	  const {
	    typeParameters,
	    parameters
	  } = node;
	  this.print(typeParameters, node);
	  this.token("(");

	  this._parameters(parameters, node);

	  this.token(")");
	  this.print(node.typeAnnotation, node);
	}

/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = _default;
	exports.CodeGenerator = void 0;

	var _sourceMap = _interopRequireDefault(__webpack_require__(99));

	var _printer = _interopRequireDefault(__webpack_require__(98));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	class Generator extends _printer.default {
	  constructor(ast, opts = {}, code) {
	    const format = normalizeOptions(code, opts);
	    const map = opts.sourceMaps ? new _sourceMap.default(opts, code) : null;
	    super(format, map);
	    this.ast = ast;
	  }

	  generate() {
	    return super.generate(this.ast);
	  }

	}

	function normalizeOptions(code, opts) {
	  const format = {
	    auxiliaryCommentBefore: opts.auxiliaryCommentBefore,
	    auxiliaryCommentAfter: opts.auxiliaryCommentAfter,
	    shouldPrintComment: opts.shouldPrintComment,
	    retainLines: opts.retainLines,
	    retainFunctionParens: opts.retainFunctionParens,
	    comments: opts.comments == null || opts.comments,
	    compact: opts.compact,
	    minified: opts.minified,
	    concise: opts.concise,
	    jsonCompatibleStrings: opts.jsonCompatibleStrings,
	    indent: {
	      adjustMultilineComment: true,
	      style: "  ",
	      base: 0
	    },
	    decoratorsBeforeExport: !!opts.decoratorsBeforeExport,
	    jsescOption: Object.assign({
	      quotes: "double",
	      wrap: true
	    }, opts.jsescOption)
	  };

	  if (format.minified) {
	    format.compact = true;

	    format.shouldPrintComment = format.shouldPrintComment || (() => format.comments);
	  } else {
	    format.shouldPrintComment = format.shouldPrintComment || (value => format.comments || value.indexOf("@license") >= 0 || value.indexOf("@preserve") >= 0);
	  }

	  if (format.compact === "auto") {
	    format.compact = code.length > 500000;

	    if (format.compact) {
	      console.error("[BABEL] Note: The code generator has deoptimised the styling of " + `${opts.filename} as it exceeds the max of ${"500KB"}.`);
	    }
	  }

	  if (format.compact) {
	    format.indent.adjustMultilineComment = false;
	  }

	  return format;
	}

	class CodeGenerator {
	  constructor(ast, opts, code) {
	    this._generator = new Generator(ast, opts, code);
	  }

	  generate() {
	    return this._generator.generate();
	  }

	}

	exports.CodeGenerator = CodeGenerator;

	function _default(ast, opts, code) {
	  const gen = new Generator(ast, opts, code);
	  return gen.generate();
	}

/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.FunctionTypeAnnotation = exports.NullableTypeAnnotation = NullableTypeAnnotation;
	exports.UpdateExpression = UpdateExpression;
	exports.ObjectExpression = ObjectExpression;
	exports.DoExpression = DoExpression;
	exports.Binary = Binary;
	exports.IntersectionTypeAnnotation = exports.UnionTypeAnnotation = UnionTypeAnnotation;
	exports.TSAsExpression = TSAsExpression;
	exports.TSTypeAssertion = TSTypeAssertion;
	exports.BinaryExpression = BinaryExpression;
	exports.SequenceExpression = SequenceExpression;
	exports.AwaitExpression = exports.YieldExpression = YieldExpression;
	exports.ClassExpression = ClassExpression;
	exports.UnaryLike = UnaryLike;
	exports.FunctionExpression = FunctionExpression;
	exports.ArrowFunctionExpression = ArrowFunctionExpression;
	exports.ConditionalExpression = ConditionalExpression;
	exports.AssignmentExpression = AssignmentExpression;
	exports.NewExpression = NewExpression;

	function t() {
	  const data = _interopRequireWildcard(__webpack_require__(2));

	  t = function () {
	    return data;
	  };

	  return data;
	}

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

	const PRECEDENCE = {
	  "||": 0,
	  "&&": 1,
	  "|": 2,
	  "^": 3,
	  "&": 4,
	  "==": 5,
	  "===": 5,
	  "!=": 5,
	  "!==": 5,
	  "<": 6,
	  ">": 6,
	  "<=": 6,
	  ">=": 6,
	  in: 6,
	  instanceof: 6,
	  ">>": 7,
	  "<<": 7,
	  ">>>": 7,
	  "+": 8,
	  "-": 8,
	  "*": 9,
	  "/": 9,
	  "%": 9,
	  "**": 10
	};

	const isClassExtendsClause = (node, parent) => (t().isClassDeclaration(parent) || t().isClassExpression(parent)) && parent.superClass === node;

	function NullableTypeAnnotation(node, parent) {
	  return t().isArrayTypeAnnotation(parent);
	}

	function UpdateExpression(node, parent) {
	  return t().isMemberExpression(parent, {
	    object: node
	  }) || t().isCallExpression(parent, {
	    callee: node
	  }) || t().isNewExpression(parent, {
	    callee: node
	  }) || isClassExtendsClause(node, parent);
	}

	function ObjectExpression(node, parent, printStack) {
	  return isFirstInStatement(printStack, {
	    considerArrow: true
	  });
	}

	function DoExpression(node, parent, printStack) {
	  return isFirstInStatement(printStack);
	}

	function Binary(node, parent) {
	  if (node.operator === "**" && t().isBinaryExpression(parent, {
	    operator: "**"
	  })) {
	    return parent.left === node;
	  }

	  if (isClassExtendsClause(node, parent)) {
	    return true;
	  }

	  if ((t().isCallExpression(parent) || t().isNewExpression(parent)) && parent.callee === node || t().isUnaryLike(parent) || t().isMemberExpression(parent) && parent.object === node || t().isAwaitExpression(parent)) {
	    return true;
	  }

	  if (t().isBinary(parent)) {
	    const parentOp = parent.operator;
	    const parentPos = PRECEDENCE[parentOp];
	    const nodeOp = node.operator;
	    const nodePos = PRECEDENCE[nodeOp];

	    if (parentPos === nodePos && parent.right === node && !t().isLogicalExpression(parent) || parentPos > nodePos) {
	      return true;
	    }
	  }

	  return false;
	}

	function UnionTypeAnnotation(node, parent) {
	  return t().isArrayTypeAnnotation(parent) || t().isNullableTypeAnnotation(parent) || t().isIntersectionTypeAnnotation(parent) || t().isUnionTypeAnnotation(parent);
	}

	function TSAsExpression() {
	  return true;
	}

	function TSTypeAssertion() {
	  return true;
	}

	function BinaryExpression(node, parent) {
	  return node.operator === "in" && (t().isVariableDeclarator(parent) || t().isFor(parent));
	}

	function SequenceExpression(node, parent) {
	  if (t().isForStatement(parent) || t().isThrowStatement(parent) || t().isReturnStatement(parent) || t().isIfStatement(parent) && parent.test === node || t().isWhileStatement(parent) && parent.test === node || t().isForInStatement(parent) && parent.right === node || t().isSwitchStatement(parent) && parent.discriminant === node || t().isExpressionStatement(parent) && parent.expression === node) {
	    return false;
	  }

	  return true;
	}

	function YieldExpression(node, parent) {
	  return t().isBinary(parent) || t().isUnaryLike(parent) || t().isCallExpression(parent) || t().isMemberExpression(parent) || t().isNewExpression(parent) || t().isConditionalExpression(parent) && node === parent.test || isClassExtendsClause(node, parent);
	}

	function ClassExpression(node, parent, printStack) {
	  return isFirstInStatement(printStack, {
	    considerDefaultExports: true
	  });
	}

	function UnaryLike(node, parent) {
	  return t().isMemberExpression(parent, {
	    object: node
	  }) || t().isCallExpression(parent, {
	    callee: node
	  }) || t().isNewExpression(parent, {
	    callee: node
	  }) || t().isBinaryExpression(parent, {
	    operator: "**",
	    left: node
	  }) || isClassExtendsClause(node, parent);
	}

	function FunctionExpression(node, parent, printStack) {
	  return isFirstInStatement(printStack, {
	    considerDefaultExports: true
	  });
	}

	function ArrowFunctionExpression(node, parent) {
	  return t().isExportDeclaration(parent) || ConditionalExpression(node, parent);
	}

	function ConditionalExpression(node, parent) {
	  if (t().isUnaryLike(parent) || t().isBinary(parent) || t().isConditionalExpression(parent, {
	    test: node
	  }) || t().isAwaitExpression(parent) || t().isTaggedTemplateExpression(parent) || t().isTSTypeAssertion(parent) || t().isTSAsExpression(parent)) {
	    return true;
	  }

	  return UnaryLike(node, parent);
	}

	function AssignmentExpression(node) {
	  if (t().isObjectPattern(node.left)) {
	    return true;
	  } else {
	    return ConditionalExpression(...arguments);
	  }
	}

	function NewExpression(node, parent) {
	  return isClassExtendsClause(node, parent);
	}

	function isFirstInStatement(printStack, {
	  considerArrow = false,
	  considerDefaultExports = false
	} = {}) {
	  let i = printStack.length - 1;
	  let node = printStack[i];
	  i--;
	  let parent = printStack[i];

	  while (i > 0) {
	    if (t().isExpressionStatement(parent, {
	      expression: node
	    }) || t().isTaggedTemplateExpression(parent) || considerDefaultExports && t().isExportDefaultDeclaration(parent, {
	      declaration: node
	    }) || considerArrow && t().isArrowFunctionExpression(parent, {
	      body: node
	    })) {
	      return true;
	    }

	    if (t().isCallExpression(parent, {
	      callee: node
	    }) || t().isSequenceExpression(parent) && parent.expressions[0] === node || t().isMemberExpression(parent, {
	      object: node
	    }) || t().isConditional(parent, {
	      test: node
	    }) || t().isBinary(parent, {
	      left: node
	    }) || t().isAssignmentExpression(parent, {
	      left: node
	    })) {
	      node = parent;
	      i--;
	      parent = printStack[i];
	    } else {
	      return false;
	    }
	  }

	  return false;
	}

/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.list = exports.nodes = void 0;

	function t() {
	  const data = _interopRequireWildcard(__webpack_require__(2));

	  t = function () {
	    return data;
	  };

	  return data;
	}

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

	function crawl(node, state = {}) {
	  if (t().isMemberExpression(node)) {
	    crawl(node.object, state);
	    if (node.computed) crawl(node.property, state);
	  } else if (t().isBinary(node) || t().isAssignmentExpression(node)) {
	    crawl(node.left, state);
	    crawl(node.right, state);
	  } else if (t().isCallExpression(node)) {
	    state.hasCall = true;
	    crawl(node.callee, state);
	  } else if (t().isFunction(node)) {
	    state.hasFunction = true;
	  } else if (t().isIdentifier(node)) {
	    state.hasHelper = state.hasHelper || isHelper(node.callee);
	  }

	  return state;
	}

	function isHelper(node) {
	  if (t().isMemberExpression(node)) {
	    return isHelper(node.object) || isHelper(node.property);
	  } else if (t().isIdentifier(node)) {
	    return node.name === "require" || node.name[0] === "_";
	  } else if (t().isCallExpression(node)) {
	    return isHelper(node.callee);
	  } else if (t().isBinary(node) || t().isAssignmentExpression(node)) {
	    return t().isIdentifier(node.left) && isHelper(node.left) || isHelper(node.right);
	  } else {
	    return false;
	  }
	}

	function isType(node) {
	  return t().isLiteral(node) || t().isObjectExpression(node) || t().isArrayExpression(node) || t().isIdentifier(node) || t().isMemberExpression(node);
	}

	const nodes = {
	  AssignmentExpression(node) {
	    const state = crawl(node.right);

	    if (state.hasCall && state.hasHelper || state.hasFunction) {
	      return {
	        before: state.hasFunction,
	        after: true
	      };
	    }
	  },

	  SwitchCase(node, parent) {
	    return {
	      before: node.consequent.length || parent.cases[0] === node,
	      after: !node.consequent.length && parent.cases[parent.cases.length - 1] === node
	    };
	  },

	  LogicalExpression(node) {
	    if (t().isFunction(node.left) || t().isFunction(node.right)) {
	      return {
	        after: true
	      };
	    }
	  },

	  Literal(node) {
	    if (node.value === "use strict") {
	      return {
	        after: true
	      };
	    }
	  },

	  CallExpression(node) {
	    if (t().isFunction(node.callee) || isHelper(node)) {
	      return {
	        before: true,
	        after: true
	      };
	    }
	  },

	  VariableDeclaration(node) {
	    for (let i = 0; i < node.declarations.length; i++) {
	      const declar = node.declarations[i];
	      let enabled = isHelper(declar.id) && !isType(declar.init);

	      if (!enabled) {
	        const state = crawl(declar.init);
	        enabled = isHelper(declar.init) && state.hasCall || state.hasFunction;
	      }

	      if (enabled) {
	        return {
	          before: true,
	          after: true
	        };
	      }
	    }
	  },

	  IfStatement(node) {
	    if (t().isBlockStatement(node.consequent)) {
	      return {
	        before: true,
	        after: true
	      };
	    }
	  }

	};
	exports.nodes = nodes;

	nodes.ObjectProperty = nodes.ObjectTypeProperty = nodes.ObjectMethod = function (node, parent) {
	  if (parent.properties[0] === node) {
	    return {
	      before: true
	    };
	  }
	};

	nodes.ObjectTypeCallProperty = function (node, parent) {
	  if (parent.callProperties[0] === node && (!parent.properties || !parent.properties.length)) {
	    return {
	      before: true
	    };
	  }
	};

	nodes.ObjectTypeIndexer = function (node, parent) {
	  if (parent.indexers[0] === node && (!parent.properties || !parent.properties.length) && (!parent.callProperties || !parent.callProperties.length)) {
	    return {
	      before: true
	    };
	  }
	};

	nodes.ObjectTypeInternalSlot = function (node, parent) {
	  if (parent.internalSlots[0] === node && (!parent.properties || !parent.properties.length) && (!parent.callProperties || !parent.callProperties.length) && (!parent.indexers || !parent.indexers.length)) {
	    return {
	      before: true
	    };
	  }
	};

	const list = {
	  VariableDeclaration(node) {
	    return node.declarations.map(decl => decl.init);
	  },

	  ArrayExpression(node) {
	    return node.elements;
	  },

	  ObjectExpression(node) {
	    return node.properties;
	  }

	};
	exports.list = list;
	[["Function", true], ["Class", true], ["Loop", true], ["LabeledStatement", true], ["SwitchStatement", true], ["TryStatement", true]].forEach(function ([type, amounts]) {
	  if (typeof amounts === "boolean") {
	    amounts = {
	      after: amounts,
	      before: amounts
	    };
	  }

	  [type].concat(t().FLIPPED_ALIAS_KEYS[type] || []).forEach(function (type) {
	    nodes[type] = function () {
	      return amounts;
	    };
	  });
	});

/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;

	function _isInteger() {
	  const data = _interopRequireDefault(__webpack_require__(152));

	  _isInteger = function () {
	    return data;
	  };

	  return data;
	}

	function _repeat() {
	  const data = _interopRequireDefault(__webpack_require__(155));

	  _repeat = function () {
	    return data;
	  };

	  return data;
	}

	var _buffer = _interopRequireDefault(__webpack_require__(84));

	var n = _interopRequireWildcard(__webpack_require__(43));

	function t() {
	  const data = _interopRequireWildcard(__webpack_require__(2));

	  t = function () {
	    return data;
	  };

	  return data;
	}

	var generatorFunctions = _interopRequireWildcard(__webpack_require__(89));

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	const SCIENTIFIC_NOTATION = /e/i;
	const ZERO_DECIMAL_INTEGER = /\.0+$/;
	const NON_DECIMAL_LITERAL = /^0[box]/;

	class Printer {
	  constructor(format, map) {
	    this.inForStatementInitCounter = 0;
	    this._printStack = [];
	    this._indent = 0;
	    this._insideAux = false;
	    this._printedCommentStarts = {};
	    this._parenPushNewlineState = null;
	    this._noLineTerminator = false;
	    this._printAuxAfterOnNextUserNode = false;
	    this._printedComments = new WeakSet();
	    this._endsWithInteger = false;
	    this._endsWithWord = false;
	    this.format = format || {};
	    this._buf = new _buffer.default(map);
	  }

	  generate(ast) {
	    this.print(ast);

	    this._maybeAddAuxComment();

	    return this._buf.get();
	  }

	  indent() {
	    if (this.format.compact || this.format.concise) return;
	    this._indent++;
	  }

	  dedent() {
	    if (this.format.compact || this.format.concise) return;
	    this._indent--;
	  }

	  semicolon(force = false) {
	    this._maybeAddAuxComment();

	    this._append(";", !force);
	  }

	  rightBrace() {
	    if (this.format.minified) {
	      this._buf.removeLastSemicolon();
	    }

	    this.token("}");
	  }

	  space(force = false) {
	    if (this.format.compact) return;

	    if (this._buf.hasContent() && !this.endsWith(" ") && !this.endsWith("\n") || force) {
	      this._space();
	    }
	  }

	  word(str) {
	    if (this._endsWithWord || this.endsWith("/") && str.indexOf("/") === 0) {
	      this._space();
	    }

	    this._maybeAddAuxComment();

	    this._append(str);

	    this._endsWithWord = true;
	  }

	  number(str) {
	    this.word(str);
	    this._endsWithInteger = (0, _isInteger().default)(+str) && !NON_DECIMAL_LITERAL.test(str) && !SCIENTIFIC_NOTATION.test(str) && !ZERO_DECIMAL_INTEGER.test(str) && str[str.length - 1] !== ".";
	  }

	  token(str) {
	    if (str === "--" && this.endsWith("!") || str[0] === "+" && this.endsWith("+") || str[0] === "-" && this.endsWith("-") || str[0] === "." && this._endsWithInteger) {
	      this._space();
	    }

	    this._maybeAddAuxComment();

	    this._append(str);
	  }

	  newline(i) {
	    if (this.format.retainLines || this.format.compact) return;

	    if (this.format.concise) {
	      this.space();
	      return;
	    }

	    if (this.endsWith("\n\n")) return;
	    if (typeof i !== "number") i = 1;
	    i = Math.min(2, i);
	    if (this.endsWith("{\n") || this.endsWith(":\n")) i--;
	    if (i <= 0) return;

	    for (let j = 0; j < i; j++) {
	      this._newline();
	    }
	  }

	  endsWith(str) {
	    return this._buf.endsWith(str);
	  }

	  removeTrailingNewline() {
	    this._buf.removeTrailingNewline();
	  }

	  exactSource(loc, cb) {
	    this._catchUp("start", loc);

	    this._buf.exactSource(loc, cb);
	  }

	  source(prop, loc) {
	    this._catchUp(prop, loc);

	    this._buf.source(prop, loc);
	  }

	  withSource(prop, loc, cb) {
	    this._catchUp(prop, loc);

	    this._buf.withSource(prop, loc, cb);
	  }

	  _space() {
	    this._append(" ", true);
	  }

	  _newline() {
	    this._append("\n", true);
	  }

	  _append(str, queue = false) {
	    this._maybeAddParen(str);

	    this._maybeIndent(str);

	    if (queue) this._buf.queue(str);else this._buf.append(str);
	    this._endsWithWord = false;
	    this._endsWithInteger = false;
	  }

	  _maybeIndent(str) {
	    if (this._indent && this.endsWith("\n") && str[0] !== "\n") {
	      this._buf.queue(this._getIndent());
	    }
	  }

	  _maybeAddParen(str) {
	    const parenPushNewlineState = this._parenPushNewlineState;
	    if (!parenPushNewlineState) return;
	    this._parenPushNewlineState = null;
	    let i;

	    for (i = 0; i < str.length && str[i] === " "; i++) continue;

	    if (i === str.length) return;
	    const cha = str[i];

	    if (cha !== "\n") {
	      if (cha !== "/") return;
	      if (i + 1 === str.length) return;
	      const chaPost = str[i + 1];
	      if (chaPost !== "/" && chaPost !== "*") return;
	    }

	    this.token("(");
	    this.indent();
	    parenPushNewlineState.printed = true;
	  }

	  _catchUp(prop, loc) {
	    if (!this.format.retainLines) return;
	    const pos = loc ? loc[prop] : null;

	    if (pos && pos.line !== null) {
	      const count = pos.line - this._buf.getCurrentLine();

	      for (let i = 0; i < count; i++) {
	        this._newline();
	      }
	    }
	  }

	  _getIndent() {
	    return (0, _repeat().default)(this.format.indent.style, this._indent);
	  }

	  startTerminatorless(isLabel = false) {
	    if (isLabel) {
	      this._noLineTerminator = true;
	      return null;
	    } else {
	      return this._parenPushNewlineState = {
	        printed: false
	      };
	    }
	  }

	  endTerminatorless(state) {
	    this._noLineTerminator = false;

	    if (state && state.printed) {
	      this.dedent();
	      this.newline();
	      this.token(")");
	    }
	  }

	  print(node, parent) {
	    if (!node) return;
	    const oldConcise = this.format.concise;

	    if (node._compact) {
	      this.format.concise = true;
	    }

	    const printMethod = this[node.type];

	    if (!printMethod) {
	      throw new ReferenceError(`unknown node of type ${JSON.stringify(node.type)} with constructor ${JSON.stringify(node && node.constructor.name)}`);
	    }

	    this._printStack.push(node);

	    const oldInAux = this._insideAux;
	    this._insideAux = !node.loc;

	    this._maybeAddAuxComment(this._insideAux && !oldInAux);

	    let needsParens = n.needsParens(node, parent, this._printStack);

	    if (this.format.retainFunctionParens && node.type === "FunctionExpression" && node.extra && node.extra.parenthesized) {
	      needsParens = true;
	    }

	    if (needsParens) this.token("(");

	    this._printLeadingComments(node, parent);

	    const loc = t().isProgram(node) || t().isFile(node) ? null : node.loc;
	    this.withSource("start", loc, () => {
	      this[node.type](node, parent);
	    });

	    this._printTrailingComments(node, parent);

	    if (needsParens) this.token(")");

	    this._printStack.pop();

	    this.format.concise = oldConcise;
	    this._insideAux = oldInAux;
	  }

	  _maybeAddAuxComment(enteredPositionlessNode) {
	    if (enteredPositionlessNode) this._printAuxBeforeComment();
	    if (!this._insideAux) this._printAuxAfterComment();
	  }

	  _printAuxBeforeComment() {
	    if (this._printAuxAfterOnNextUserNode) return;
	    this._printAuxAfterOnNextUserNode = true;
	    const comment = this.format.auxiliaryCommentBefore;

	    if (comment) {
	      this._printComment({
	        type: "CommentBlock",
	        value: comment
	      });
	    }
	  }

	  _printAuxAfterComment() {
	    if (!this._printAuxAfterOnNextUserNode) return;
	    this._printAuxAfterOnNextUserNode = false;
	    const comment = this.format.auxiliaryCommentAfter;

	    if (comment) {
	      this._printComment({
	        type: "CommentBlock",
	        value: comment
	      });
	    }
	  }

	  getPossibleRaw(node) {
	    const extra = node.extra;

	    if (extra && extra.raw != null && extra.rawValue != null && node.value === extra.rawValue) {
	      return extra.raw;
	    }
	  }

	  printJoin(nodes, parent, opts = {}) {
	    if (!nodes || !nodes.length) return;
	    if (opts.indent) this.indent();
	    const newlineOpts = {
	      addNewlines: opts.addNewlines
	    };

	    for (let i = 0; i < nodes.length; i++) {
	      const node = nodes[i];
	      if (!node) continue;
	      if (opts.statement) this._printNewline(true, node, parent, newlineOpts);
	      this.print(node, parent);

	      if (opts.iterator) {
	        opts.iterator(node, i);
	      }

	      if (opts.separator && i < nodes.length - 1) {
	        opts.separator.call(this);
	      }

	      if (opts.statement) this._printNewline(false, node, parent, newlineOpts);
	    }

	    if (opts.indent) this.dedent();
	  }

	  printAndIndentOnComments(node, parent) {
	    const indent = node.leadingComments && node.leadingComments.length > 0;
	    if (indent) this.indent();
	    this.print(node, parent);
	    if (indent) this.dedent();
	  }

	  printBlock(parent) {
	    const node = parent.body;

	    if (!t().isEmptyStatement(node)) {
	      this.space();
	    }

	    this.print(node, parent);
	  }

	  _printTrailingComments(node, parent) {
	    this._printComments(this._getComments(false, node, parent));
	  }

	  _printLeadingComments(node, parent) {
	    this._printComments(this._getComments(true, node, parent));
	  }

	  printInnerComments(node, indent = true) {
	    if (!node.innerComments || !node.innerComments.length) return;
	    if (indent) this.indent();

	    this._printComments(node.innerComments);

	    if (indent) this.dedent();
	  }

	  printSequence(nodes, parent, opts = {}) {
	    opts.statement = true;
	    return this.printJoin(nodes, parent, opts);
	  }

	  printList(items, parent, opts = {}) {
	    if (opts.separator == null) {
	      opts.separator = commaSeparator;
	    }

	    return this.printJoin(items, parent, opts);
	  }

	  _printNewline(leading, node, parent, opts) {
	    if (this.format.retainLines || this.format.compact) return;

	    if (this.format.concise) {
	      this.space();
	      return;
	    }

	    let lines = 0;

	    if (this._buf.hasContent()) {
	      if (!leading) lines++;
	      if (opts.addNewlines) lines += opts.addNewlines(leading, node) || 0;
	      const needs = leading ? n.needsWhitespaceBefore : n.needsWhitespaceAfter;
	      if (needs(node, parent)) lines++;
	    }

	    this.newline(lines);
	  }

	  _getComments(leading, node) {
	    return node && (leading ? node.leadingComments : node.trailingComments) || [];
	  }

	  _printComment(comment) {
	    if (!this.format.shouldPrintComment(comment.value)) return;
	    if (comment.ignore) return;
	    if (this._printedComments.has(comment)) return;

	    this._printedComments.add(comment);

	    if (comment.start != null) {
	      if (this._printedCommentStarts[comment.start]) return;
	      this._printedCommentStarts[comment.start] = true;
	    }

	    const isBlockComment = comment.type === "CommentBlock";
	    this.newline(this._buf.hasContent() && !this._noLineTerminator && isBlockComment ? 1 : 0);
	    if (!this.endsWith("[") && !this.endsWith("{")) this.space();
	    let val = !isBlockComment && !this._noLineTerminator ? `//${comment.value}\n` : `/*${comment.value}*/`;

	    if (isBlockComment && this.format.indent.adjustMultilineComment) {
	      const offset = comment.loc && comment.loc.start.column;

	      if (offset) {
	        const newlineRegex = new RegExp("\\n\\s{1," + offset + "}", "g");
	        val = val.replace(newlineRegex, "\n");
	      }

	      const indentSize = Math.max(this._getIndent().length, this._buf.getCurrentColumn());
	      val = val.replace(/\n(?!$)/g, `\n${(0, _repeat().default)(" ", indentSize)}`);
	    }

	    if (this.endsWith("/")) this._space();
	    this.withSource("start", comment.loc, () => {
	      this._append(val);
	    });
	    this.newline(isBlockComment && !this._noLineTerminator ? 1 : 0);
	  }

	  _printComments(comments) {
	    if (!comments || !comments.length) return;

	    for (const comment of comments) {
	      this._printComment(comment);
	    }
	  }

	}

	exports.default = Printer;
	Object.assign(Printer.prototype, generatorFunctions);

	function commaSeparator() {
	  this.token(",");
	  this.space();
	}

/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;

	function _sourceMap() {
	  const data = _interopRequireDefault(__webpack_require__(157));

	  _sourceMap = function () {
	    return data;
	  };

	  return data;
	}

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	class SourceMap {
	  constructor(opts, code) {
	    this._cachedMap = null;
	    this._code = code;
	    this._opts = opts;
	    this._rawMappings = [];
	  }

	  get() {
	    if (!this._cachedMap) {
	      const map = this._cachedMap = new (_sourceMap().default.SourceMapGenerator)({
	        sourceRoot: this._opts.sourceRoot
	      });
	      const code = this._code;

	      if (typeof code === "string") {
	        map.setSourceContent(this._opts.sourceFileName, code);
	      } else if (typeof code === "object") {
	        Object.keys(code).forEach(sourceFileName => {
	          map.setSourceContent(sourceFileName, code[sourceFileName]);
	        });
	      }

	      this._rawMappings.forEach(map.addMapping, map);
	    }

	    return this._cachedMap.toJSON();
	  }

	  getRawMappings() {
	    return this._rawMappings.slice();
	  }

	  mark(generatedLine, generatedColumn, line, column, identifierName, filename, force) {
	    if (this._lastGenLine !== generatedLine && line === null) return;

	    if (!force && this._lastGenLine === generatedLine && this._lastSourceLine === line && this._lastSourceColumn === column) {
	      return;
	    }

	    this._cachedMap = null;
	    this._lastGenLine = generatedLine;
	    this._lastSourceLine = line;
	    this._lastSourceColumn = column;

	    this._rawMappings.push({
	      name: identifierName || undefined,
	      generated: {
	        line: generatedLine,
	        column: generatedColumn
	      },
	      source: line == null ? undefined : filename || this._opts.sourceFileName,
	      original: line == null ? undefined : {
	        line: line,
	        column: column
	      }
	    });
	  }

	}

	exports.default = SourceMap;

/***/ }),
/* 100 */
/***/ (function(module, exports) {

	'use strict';

	Object.defineProperty(exports, '__esModule', { value: true });

	function _AwaitValue(value) {
	  this.wrapped = value;
	}

	function _AsyncGenerator(gen) {
	  var front, back;

	  function send(key, arg) {
	    return new Promise(function (resolve, reject) {
	      var request = {
	        key: key,
	        arg: arg,
	        resolve: resolve,
	        reject: reject,
	        next: null
	      };

	      if (back) {
	        back = back.next = request;
	      } else {
	        front = back = request;
	        resume(key, arg);
	      }
	    });
	  }

	  function resume(key, arg) {
	    try {
	      var result = gen[key](arg);
	      var value = result.value;
	      var wrappedAwait = value instanceof _AwaitValue;
	      Promise.resolve(wrappedAwait ? value.wrapped : value).then(function (arg) {
	        if (wrappedAwait) {
	          resume("next", arg);
	          return;
	        }

	        settle(result.done ? "return" : "normal", arg);
	      }, function (err) {
	        resume("throw", err);
	      });
	    } catch (err) {
	      settle("throw", err);
	    }
	  }

	  function settle(type, value) {
	    switch (type) {
	      case "return":
	        front.resolve({
	          value: value,
	          done: true
	        });
	        break;

	      case "throw":
	        front.reject(value);
	        break;

	      default:
	        front.resolve({
	          value: value,
	          done: false
	        });
	        break;
	    }

	    front = front.next;

	    if (front) {
	      resume(front.key, front.arg);
	    } else {
	      back = null;
	    }
	  }

	  this._invoke = send;

	  if (typeof gen.return !== "function") {
	    this.return = undefined;
	  }
	}

	if (typeof Symbol === "function" && Symbol.asyncIterator) {
	  _AsyncGenerator.prototype[Symbol.asyncIterator] = function () {
	    return this;
	  };
	}

	_AsyncGenerator.prototype.next = function (arg) {
	  return this._invoke("next", arg);
	};

	_AsyncGenerator.prototype.throw = function (arg) {
	  return this._invoke("throw", arg);
	};

	_AsyncGenerator.prototype.return = function (arg) {
	  return this._invoke("return", arg);
	};

	function _inheritsLoose(subClass, superClass) {
	  subClass.prototype = Object.create(superClass.prototype);
	  subClass.prototype.constructor = subClass;
	  subClass.__proto__ = superClass;
	}

	var beforeExpr = true;
	var startsExpr = true;
	var isLoop = true;
	var isAssign = true;
	var prefix = true;
	var postfix = true;
	var TokenType = function TokenType(label, conf) {
	  if (conf === void 0) {
	    conf = {};
	  }

	  this.label = label;
	  this.keyword = conf.keyword;
	  this.beforeExpr = !!conf.beforeExpr;
	  this.startsExpr = !!conf.startsExpr;
	  this.rightAssociative = !!conf.rightAssociative;
	  this.isLoop = !!conf.isLoop;
	  this.isAssign = !!conf.isAssign;
	  this.prefix = !!conf.prefix;
	  this.postfix = !!conf.postfix;
	  this.binop = conf.binop === 0 ? 0 : conf.binop || null;
	  this.updateContext = null;
	};

	var KeywordTokenType = function (_TokenType) {
	  _inheritsLoose(KeywordTokenType, _TokenType);

	  function KeywordTokenType(name, options) {
	    if (options === void 0) {
	      options = {};
	    }

	    options.keyword = name;
	    return _TokenType.call(this, name, options) || this;
	  }

	  return KeywordTokenType;
	}(TokenType);

	var BinopTokenType = function (_TokenType2) {
	  _inheritsLoose(BinopTokenType, _TokenType2);

	  function BinopTokenType(name, prec) {
	    return _TokenType2.call(this, name, {
	      beforeExpr: beforeExpr,
	      binop: prec
	    }) || this;
	  }

	  return BinopTokenType;
	}(TokenType);
	var types = {
	  num: new TokenType("num", {
	    startsExpr: startsExpr
	  }),
	  bigint: new TokenType("bigint", {
	    startsExpr: startsExpr
	  }),
	  regexp: new TokenType("regexp", {
	    startsExpr: startsExpr
	  }),
	  string: new TokenType("string", {
	    startsExpr: startsExpr
	  }),
	  name: new TokenType("name", {
	    startsExpr: startsExpr
	  }),
	  eof: new TokenType("eof"),
	  bracketL: new TokenType("[", {
	    beforeExpr: beforeExpr,
	    startsExpr: startsExpr
	  }),
	  bracketR: new TokenType("]"),
	  braceL: new TokenType("{", {
	    beforeExpr: beforeExpr,
	    startsExpr: startsExpr
	  }),
	  braceBarL: new TokenType("{|", {
	    beforeExpr: beforeExpr,
	    startsExpr: startsExpr
	  }),
	  braceR: new TokenType("}"),
	  braceBarR: new TokenType("|}"),
	  parenL: new TokenType("(", {
	    beforeExpr: beforeExpr,
	    startsExpr: startsExpr
	  }),
	  parenR: new TokenType(")"),
	  comma: new TokenType(",", {
	    beforeExpr: beforeExpr
	  }),
	  semi: new TokenType(";", {
	    beforeExpr: beforeExpr
	  }),
	  colon: new TokenType(":", {
	    beforeExpr: beforeExpr
	  }),
	  doubleColon: new TokenType("::", {
	    beforeExpr: beforeExpr
	  }),
	  dot: new TokenType("."),
	  question: new TokenType("?", {
	    beforeExpr: beforeExpr
	  }),
	  questionDot: new TokenType("?."),
	  arrow: new TokenType("=>", {
	    beforeExpr: beforeExpr
	  }),
	  template: new TokenType("template"),
	  ellipsis: new TokenType("...", {
	    beforeExpr: beforeExpr
	  }),
	  backQuote: new TokenType("`", {
	    startsExpr: startsExpr
	  }),
	  dollarBraceL: new TokenType("${", {
	    beforeExpr: beforeExpr,
	    startsExpr: startsExpr
	  }),
	  at: new TokenType("@"),
	  hash: new TokenType("#"),
	  interpreterDirective: new TokenType("#!..."),
	  eq: new TokenType("=", {
	    beforeExpr: beforeExpr,
	    isAssign: isAssign
	  }),
	  assign: new TokenType("_=", {
	    beforeExpr: beforeExpr,
	    isAssign: isAssign
	  }),
	  incDec: new TokenType("++/--", {
	    prefix: prefix,
	    postfix: postfix,
	    startsExpr: startsExpr
	  }),
	  bang: new TokenType("!", {
	    beforeExpr: beforeExpr,
	    prefix: prefix,
	    startsExpr: startsExpr
	  }),
	  tilde: new TokenType("~", {
	    beforeExpr: beforeExpr,
	    prefix: prefix,
	    startsExpr: startsExpr
	  }),
	  pipeline: new BinopTokenType("|>", 0),
	  nullishCoalescing: new BinopTokenType("??", 1),
	  logicalOR: new BinopTokenType("||", 1),
	  logicalAND: new BinopTokenType("&&", 2),
	  bitwiseOR: new BinopTokenType("|", 3),
	  bitwiseXOR: new BinopTokenType("^", 4),
	  bitwiseAND: new BinopTokenType("&", 5),
	  equality: new BinopTokenType("==/!=", 6),
	  relational: new BinopTokenType("</>", 7),
	  bitShift: new BinopTokenType("<</>>", 8),
	  plusMin: new TokenType("+/-", {
	    beforeExpr: beforeExpr,
	    binop: 9,
	    prefix: prefix,
	    startsExpr: startsExpr
	  }),
	  modulo: new BinopTokenType("%", 10),
	  star: new BinopTokenType("*", 10),
	  slash: new BinopTokenType("/", 10),
	  exponent: new TokenType("**", {
	    beforeExpr: beforeExpr,
	    binop: 11,
	    rightAssociative: true
	  })
	};
	var keywords = {
	  break: new KeywordTokenType("break"),
	  case: new KeywordTokenType("case", {
	    beforeExpr: beforeExpr
	  }),
	  catch: new KeywordTokenType("catch"),
	  continue: new KeywordTokenType("continue"),
	  debugger: new KeywordTokenType("debugger"),
	  default: new KeywordTokenType("default", {
	    beforeExpr: beforeExpr
	  }),
	  do: new KeywordTokenType("do", {
	    isLoop: isLoop,
	    beforeExpr: beforeExpr
	  }),
	  else: new KeywordTokenType("else", {
	    beforeExpr: beforeExpr
	  }),
	  finally: new KeywordTokenType("finally"),
	  for: new KeywordTokenType("for", {
	    isLoop: isLoop
	  }),
	  function: new KeywordTokenType("function", {
	    startsExpr: startsExpr
	  }),
	  if: new KeywordTokenType("if"),
	  return: new KeywordTokenType("return", {
	    beforeExpr: beforeExpr
	  }),
	  switch: new KeywordTokenType("switch"),
	  throw: new KeywordTokenType("throw", {
	    beforeExpr: beforeExpr,
	    prefix: prefix,
	    startsExpr: startsExpr
	  }),
	  try: new KeywordTokenType("try"),
	  var: new KeywordTokenType("var"),
	  let: new KeywordTokenType("let"),
	  const: new KeywordTokenType("const"),
	  while: new KeywordTokenType("while", {
	    isLoop: isLoop
	  }),
	  with: new KeywordTokenType("with"),
	  new: new KeywordTokenType("new", {
	    beforeExpr: beforeExpr,
	    startsExpr: startsExpr
	  }),
	  this: new KeywordTokenType("this", {
	    startsExpr: startsExpr
	  }),
	  super: new KeywordTokenType("super", {
	    startsExpr: startsExpr
	  }),
	  class: new KeywordTokenType("class"),
	  extends: new KeywordTokenType("extends", {
	    beforeExpr: beforeExpr
	  }),
	  export: new KeywordTokenType("export"),
	  import: new KeywordTokenType("import", {
	    startsExpr: startsExpr
	  }),
	  yield: new KeywordTokenType("yield", {
	    beforeExpr: beforeExpr,
	    startsExpr: startsExpr
	  }),
	  null: new KeywordTokenType("null", {
	    startsExpr: startsExpr
	  }),
	  true: new KeywordTokenType("true", {
	    startsExpr: startsExpr
	  }),
	  false: new KeywordTokenType("false", {
	    startsExpr: startsExpr
	  }),
	  in: new KeywordTokenType("in", {
	    beforeExpr: beforeExpr,
	    binop: 7
	  }),
	  instanceof: new KeywordTokenType("instanceof", {
	    beforeExpr: beforeExpr,
	    binop: 7
	  }),
	  typeof: new KeywordTokenType("typeof", {
	    beforeExpr: beforeExpr,
	    prefix: prefix,
	    startsExpr: startsExpr
	  }),
	  void: new KeywordTokenType("void", {
	    beforeExpr: beforeExpr,
	    prefix: prefix,
	    startsExpr: startsExpr
	  }),
	  delete: new KeywordTokenType("delete", {
	    beforeExpr: beforeExpr,
	    prefix: prefix,
	    startsExpr: startsExpr
	  })
	};
	Object.keys(keywords).forEach(function (name) {
	  types["_" + name] = keywords[name];
	});

	function isSimpleProperty(node) {
	  return node != null && node.type === "Property" && node.kind === "init" && node.method === false;
	}

	var estree = (function (superClass) {
	  return function (_superClass) {
	    _inheritsLoose(_class, _superClass);

	    function _class() {
	      return _superClass.apply(this, arguments) || this;
	    }

	    var _proto = _class.prototype;

	    _proto.estreeParseRegExpLiteral = function estreeParseRegExpLiteral(_ref) {
	      var pattern = _ref.pattern,
	          flags = _ref.flags;
	      var regex = null;

	      try {
	        regex = new RegExp(pattern, flags);
	      } catch (e) {}

	      var node = this.estreeParseLiteral(regex);
	      node.regex = {
	        pattern: pattern,
	        flags: flags
	      };
	      return node;
	    };

	    _proto.estreeParseLiteral = function estreeParseLiteral(value) {
	      return this.parseLiteral(value, "Literal");
	    };

	    _proto.directiveToStmt = function directiveToStmt(directive) {
	      var directiveLiteral = directive.value;
	      var stmt = this.startNodeAt(directive.start, directive.loc.start);
	      var expression = this.startNodeAt(directiveLiteral.start, directiveLiteral.loc.start);
	      expression.value = directiveLiteral.value;
	      expression.raw = directiveLiteral.extra.raw;
	      stmt.expression = this.finishNodeAt(expression, "Literal", directiveLiteral.end, directiveLiteral.loc.end);
	      stmt.directive = directiveLiteral.extra.raw.slice(1, -1);
	      return this.finishNodeAt(stmt, "ExpressionStatement", directive.end, directive.loc.end);
	    };

	    _proto.initFunction = function initFunction(node, isAsync) {
	      _superClass.prototype.initFunction.call(this, node, isAsync);

	      node.expression = false;
	    };

	    _proto.checkDeclaration = function checkDeclaration(node) {
	      if (isSimpleProperty(node)) {
	        this.checkDeclaration(node.value);
	      } else {
	        _superClass.prototype.checkDeclaration.call(this, node);
	      }
	    };

	    _proto.checkGetterSetterParams = function checkGetterSetterParams(method) {
	      var prop = method;
	      var paramCount = prop.kind === "get" ? 0 : 1;
	      var start = prop.start;

	      if (prop.value.params.length !== paramCount) {
	        if (prop.kind === "get") {
	          this.raise(start, "getter must not have any formal parameters");
	        } else {
	          this.raise(start, "setter must have exactly one formal parameter");
	        }
	      }

	      if (prop.kind === "set" && prop.value.params[0].type === "RestElement") {
	        this.raise(start, "setter function argument must not be a rest parameter");
	      }
	    };

	    _proto.checkLVal = function checkLVal(expr, isBinding, checkClashes, contextDescription) {
	      var _this = this;

	      switch (expr.type) {
	        case "ObjectPattern":
	          expr.properties.forEach(function (prop) {
	            _this.checkLVal(prop.type === "Property" ? prop.value : prop, isBinding, checkClashes, "object destructuring pattern");
	          });
	          break;

	        default:
	          _superClass.prototype.checkLVal.call(this, expr, isBinding, checkClashes, contextDescription);

	      }
	    };

	    _proto.checkPropClash = function checkPropClash(prop, propHash) {
	      if (prop.computed || !isSimpleProperty(prop)) return;
	      var key = prop.key;
	      var name = key.type === "Identifier" ? key.name : String(key.value);

	      if (name === "__proto__") {
	        if (propHash.proto) {
	          this.raise(key.start, "Redefinition of __proto__ property");
	        }

	        propHash.proto = true;
	      }
	    };

	    _proto.isStrictBody = function isStrictBody(node) {
	      var isBlockStatement = node.body.type === "BlockStatement";

	      if (isBlockStatement && node.body.body.length > 0) {
	        for (var _i2 = 0, _node$body$body2 = node.body.body; _i2 < _node$body$body2.length; _i2++) {
	          var directive = _node$body$body2[_i2];

	          if (directive.type === "ExpressionStatement" && directive.expression.type === "Literal") {
	            if (directive.expression.value === "use strict") return true;
	          } else {
	            break;
	          }
	        }
	      }

	      return false;
	    };

	    _proto.isValidDirective = function isValidDirective(stmt) {
	      return stmt.type === "ExpressionStatement" && stmt.expression.type === "Literal" && typeof stmt.expression.value === "string" && (!stmt.expression.extra || !stmt.expression.extra.parenthesized);
	    };

	    _proto.stmtToDirective = function stmtToDirective(stmt) {
	      var directive = _superClass.prototype.stmtToDirective.call(this, stmt);

	      var value = stmt.expression.value;
	      directive.value.value = value;
	      return directive;
	    };

	    _proto.parseBlockBody = function parseBlockBody(node, allowDirectives, topLevel, end) {
	      var _this2 = this;

	      _superClass.prototype.parseBlockBody.call(this, node, allowDirectives, topLevel, end);

	      var directiveStatements = node.directives.map(function (d) {
	        return _this2.directiveToStmt(d);
	      });
	      node.body = directiveStatements.concat(node.body);
	      delete node.directives;
	    };

	    _proto.pushClassMethod = function pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor) {
	      this.parseMethod(method, isGenerator, isAsync, isConstructor, "MethodDefinition");

	      if (method.typeParameters) {
	        method.value.typeParameters = method.typeParameters;
	        delete method.typeParameters;
	      }

	      classBody.body.push(method);
	    };

	    _proto.parseExprAtom = function parseExprAtom(refShorthandDefaultPos) {
	      switch (this.state.type) {
	        case types.regexp:
	          return this.estreeParseRegExpLiteral(this.state.value);

	        case types.num:
	        case types.string:
	          return this.estreeParseLiteral(this.state.value);

	        case types._null:
	          return this.estreeParseLiteral(null);

	        case types._true:
	          return this.estreeParseLiteral(true);

	        case types._false:
	          return this.estreeParseLiteral(false);

	        default:
	          return _superClass.prototype.parseExprAtom.call(this, refShorthandDefaultPos);
	      }
	    };

	    _proto.parseLiteral = function parseLiteral(value, type, startPos, startLoc) {
	      var node = _superClass.prototype.parseLiteral.call(this, value, type, startPos, startLoc);

	      node.raw = node.extra.raw;
	      delete node.extra;
	      return node;
	    };

	    _proto.parseFunctionBody = function parseFunctionBody(node, allowExpression) {
	      _superClass.prototype.parseFunctionBody.call(this, node, allowExpression);

	      node.expression = node.body.type !== "BlockStatement";
	    };

	    _proto.parseMethod = function parseMethod(node, isGenerator, isAsync, isConstructor, type) {
	      var funcNode = this.startNode();
	      funcNode.kind = node.kind;
	      funcNode = _superClass.prototype.parseMethod.call(this, funcNode, isGenerator, isAsync, isConstructor, "FunctionExpression");
	      delete funcNode.kind;
	      node.value = funcNode;
	      return this.finishNode(node, type);
	    };

	    _proto.parseObjectMethod = function parseObjectMethod(prop, isGenerator, isAsync, isPattern, containsEsc) {
	      var node = _superClass.prototype.parseObjectMethod.call(this, prop, isGenerator, isAsync, isPattern, containsEsc);

	      if (node) {
	        node.type = "Property";
	        if (node.kind === "method") node.kind = "init";
	        node.shorthand = false;
	      }

	      return node;
	    };

	    _proto.parseObjectProperty = function parseObjectProperty(prop, startPos, startLoc, isPattern, refShorthandDefaultPos) {
	      var node = _superClass.prototype.parseObjectProperty.call(this, prop, startPos, startLoc, isPattern, refShorthandDefaultPos);

	      if (node) {
	        node.kind = "init";
	        node.type = "Property";
	      }

	      return node;
	    };

	    _proto.toAssignable = function toAssignable(node, isBinding, contextDescription) {
	      if (isSimpleProperty(node)) {
	        this.toAssignable(node.value, isBinding, contextDescription);
	        return node;
	      }

	      return _superClass.prototype.toAssignable.call(this, node, isBinding, contextDescription);
	    };

	    _proto.toAssignableObjectExpressionProp = function toAssignableObjectExpressionProp(prop, isBinding, isLast) {
	      if (prop.kind === "get" || prop.kind === "set") {
	        this.raise(prop.key.start, "Object pattern can't contain getter or setter");
	      } else if (prop.method) {
	        this.raise(prop.key.start, "Object pattern can't contain methods");
	      } else {
	        _superClass.prototype.toAssignableObjectExpressionProp.call(this, prop, isBinding, isLast);
	      }
	    };

	    return _class;
	  }(superClass);
	});

	function makePredicate(words) {
	  var wordsArr = words.split(" ");
	  return function (str) {
	    return wordsArr.indexOf(str) >= 0;
	  };
	}

	var reservedWords = {
	  "6": makePredicate("enum await"),
	  strict: makePredicate("implements interface let package private protected public static yield"),
	  strictBind: makePredicate("eval arguments")
	};
	var isKeyword = makePredicate("break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this let const class extends export import yield super");
	var nonASCIIidentifierStartChars = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEF\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7B9\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC";
	var nonASCIIidentifierChars = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08D3-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D82\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF2-\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DF9\u1DFB-\u1DFF\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F";
	var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
	var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
	nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
	var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 157, 310, 10, 21, 11, 7, 153, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 477, 28, 11, 0, 9, 21, 190, 52, 76, 44, 33, 24, 27, 35, 30, 0, 12, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 54, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 86, 26, 230, 43, 117, 63, 32, 0, 257, 0, 11, 39, 8, 0, 22, 0, 12, 39, 3, 3, 20, 0, 35, 56, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 270, 921, 103, 110, 18, 195, 2749, 1070, 4050, 582, 8634, 568, 8, 30, 114, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 68, 12, 0, 67, 12, 65, 1, 31, 6129, 15, 754, 9486, 286, 82, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 4149, 196, 60, 67, 1213, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42710, 42, 4148, 12, 221, 3, 5761, 15, 7472, 3104, 541];
	var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 525, 10, 176, 2, 54, 14, 32, 9, 16, 3, 46, 10, 54, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 4, 9, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 280, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 135, 4, 60, 6, 26, 9, 1016, 45, 17, 3, 19723, 1, 5319, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 2214, 6, 110, 6, 6, 9, 792487, 239];

	function isInAstralSet(code, set) {
	  var pos = 0x10000;

	  for (var i = 0; i < set.length; i += 2) {
	    pos += set[i];
	    if (pos > code) return false;
	    pos += set[i + 1];
	    if (pos >= code) return true;
	  }

	  return false;
	}

	function isIdentifierStart(code) {
	  if (code < 65) return code === 36;
	  if (code <= 90) return true;
	  if (code < 97) return code === 95;
	  if (code <= 122) return true;

	  if (code <= 0xffff) {
	    return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));
	  }

	  return isInAstralSet(code, astralIdentifierStartCodes);
	}
	function isIteratorStart(current, next) {
	  return current === 64 && next === 64;
	}
	function isIdentifierChar(code) {
	  if (code < 48) return code === 36;
	  if (code < 58) return true;
	  if (code < 65) return false;
	  if (code <= 90) return true;
	  if (code < 97) return code === 95;
	  if (code <= 122) return true;

	  if (code <= 0xffff) {
	    return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));
	  }

	  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
	}

	var primitiveTypes = ["any", "bool", "boolean", "empty", "false", "mixed", "null", "number", "static", "string", "true", "typeof", "void"];

	function isEsModuleType(bodyElement) {
	  return bodyElement.type === "DeclareExportAllDeclaration" || bodyElement.type === "DeclareExportDeclaration" && (!bodyElement.declaration || bodyElement.declaration.type !== "TypeAlias" && bodyElement.declaration.type !== "InterfaceDeclaration");
	}

	function hasTypeImportKind(node) {
	  return node.importKind === "type" || node.importKind === "typeof";
	}

	function isMaybeDefaultImport(state) {
	  return (state.type === types.name || !!state.type.keyword) && state.value !== "from";
	}

	var exportSuggestions = {
	  const: "declare export var",
	  let: "declare export var",
	  type: "export type",
	  interface: "export interface"
	};

	function partition(list, test) {
	  var list1 = [];
	  var list2 = [];

	  for (var i = 0; i < list.length; i++) {
	    (test(list[i], i, list) ? list1 : list2).push(list[i]);
	  }

	  return [list1, list2];
	}

	var FLOW_PRAGMA_REGEX = /\*?\s*@((?:no)?flow)\b/;
	var flow = (function (superClass) {
	  return function (_superClass) {
	    _inheritsLoose(_class, _superClass);

	    function _class(options, input) {
	      var _this;

	      _this = _superClass.call(this, options, input) || this;
	      _this.flowPragma = undefined;
	      return _this;
	    }

	    var _proto = _class.prototype;

	    _proto.shouldParseTypes = function shouldParseTypes() {
	      return this.getPluginOption("flow", "all") || this.flowPragma === "flow";
	    };

	    _proto.addComment = function addComment(comment) {
	      if (this.flowPragma === undefined) {
	        var matches = FLOW_PRAGMA_REGEX.exec(comment.value);

	        if (!matches) {
	          this.flowPragma = null;
	        } else if (matches[1] === "flow") {
	          this.flowPragma = "flow";
	        } else if (matches[1] === "noflow") {
	          this.flowPragma = "noflow";
	        } else {
	          throw new Error("Unexpected flow pragma");
	        }
	      }

	      return _superClass.prototype.addComment.call(this, comment);
	    };

	    _proto.flowParseTypeInitialiser = function flowParseTypeInitialiser(tok) {
	      var oldInType = this.state.inType;
	      this.state.inType = true;
	      this.expect(tok || types.colon);
	      var type = this.flowParseType();
	      this.state.inType = oldInType;
	      return type;
	    };

	    _proto.flowParsePredicate = function flowParsePredicate() {
	      var node = this.startNode();
	      var moduloLoc = this.state.startLoc;
	      var moduloPos = this.state.start;
	      this.expect(types.modulo);
	      var checksLoc = this.state.startLoc;
	      this.expectContextual("checks");

	      if (moduloLoc.line !== checksLoc.line || moduloLoc.column !== checksLoc.column - 1) {
	        this.raise(moduloPos, "Spaces between ´%´ and ´checks´ are not allowed here.");
	      }

	      if (this.eat(types.parenL)) {
	        node.value = this.parseExpression();
	        this.expect(types.parenR);
	        return this.finishNode(node, "DeclaredPredicate");
	      } else {
	        return this.finishNode(node, "InferredPredicate");
	      }
	    };

	    _proto.flowParseTypeAndPredicateInitialiser = function flowParseTypeAndPredicateInitialiser() {
	      var oldInType = this.state.inType;
	      this.state.inType = true;
	      this.expect(types.colon);
	      var type = null;
	      var predicate = null;

	      if (this.match(types.modulo)) {
	        this.state.inType = oldInType;
	        predicate = this.flowParsePredicate();
	      } else {
	        type = this.flowParseType();
	        this.state.inType = oldInType;

	        if (this.match(types.modulo)) {
	          predicate = this.flowParsePredicate();
	        }
	      }

	      return [type, predicate];
	    };

	    _proto.flowParseDeclareClass = function flowParseDeclareClass(node) {
	      this.next();
	      this.flowParseInterfaceish(node, true);
	      return this.finishNode(node, "DeclareClass");
	    };

	    _proto.flowParseDeclareFunction = function flowParseDeclareFunction(node) {
	      this.next();
	      var id = node.id = this.parseIdentifier();
	      var typeNode = this.startNode();
	      var typeContainer = this.startNode();

	      if (this.isRelational("<")) {
	        typeNode.typeParameters = this.flowParseTypeParameterDeclaration();
	      } else {
	        typeNode.typeParameters = null;
	      }

	      this.expect(types.parenL);
	      var tmp = this.flowParseFunctionTypeParams();
	      typeNode.params = tmp.params;
	      typeNode.rest = tmp.rest;
	      this.expect(types.parenR);

	      var _this$flowParseTypeAn = this.flowParseTypeAndPredicateInitialiser();

	      typeNode.returnType = _this$flowParseTypeAn[0];
	      node.predicate = _this$flowParseTypeAn[1];
	      typeContainer.typeAnnotation = this.finishNode(typeNode, "FunctionTypeAnnotation");
	      id.typeAnnotation = this.finishNode(typeContainer, "TypeAnnotation");
	      this.finishNode(id, id.type);
	      this.semicolon();
	      return this.finishNode(node, "DeclareFunction");
	    };

	    _proto.flowParseDeclare = function flowParseDeclare(node, insideModule) {
	      if (this.match(types._class)) {
	        return this.flowParseDeclareClass(node);
	      } else if (this.match(types._function)) {
	        return this.flowParseDeclareFunction(node);
	      } else if (this.match(types._var)) {
	        return this.flowParseDeclareVariable(node);
	      } else if (this.isContextual("module")) {
	        if (this.lookahead().type === types.dot) {
	          return this.flowParseDeclareModuleExports(node);
	        } else {
	          if (insideModule) {
	            this.unexpected(null, "`declare module` cannot be used inside another `declare module`");
	          }

	          return this.flowParseDeclareModule(node);
	        }
	      } else if (this.isContextual("type")) {
	        return this.flowParseDeclareTypeAlias(node);
	      } else if (this.isContextual("opaque")) {
	        return this.flowParseDeclareOpaqueType(node);
	      } else if (this.isContextual("interface")) {
	        return this.flowParseDeclareInterface(node);
	      } else if (this.match(types._export)) {
	        return this.flowParseDeclareExportDeclaration(node, insideModule);
	      } else {
	        throw this.unexpected();
	      }
	    };

	    _proto.flowParseDeclareVariable = function flowParseDeclareVariable(node) {
	      this.next();
	      node.id = this.flowParseTypeAnnotatableIdentifier(true);
	      this.semicolon();
	      return this.finishNode(node, "DeclareVariable");
	    };

	    _proto.flowParseDeclareModule = function flowParseDeclareModule(node) {
	      var _this2 = this;

	      this.next();

	      if (this.match(types.string)) {
	        node.id = this.parseExprAtom();
	      } else {
	        node.id = this.parseIdentifier();
	      }

	      var bodyNode = node.body = this.startNode();
	      var body = bodyNode.body = [];
	      this.expect(types.braceL);

	      while (!this.match(types.braceR)) {
	        var _bodyNode = this.startNode();

	        if (this.match(types._import)) {
	          var lookahead = this.lookahead();

	          if (lookahead.value !== "type" && lookahead.value !== "typeof") {
	            this.unexpected(null, "Imports within a `declare module` body must always be `import type` or `import typeof`");
	          }

	          this.next();
	          this.parseImport(_bodyNode);
	        } else {
	          this.expectContextual("declare", "Only declares and type imports are allowed inside declare module");
	          _bodyNode = this.flowParseDeclare(_bodyNode, true);
	        }

	        body.push(_bodyNode);
	      }

	      this.expect(types.braceR);
	      this.finishNode(bodyNode, "BlockStatement");
	      var kind = null;
	      var hasModuleExport = false;
	      var errorMessage = "Found both `declare module.exports` and `declare export` in the same module. " + "Modules can only have 1 since they are either an ES module or they are a CommonJS module";
	      body.forEach(function (bodyElement) {
	        if (isEsModuleType(bodyElement)) {
	          if (kind === "CommonJS") {
	            _this2.unexpected(bodyElement.start, errorMessage);
	          }

	          kind = "ES";
	        } else if (bodyElement.type === "DeclareModuleExports") {
	          if (hasModuleExport) {
	            _this2.unexpected(bodyElement.start, "Duplicate `declare module.exports` statement");
	          }

	          if (kind === "ES") _this2.unexpected(bodyElement.start, errorMessage);
	          kind = "CommonJS";
	          hasModuleExport = true;
	        }
	      });
	      node.kind = kind || "CommonJS";
	      return this.finishNode(node, "DeclareModule");
	    };

	    _proto.flowParseDeclareExportDeclaration = function flowParseDeclareExportDeclaration(node, insideModule) {
	      this.expect(types._export);

	      if (this.eat(types._default)) {
	        if (this.match(types._function) || this.match(types._class)) {
	          node.declaration = this.flowParseDeclare(this.startNode());
	        } else {
	          node.declaration = this.flowParseType();
	          this.semicolon();
	        }

	        node.default = true;
	        return this.finishNode(node, "DeclareExportDeclaration");
	      } else {
	        if (this.match(types._const) || this.match(types._let) || (this.isContextual("type") || this.isContextual("interface")) && !insideModule) {
	          var label = this.state.value;
	          var suggestion = exportSuggestions[label];
	          this.unexpected(this.state.start, "`declare export " + label + "` is not supported. Use `" + suggestion + "` instead");
	        }

	        if (this.match(types._var) || this.match(types._function) || this.match(types._class) || this.isContextual("opaque")) {
	            node.declaration = this.flowParseDeclare(this.startNode());
	            node.default = false;
	            return this.finishNode(node, "DeclareExportDeclaration");
	          } else if (this.match(types.star) || this.match(types.braceL) || this.isContextual("interface") || this.isContextual("type") || this.isContextual("opaque")) {
	            node = this.parseExport(node);

	            if (node.type === "ExportNamedDeclaration") {
	              node.type = "ExportDeclaration";
	              node.default = false;
	              delete node.exportKind;
	            }

	            node.type = "Declare" + node.type;
	            return node;
	          }
	      }

	      throw this.unexpected();
	    };

	    _proto.flowParseDeclareModuleExports = function flowParseDeclareModuleExports(node) {
	      this.expectContextual("module");
	      this.expect(types.dot);
	      this.expectContextual("exports");
	      node.typeAnnotation = this.flowParseTypeAnnotation();
	      this.semicolon();
	      return this.finishNode(node, "DeclareModuleExports");
	    };

	    _proto.flowParseDeclareTypeAlias = function flowParseDeclareTypeAlias(node) {
	      this.next();
	      this.flowParseTypeAlias(node);
	      return this.finishNode(node, "DeclareTypeAlias");
	    };

	    _proto.flowParseDeclareOpaqueType = function flowParseDeclareOpaqueType(node) {
	      this.next();
	      this.flowParseOpaqueType(node, true);
	      return this.finishNode(node, "DeclareOpaqueType");
	    };

	    _proto.flowParseDeclareInterface = function flowParseDeclareInterface(node) {
	      this.next();
	      this.flowParseInterfaceish(node);
	      return this.finishNode(node, "DeclareInterface");
	    };

	    _proto.flowParseInterfaceish = function flowParseInterfaceish(node, isClass) {
	      if (isClass === void 0) {
	        isClass = false;
	      }

	      node.id = this.flowParseRestrictedIdentifier(!isClass);

	      if (this.isRelational("<")) {
	        node.typeParameters = this.flowParseTypeParameterDeclaration();
	      } else {
	        node.typeParameters = null;
	      }

	      node.extends = [];
	      node.implements = [];
	      node.mixins = [];

	      if (this.eat(types._extends)) {
	        do {
	          node.extends.push(this.flowParseInterfaceExtends());
	        } while (!isClass && this.eat(types.comma));
	      }

	      if (this.isContextual("mixins")) {
	        this.next();

	        do {
	          node.mixins.push(this.flowParseInterfaceExtends());
	        } while (this.eat(types.comma));
	      }

	      if (this.isContextual("implements")) {
	        this.next();

	        do {
	          node.implements.push(this.flowParseInterfaceExtends());
	        } while (this.eat(types.comma));
	      }

	      node.body = this.flowParseObjectType(isClass, false, false, isClass);
	    };

	    _proto.flowParseInterfaceExtends = function flowParseInterfaceExtends() {
	      var node = this.startNode();
	      node.id = this.flowParseQualifiedTypeIdentifier();

	      if (this.isRelational("<")) {
	        node.typeParameters = this.flowParseTypeParameterInstantiation();
	      } else {
	        node.typeParameters = null;
	      }

	      return this.finishNode(node, "InterfaceExtends");
	    };

	    _proto.flowParseInterface = function flowParseInterface(node) {
	      this.flowParseInterfaceish(node);
	      return this.finishNode(node, "InterfaceDeclaration");
	    };

	    _proto.checkReservedType = function checkReservedType(word, startLoc) {
	      if (primitiveTypes.indexOf(word) > -1) {
	        this.raise(startLoc, "Cannot overwrite primitive type " + word);
	      }
	    };

	    _proto.flowParseRestrictedIdentifier = function flowParseRestrictedIdentifier(liberal) {
	      this.checkReservedType(this.state.value, this.state.start);
	      return this.parseIdentifier(liberal);
	    };

	    _proto.flowParseTypeAlias = function flowParseTypeAlias(node) {
	      node.id = this.flowParseRestrictedIdentifier();

	      if (this.isRelational("<")) {
	        node.typeParameters = this.flowParseTypeParameterDeclaration();
	      } else {
	        node.typeParameters = null;
	      }

	      node.right = this.flowParseTypeInitialiser(types.eq);
	      this.semicolon();
	      return this.finishNode(node, "TypeAlias");
	    };

	    _proto.flowParseOpaqueType = function flowParseOpaqueType(node, declare) {
	      this.expectContextual("type");
	      node.id = this.flowParseRestrictedIdentifier(true);

	      if (this.isRelational("<")) {
	        node.typeParameters = this.flowParseTypeParameterDeclaration();
	      } else {
	        node.typeParameters = null;
	      }

	      node.supertype = null;

	      if (this.match(types.colon)) {
	        node.supertype = this.flowParseTypeInitialiser(types.colon);
	      }

	      node.impltype = null;

	      if (!declare) {
	        node.impltype = this.flowParseTypeInitialiser(types.eq);
	      }

	      this.semicolon();
	      return this.finishNode(node, "OpaqueType");
	    };

	    _proto.flowParseTypeParameter = function flowParseTypeParameter(allowDefault, requireDefault) {
	      if (allowDefault === void 0) {
	        allowDefault = true;
	      }

	      if (requireDefault === void 0) {
	        requireDefault = false;
	      }

	      if (!allowDefault && requireDefault) {
	        throw new Error("Cannot disallow a default value (`allowDefault`) while also requiring it (`requireDefault`).");
	      }

	      var nodeStart = this.state.start;
	      var node = this.startNode();
	      var variance = this.flowParseVariance();
	      var ident = this.flowParseTypeAnnotatableIdentifier();
	      node.name = ident.name;
	      node.variance = variance;
	      node.bound = ident.typeAnnotation;

	      if (this.match(types.eq)) {
	        if (allowDefault) {
	          this.eat(types.eq);
	          node.default = this.flowParseType();
	        } else {
	          this.unexpected();
	        }
	      } else {
	        if (requireDefault) {
	          this.unexpected(nodeStart, "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.");
	        }
	      }

	      return this.finishNode(node, "TypeParameter");
	    };

	    _proto.flowParseTypeParameterDeclaration = function flowParseTypeParameterDeclaration(allowDefault) {
	      if (allowDefault === void 0) {
	        allowDefault = true;
	      }

	      var oldInType = this.state.inType;
	      var node = this.startNode();
	      node.params = [];
	      this.state.inType = true;

	      if (this.isRelational("<") || this.match(types.jsxTagStart)) {
	        this.next();
	      } else {
	        this.unexpected();
	      }

	      var defaultRequired = false;

	      do {
	        var typeParameter = this.flowParseTypeParameter(allowDefault, defaultRequired);
	        node.params.push(typeParameter);

	        if (typeParameter.default) {
	          defaultRequired = true;
	        }

	        if (!this.isRelational(">")) {
	          this.expect(types.comma);
	        }
	      } while (!this.isRelational(">"));

	      this.expectRelational(">");
	      this.state.inType = oldInType;
	      return this.finishNode(node, "TypeParameterDeclaration");
	    };

	    _proto.flowParseTypeParameterInstantiation = function flowParseTypeParameterInstantiation() {
	      var node = this.startNode();
	      var oldInType = this.state.inType;
	      node.params = [];
	      this.state.inType = true;
	      this.expectRelational("<");

	      while (!this.isRelational(">")) {
	        node.params.push(this.flowParseType());

	        if (!this.isRelational(">")) {
	          this.expect(types.comma);
	        }
	      }

	      this.expectRelational(">");
	      this.state.inType = oldInType;
	      return this.finishNode(node, "TypeParameterInstantiation");
	    };

	    _proto.flowParseInterfaceType = function flowParseInterfaceType() {
	      var node = this.startNode();
	      this.expectContextual("interface");
	      node.extends = [];

	      if (this.eat(types._extends)) {
	        do {
	          node.extends.push(this.flowParseInterfaceExtends());
	        } while (this.eat(types.comma));
	      }

	      node.body = this.flowParseObjectType(false, false, false, false);
	      return this.finishNode(node, "InterfaceTypeAnnotation");
	    };

	    _proto.flowParseObjectPropertyKey = function flowParseObjectPropertyKey() {
	      return this.match(types.num) || this.match(types.string) ? this.parseExprAtom() : this.parseIdentifier(true);
	    };

	    _proto.flowParseObjectTypeIndexer = function flowParseObjectTypeIndexer(node, isStatic, variance) {
	      node.static = isStatic;

	      if (this.lookahead().type === types.colon) {
	        node.id = this.flowParseObjectPropertyKey();
	        node.key = this.flowParseTypeInitialiser();
	      } else {
	        node.id = null;
	        node.key = this.flowParseType();
	      }

	      this.expect(types.bracketR);
	      node.value = this.flowParseTypeInitialiser();
	      node.variance = variance;
	      return this.finishNode(node, "ObjectTypeIndexer");
	    };

	    _proto.flowParseObjectTypeInternalSlot = function flowParseObjectTypeInternalSlot(node, isStatic) {
	      node.static = isStatic;
	      node.id = this.flowParseObjectPropertyKey();
	      this.expect(types.bracketR);
	      this.expect(types.bracketR);

	      if (this.isRelational("<") || this.match(types.parenL)) {
	        node.method = true;
	        node.optional = false;
	        node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.start, node.loc.start));
	      } else {
	        node.method = false;

	        if (this.eat(types.question)) {
	          node.optional = true;
	        }

	        node.value = this.flowParseTypeInitialiser();
	      }

	      return this.finishNode(node, "ObjectTypeInternalSlot");
	    };

	    _proto.flowParseObjectTypeMethodish = function flowParseObjectTypeMethodish(node) {
	      node.params = [];
	      node.rest = null;
	      node.typeParameters = null;

	      if (this.isRelational("<")) {
	        node.typeParameters = this.flowParseTypeParameterDeclaration(false);
	      }

	      this.expect(types.parenL);

	      while (!this.match(types.parenR) && !this.match(types.ellipsis)) {
	        node.params.push(this.flowParseFunctionTypeParam());

	        if (!this.match(types.parenR)) {
	          this.expect(types.comma);
	        }
	      }

	      if (this.eat(types.ellipsis)) {
	        node.rest = this.flowParseFunctionTypeParam();
	      }

	      this.expect(types.parenR);
	      node.returnType = this.flowParseTypeInitialiser();
	      return this.finishNode(node, "FunctionTypeAnnotation");
	    };

	    _proto.flowParseObjectTypeCallProperty = function flowParseObjectTypeCallProperty(node, isStatic) {
	      var valueNode = this.startNode();
	      node.static = isStatic;
	      node.value = this.flowParseObjectTypeMethodish(valueNode);
	      return this.finishNode(node, "ObjectTypeCallProperty");
	    };

	    _proto.flowParseObjectType = function flowParseObjectType(allowStatic, allowExact, allowSpread, allowProto) {
	      var oldInType = this.state.inType;
	      this.state.inType = true;
	      var nodeStart = this.startNode();
	      nodeStart.callProperties = [];
	      nodeStart.properties = [];
	      nodeStart.indexers = [];
	      nodeStart.internalSlots = [];
	      var endDelim;
	      var exact;

	      if (allowExact && this.match(types.braceBarL)) {
	        this.expect(types.braceBarL);
	        endDelim = types.braceBarR;
	        exact = true;
	      } else {
	        this.expect(types.braceL);
	        endDelim = types.braceR;
	        exact = false;
	      }

	      nodeStart.exact = exact;

	      while (!this.match(endDelim)) {
	        var isStatic = false;
	        var protoStart = null;
	        var node = this.startNode();

	        if (allowProto && this.isContextual("proto")) {
	          var lookahead = this.lookahead();

	          if (lookahead.type !== types.colon && lookahead.type !== types.question) {
	            this.next();
	            protoStart = this.state.start;
	            allowStatic = false;
	          }
	        }

	        if (allowStatic && this.isContextual("static")) {
	          var _lookahead = this.lookahead();

	          if (_lookahead.type !== types.colon && _lookahead.type !== types.question) {
	            this.next();
	            isStatic = true;
	          }
	        }

	        var variance = this.flowParseVariance();

	        if (this.eat(types.bracketL)) {
	          if (protoStart != null) {
	            this.unexpected(protoStart);
	          }

	          if (this.eat(types.bracketL)) {
	            if (variance) {
	              this.unexpected(variance.start);
	            }

	            nodeStart.internalSlots.push(this.flowParseObjectTypeInternalSlot(node, isStatic));
	          } else {
	            nodeStart.indexers.push(this.flowParseObjectTypeIndexer(node, isStatic, variance));
	          }
	        } else if (this.match(types.parenL) || this.isRelational("<")) {
	          if (protoStart != null) {
	            this.unexpected(protoStart);
	          }

	          if (variance) {
	            this.unexpected(variance.start);
	          }

	          nodeStart.callProperties.push(this.flowParseObjectTypeCallProperty(node, isStatic));
	        } else {
	          var kind = "init";

	          if (this.isContextual("get") || this.isContextual("set")) {
	            var _lookahead2 = this.lookahead();

	            if (_lookahead2.type === types.name || _lookahead2.type === types.string || _lookahead2.type === types.num) {
	              kind = this.state.value;
	              this.next();
	            }
	          }

	          nodeStart.properties.push(this.flowParseObjectTypeProperty(node, isStatic, protoStart, variance, kind, allowSpread));
	        }

	        this.flowObjectTypeSemicolon();
	      }

	      this.expect(endDelim);
	      var out = this.finishNode(nodeStart, "ObjectTypeAnnotation");
	      this.state.inType = oldInType;
	      return out;
	    };

	    _proto.flowParseObjectTypeProperty = function flowParseObjectTypeProperty(node, isStatic, protoStart, variance, kind, allowSpread) {
	      if (this.match(types.ellipsis)) {
	        if (!allowSpread) {
	          this.unexpected(null, "Spread operator cannot appear in class or interface definitions");
	        }

	        if (protoStart != null) {
	          this.unexpected(protoStart);
	        }

	        if (variance) {
	          this.unexpected(variance.start, "Spread properties cannot have variance");
	        }

	        this.expect(types.ellipsis);
	        node.argument = this.flowParseType();
	        return this.finishNode(node, "ObjectTypeSpreadProperty");
	      } else {
	        node.key = this.flowParseObjectPropertyKey();
	        node.static = isStatic;
	        node.proto = protoStart != null;
	        node.kind = kind;
	        var optional = false;

	        if (this.isRelational("<") || this.match(types.parenL)) {
	          node.method = true;

	          if (protoStart != null) {
	            this.unexpected(protoStart);
	          }

	          if (variance) {
	            this.unexpected(variance.start);
	          }

	          node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.start, node.loc.start));

	          if (kind === "get" || kind === "set") {
	            this.flowCheckGetterSetterParams(node);
	          }
	        } else {
	          if (kind !== "init") this.unexpected();
	          node.method = false;

	          if (this.eat(types.question)) {
	            optional = true;
	          }

	          node.value = this.flowParseTypeInitialiser();
	          node.variance = variance;
	        }

	        node.optional = optional;
	        return this.finishNode(node, "ObjectTypeProperty");
	      }
	    };

	    _proto.flowCheckGetterSetterParams = function flowCheckGetterSetterParams(property) {
	      var paramCount = property.kind === "get" ? 0 : 1;
	      var start = property.start;
	      var length = property.value.params.length + (property.value.rest ? 1 : 0);

	      if (length !== paramCount) {
	        if (property.kind === "get") {
	          this.raise(start, "getter must not have any formal parameters");
	        } else {
	          this.raise(start, "setter must have exactly one formal parameter");
	        }
	      }

	      if (property.kind === "set" && property.value.rest) {
	        this.raise(start, "setter function argument must not be a rest parameter");
	      }
	    };

	    _proto.flowObjectTypeSemicolon = function flowObjectTypeSemicolon() {
	      if (!this.eat(types.semi) && !this.eat(types.comma) && !this.match(types.braceR) && !this.match(types.braceBarR)) {
	        this.unexpected();
	      }
	    };

	    _proto.flowParseQualifiedTypeIdentifier = function flowParseQualifiedTypeIdentifier(startPos, startLoc, id) {
	      startPos = startPos || this.state.start;
	      startLoc = startLoc || this.state.startLoc;
	      var node = id || this.parseIdentifier();

	      while (this.eat(types.dot)) {
	        var node2 = this.startNodeAt(startPos, startLoc);
	        node2.qualification = node;
	        node2.id = this.parseIdentifier();
	        node = this.finishNode(node2, "QualifiedTypeIdentifier");
	      }

	      return node;
	    };

	    _proto.flowParseGenericType = function flowParseGenericType(startPos, startLoc, id) {
	      var node = this.startNodeAt(startPos, startLoc);
	      node.typeParameters = null;
	      node.id = this.flowParseQualifiedTypeIdentifier(startPos, startLoc, id);

	      if (this.isRelational("<")) {
	        node.typeParameters = this.flowParseTypeParameterInstantiation();
	      }

	      return this.finishNode(node, "GenericTypeAnnotation");
	    };

	    _proto.flowParseTypeofType = function flowParseTypeofType() {
	      var node = this.startNode();
	      this.expect(types._typeof);
	      node.argument = this.flowParsePrimaryType();
	      return this.finishNode(node, "TypeofTypeAnnotation");
	    };

	    _proto.flowParseTupleType = function flowParseTupleType() {
	      var node = this.startNode();
	      node.types = [];
	      this.expect(types.bracketL);

	      while (this.state.pos < this.input.length && !this.match(types.bracketR)) {
	        node.types.push(this.flowParseType());
	        if (this.match(types.bracketR)) break;
	        this.expect(types.comma);
	      }

	      this.expect(types.bracketR);
	      return this.finishNode(node, "TupleTypeAnnotation");
	    };

	    _proto.flowParseFunctionTypeParam = function flowParseFunctionTypeParam() {
	      var name = null;
	      var optional = false;
	      var typeAnnotation = null;
	      var node = this.startNode();
	      var lh = this.lookahead();

	      if (lh.type === types.colon || lh.type === types.question) {
	        name = this.parseIdentifier();

	        if (this.eat(types.question)) {
	          optional = true;
	        }

	        typeAnnotation = this.flowParseTypeInitialiser();
	      } else {
	        typeAnnotation = this.flowParseType();
	      }

	      node.name = name;
	      node.optional = optional;
	      node.typeAnnotation = typeAnnotation;
	      return this.finishNode(node, "FunctionTypeParam");
	    };

	    _proto.reinterpretTypeAsFunctionTypeParam = function reinterpretTypeAsFunctionTypeParam(type) {
	      var node = this.startNodeAt(type.start, type.loc.start);
	      node.name = null;
	      node.optional = false;
	      node.typeAnnotation = type;
	      return this.finishNode(node, "FunctionTypeParam");
	    };

	    _proto.flowParseFunctionTypeParams = function flowParseFunctionTypeParams(params) {
	      if (params === void 0) {
	        params = [];
	      }

	      var rest = null;

	      while (!this.match(types.parenR) && !this.match(types.ellipsis)) {
	        params.push(this.flowParseFunctionTypeParam());

	        if (!this.match(types.parenR)) {
	          this.expect(types.comma);
	        }
	      }

	      if (this.eat(types.ellipsis)) {
	        rest = this.flowParseFunctionTypeParam();
	      }

	      return {
	        params: params,
	        rest: rest
	      };
	    };

	    _proto.flowIdentToTypeAnnotation = function flowIdentToTypeAnnotation(startPos, startLoc, node, id) {
	      switch (id.name) {
	        case "any":
	          return this.finishNode(node, "AnyTypeAnnotation");

	        case "void":
	          return this.finishNode(node, "VoidTypeAnnotation");

	        case "bool":
	        case "boolean":
	          return this.finishNode(node, "BooleanTypeAnnotation");

	        case "mixed":
	          return this.finishNode(node, "MixedTypeAnnotation");

	        case "empty":
	          return this.finishNode(node, "EmptyTypeAnnotation");

	        case "number":
	          return this.finishNode(node, "NumberTypeAnnotation");

	        case "string":
	          return this.finishNode(node, "StringTypeAnnotation");

	        default:
	          return this.flowParseGenericType(startPos, startLoc, id);
	      }
	    };

	    _proto.flowParsePrimaryType = function flowParsePrimaryType() {
	      var startPos = this.state.start;
	      var startLoc = this.state.startLoc;
	      var node = this.startNode();
	      var tmp;
	      var type;
	      var isGroupedType = false;
	      var oldNoAnonFunctionType = this.state.noAnonFunctionType;

	      switch (this.state.type) {
	        case types.name:
	          if (this.isContextual("interface")) {
	            return this.flowParseInterfaceType();
	          }

	          return this.flowIdentToTypeAnnotation(startPos, startLoc, node, this.parseIdentifier());

	        case types.braceL:
	          return this.flowParseObjectType(false, false, true, false);

	        case types.braceBarL:
	          return this.flowParseObjectType(false, true, true, false);

	        case types.bracketL:
	          return this.flowParseTupleType();

	        case types.relational:
	          if (this.state.value === "<") {
	            node.typeParameters = this.flowParseTypeParameterDeclaration(false);
	            this.expect(types.parenL);
	            tmp = this.flowParseFunctionTypeParams();
	            node.params = tmp.params;
	            node.rest = tmp.rest;
	            this.expect(types.parenR);
	            this.expect(types.arrow);
	            node.returnType = this.flowParseType();
	            return this.finishNode(node, "FunctionTypeAnnotation");
	          }

	          break;

	        case types.parenL:
	          this.next();

	          if (!this.match(types.parenR) && !this.match(types.ellipsis)) {
	            if (this.match(types.name)) {
	              var token = this.lookahead().type;
	              isGroupedType = token !== types.question && token !== types.colon;
	            } else {
	              isGroupedType = true;
	            }
	          }

	          if (isGroupedType) {
	            this.state.noAnonFunctionType = false;
	            type = this.flowParseType();
	            this.state.noAnonFunctionType = oldNoAnonFunctionType;

	            if (this.state.noAnonFunctionType || !(this.match(types.comma) || this.match(types.parenR) && this.lookahead().type === types.arrow)) {
	              this.expect(types.parenR);
	              return type;
	            } else {
	              this.eat(types.comma);
	            }
	          }

	          if (type) {
	            tmp = this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(type)]);
	          } else {
	            tmp = this.flowParseFunctionTypeParams();
	          }

	          node.params = tmp.params;
	          node.rest = tmp.rest;
	          this.expect(types.parenR);
	          this.expect(types.arrow);
	          node.returnType = this.flowParseType();
	          node.typeParameters = null;
	          return this.finishNode(node, "FunctionTypeAnnotation");

	        case types.string:
	          return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");

	        case types._true:
	        case types._false:
	          node.value = this.match(types._true);
	          this.next();
	          return this.finishNode(node, "BooleanLiteralTypeAnnotation");

	        case types.plusMin:
	          if (this.state.value === "-") {
	            this.next();

	            if (!this.match(types.num)) {
	              this.unexpected(null, "Unexpected token, expected \"number\"");
	            }

	            return this.parseLiteral(-this.state.value, "NumberLiteralTypeAnnotation", node.start, node.loc.start);
	          }

	          this.unexpected();

	        case types.num:
	          return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation");

	        case types._null:
	          this.next();
	          return this.finishNode(node, "NullLiteralTypeAnnotation");

	        case types._this:
	          this.next();
	          return this.finishNode(node, "ThisTypeAnnotation");

	        case types.star:
	          this.next();
	          return this.finishNode(node, "ExistsTypeAnnotation");

	        default:
	          if (this.state.type.keyword === "typeof") {
	            return this.flowParseTypeofType();
	          }

	      }

	      throw this.unexpected();
	    };

	    _proto.flowParsePostfixType = function flowParsePostfixType() {
	      var startPos = this.state.start,
	          startLoc = this.state.startLoc;
	      var type = this.flowParsePrimaryType();

	      while (!this.canInsertSemicolon() && this.match(types.bracketL)) {
	        var node = this.startNodeAt(startPos, startLoc);
	        node.elementType = type;
	        this.expect(types.bracketL);
	        this.expect(types.bracketR);
	        type = this.finishNode(node, "ArrayTypeAnnotation");
	      }

	      return type;
	    };

	    _proto.flowParsePrefixType = function flowParsePrefixType() {
	      var node = this.startNode();

	      if (this.eat(types.question)) {
	        node.typeAnnotation = this.flowParsePrefixType();
	        return this.finishNode(node, "NullableTypeAnnotation");
	      } else {
	        return this.flowParsePostfixType();
	      }
	    };

	    _proto.flowParseAnonFunctionWithoutParens = function flowParseAnonFunctionWithoutParens() {
	      var param = this.flowParsePrefixType();

	      if (!this.state.noAnonFunctionType && this.eat(types.arrow)) {
	        var node = this.startNodeAt(param.start, param.loc.start);
	        node.params = [this.reinterpretTypeAsFunctionTypeParam(param)];
	        node.rest = null;
	        node.returnType = this.flowParseType();
	        node.typeParameters = null;
	        return this.finishNode(node, "FunctionTypeAnnotation");
	      }

	      return param;
	    };

	    _proto.flowParseIntersectionType = function flowParseIntersectionType() {
	      var node = this.startNode();
	      this.eat(types.bitwiseAND);
	      var type = this.flowParseAnonFunctionWithoutParens();
	      node.types = [type];

	      while (this.eat(types.bitwiseAND)) {
	        node.types.push(this.flowParseAnonFunctionWithoutParens());
	      }

	      return node.types.length === 1 ? type : this.finishNode(node, "IntersectionTypeAnnotation");
	    };

	    _proto.flowParseUnionType = function flowParseUnionType() {
	      var node = this.startNode();
	      this.eat(types.bitwiseOR);
	      var type = this.flowParseIntersectionType();
	      node.types = [type];

	      while (this.eat(types.bitwiseOR)) {
	        node.types.push(this.flowParseIntersectionType());
	      }

	      return node.types.length === 1 ? type : this.finishNode(node, "UnionTypeAnnotation");
	    };

	    _proto.flowParseType = function flowParseType() {
	      var oldInType = this.state.inType;
	      this.state.inType = true;
	      var type = this.flowParseUnionType();
	      this.state.inType = oldInType;
	      this.state.exprAllowed = this.state.exprAllowed || this.state.noAnonFunctionType;
	      return type;
	    };

	    _proto.flowParseTypeAnnotation = function flowParseTypeAnnotation() {
	      var node = this.startNode();
	      node.typeAnnotation = this.flowParseTypeInitialiser();
	      return this.finishNode(node, "TypeAnnotation");
	    };

	    _proto.flowParseTypeAnnotatableIdentifier = function flowParseTypeAnnotatableIdentifier(allowPrimitiveOverride) {
	      var ident = allowPrimitiveOverride ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();

	      if (this.match(types.colon)) {
	        ident.typeAnnotation = this.flowParseTypeAnnotation();
	        this.finishNode(ident, ident.type);
	      }

	      return ident;
	    };

	    _proto.typeCastToParameter = function typeCastToParameter(node) {
	      node.expression.typeAnnotation = node.typeAnnotation;
	      return this.finishNodeAt(node.expression, node.expression.type, node.typeAnnotation.end, node.typeAnnotation.loc.end);
	    };

	    _proto.flowParseVariance = function flowParseVariance() {
	      var variance = null;

	      if (this.match(types.plusMin)) {
	        variance = this.startNode();

	        if (this.state.value === "+") {
	          variance.kind = "plus";
	        } else {
	          variance.kind = "minus";
	        }

	        this.next();
	        this.finishNode(variance, "Variance");
	      }

	      return variance;
	    };

	    _proto.parseFunctionBody = function parseFunctionBody(node, allowExpressionBody) {
	      var _this3 = this;

	      if (allowExpressionBody) {
	        return this.forwardNoArrowParamsConversionAt(node, function () {
	          return _superClass.prototype.parseFunctionBody.call(_this3, node, true);
	        });
	      }

	      return _superClass.prototype.parseFunctionBody.call(this, node, false);
	    };

	    _proto.parseFunctionBodyAndFinish = function parseFunctionBodyAndFinish(node, type, allowExpressionBody) {
	      if (!allowExpressionBody && this.match(types.colon)) {
	        var typeNode = this.startNode();

	        var _this$flowParseTypeAn2 = this.flowParseTypeAndPredicateInitialiser();

	        typeNode.typeAnnotation = _this$flowParseTypeAn2[0];
	        node.predicate = _this$flowParseTypeAn2[1];
	        node.returnType = typeNode.typeAnnotation ? this.finishNode(typeNode, "TypeAnnotation") : null;
	      }

	      _superClass.prototype.parseFunctionBodyAndFinish.call(this, node, type, allowExpressionBody);
	    };

	    _proto.parseStatement = function parseStatement(declaration, topLevel) {
	      if (this.state.strict && this.match(types.name) && this.state.value === "interface") {
	        var node = this.startNode();
	        this.next();
	        return this.flowParseInterface(node);
	      } else {
	        var stmt = _superClass.prototype.parseStatement.call(this, declaration, topLevel);

	        if (this.flowPragma === undefined && !this.isValidDirective(stmt)) {
	          this.flowPragma = null;
	        }

	        return stmt;
	      }
	    };

	    _proto.parseExpressionStatement = function parseExpressionStatement(node, expr) {
	      if (expr.type === "Identifier") {
	        if (expr.name === "declare") {
	          if (this.match(types._class) || this.match(types.name) || this.match(types._function) || this.match(types._var) || this.match(types._export)) {
	            return this.flowParseDeclare(node);
	          }
	        } else if (this.match(types.name)) {
	          if (expr.name === "interface") {
	            return this.flowParseInterface(node);
	          } else if (expr.name === "type") {
	            return this.flowParseTypeAlias(node);
	          } else if (expr.name === "opaque") {
	            return this.flowParseOpaqueType(node, false);
	          }
	        }
	      }

	      return _superClass.prototype.parseExpressionStatement.call(this, node, expr);
	    };

	    _proto.shouldParseExportDeclaration = function shouldParseExportDeclaration() {
	      return this.isContextual("type") || this.isContextual("interface") || this.isContextual("opaque") || _superClass.prototype.shouldParseExportDeclaration.call(this);
	    };

	    _proto.isExportDefaultSpecifier = function isExportDefaultSpecifier() {
	      if (this.match(types.name) && (this.state.value === "type" || this.state.value === "interface" || this.state.value == "opaque")) {
	        return false;
	      }

	      return _superClass.prototype.isExportDefaultSpecifier.call(this);
	    };

	    _proto.parseConditional = function parseConditional(expr, noIn, startPos, startLoc, refNeedsArrowPos) {
	      var _this4 = this;

	      if (!this.match(types.question)) return expr;

	      if (refNeedsArrowPos) {
	        var _state = this.state.clone();

	        try {
	          return _superClass.prototype.parseConditional.call(this, expr, noIn, startPos, startLoc);
	        } catch (err) {
	          if (err instanceof SyntaxError) {
	            this.state = _state;
	            refNeedsArrowPos.start = err.pos || this.state.start;
	            return expr;
	          } else {
	            throw err;
	          }
	        }
	      }

	      this.expect(types.question);
	      var state = this.state.clone();
	      var originalNoArrowAt = this.state.noArrowAt;
	      var node = this.startNodeAt(startPos, startLoc);

	      var _this$tryParseConditi = this.tryParseConditionalConsequent(),
	          consequent = _this$tryParseConditi.consequent,
	          failed = _this$tryParseConditi.failed;

	      var _this$getArrowLikeExp = this.getArrowLikeExpressions(consequent),
	          valid = _this$getArrowLikeExp[0],
	          invalid = _this$getArrowLikeExp[1];

	      if (failed || invalid.length > 0) {
	        var noArrowAt = originalNoArrowAt.concat();

	        if (invalid.length > 0) {
	          this.state = state;
	          this.state.noArrowAt = noArrowAt;

	          for (var i = 0; i < invalid.length; i++) {
	            noArrowAt.push(invalid[i].start);
	          }

	          var _this$tryParseConditi2 = this.tryParseConditionalConsequent();

	          consequent = _this$tryParseConditi2.consequent;
	          failed = _this$tryParseConditi2.failed;

	          var _this$getArrowLikeExp2 = this.getArrowLikeExpressions(consequent);

	          valid = _this$getArrowLikeExp2[0];
	          invalid = _this$getArrowLikeExp2[1];
	        }

	        if (failed && valid.length > 1) {
	          this.raise(state.start, "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.");
	        }

	        if (failed && valid.length === 1) {
	          this.state = state;
	          this.state.noArrowAt = noArrowAt.concat(valid[0].start);

	          var _this$tryParseConditi3 = this.tryParseConditionalConsequent();

	          consequent = _this$tryParseConditi3.consequent;
	          failed = _this$tryParseConditi3.failed;
	        }

	        this.getArrowLikeExpressions(consequent, true);
	      }

	      this.state.noArrowAt = originalNoArrowAt;
	      this.expect(types.colon);
	      node.test = expr;
	      node.consequent = consequent;
	      node.alternate = this.forwardNoArrowParamsConversionAt(node, function () {
	        return _this4.parseMaybeAssign(noIn, undefined, undefined, undefined);
	      });
	      return this.finishNode(node, "ConditionalExpression");
	    };

	    _proto.tryParseConditionalConsequent = function tryParseConditionalConsequent() {
	      this.state.noArrowParamsConversionAt.push(this.state.start);
	      var consequent = this.parseMaybeAssign();
	      var failed = !this.match(types.colon);
	      this.state.noArrowParamsConversionAt.pop();
	      return {
	        consequent: consequent,
	        failed: failed
	      };
	    };

	    _proto.getArrowLikeExpressions = function getArrowLikeExpressions(node, disallowInvalid) {
	      var _this5 = this;

	      var stack = [node];
	      var arrows = [];

	      while (stack.length !== 0) {
	        var _node = stack.pop();

	        if (_node.type === "ArrowFunctionExpression") {
	          if (_node.typeParameters || !_node.returnType) {
	            this.toAssignableList(_node.params, true, "arrow function parameters");

	            _superClass.prototype.checkFunctionNameAndParams.call(this, _node, true);
	          } else {
	            arrows.push(_node);
	          }

	          stack.push(_node.body);
	        } else if (_node.type === "ConditionalExpression") {
	          stack.push(_node.consequent);
	          stack.push(_node.alternate);
	        }
	      }

	      if (disallowInvalid) {
	        for (var i = 0; i < arrows.length; i++) {
	          this.toAssignableList(node.params, true, "arrow function parameters");
	        }

	        return [arrows, []];
	      }

	      return partition(arrows, function (node) {
	        try {
	          _this5.toAssignableList(node.params, true, "arrow function parameters");

	          return true;
	        } catch (err) {
	          return false;
	        }
	      });
	    };

	    _proto.forwardNoArrowParamsConversionAt = function forwardNoArrowParamsConversionAt(node, parse) {
	      var result;

	      if (this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {
	        this.state.noArrowParamsConversionAt.push(this.state.start);
	        result = parse();
	        this.state.noArrowParamsConversionAt.pop();
	      } else {
	        result = parse();
	      }

	      return result;
	    };

	    _proto.parseParenItem = function parseParenItem(node, startPos, startLoc) {
	      node = _superClass.prototype.parseParenItem.call(this, node, startPos, startLoc);

	      if (this.eat(types.question)) {
	        node.optional = true;
	      }

	      if (this.match(types.colon)) {
	        var typeCastNode = this.startNodeAt(startPos, startLoc);
	        typeCastNode.expression = node;
	        typeCastNode.typeAnnotation = this.flowParseTypeAnnotation();
	        return this.finishNode(typeCastNode, "TypeCastExpression");
	      }

	      return node;
	    };

	    _proto.assertModuleNodeAllowed = function assertModuleNodeAllowed(node) {
	      if (node.type === "ImportDeclaration" && (node.importKind === "type" || node.importKind === "typeof") || node.type === "ExportNamedDeclaration" && node.exportKind === "type" || node.type === "ExportAllDeclaration" && node.exportKind === "type") {
	        return;
	      }

	      _superClass.prototype.assertModuleNodeAllowed.call(this, node);
	    };

	    _proto.parseExport = function parseExport(node) {
	      node = _superClass.prototype.parseExport.call(this, node);

	      if (node.type === "ExportNamedDeclaration" || node.type === "ExportAllDeclaration") {
	        node.exportKind = node.exportKind || "value";
	      }

	      return node;
	    };

	    _proto.parseExportDeclaration = function parseExportDeclaration(node) {
	      if (this.isContextual("type")) {
	        node.exportKind = "type";
	        var declarationNode = this.startNode();
	        this.next();

	        if (this.match(types.braceL)) {
	          node.specifiers = this.parseExportSpecifiers();
	          this.parseExportFrom(node);
	          return null;
	        } else {
	          return this.flowParseTypeAlias(declarationNode);
	        }
	      } else if (this.isContextual("opaque")) {
	        node.exportKind = "type";

	        var _declarationNode = this.startNode();

	        this.next();
	        return this.flowParseOpaqueType(_declarationNode, false);
	      } else if (this.isContextual("interface")) {
	        node.exportKind = "type";

	        var _declarationNode2 = this.startNode();

	        this.next();
	        return this.flowParseInterface(_declarationNode2);
	      } else {
	        return _superClass.prototype.parseExportDeclaration.call(this, node);
	      }
	    };

	    _proto.shouldParseExportStar = function shouldParseExportStar() {
	      return _superClass.prototype.shouldParseExportStar.call(this) || this.isContextual("type") && this.lookahead().type === types.star;
	    };

	    _proto.parseExportStar = function parseExportStar(node) {
	      if (this.eatContextual("type")) {
	        node.exportKind = "type";
	      }

	      return _superClass.prototype.parseExportStar.call(this, node);
	    };

	    _proto.parseExportNamespace = function parseExportNamespace(node) {
	      if (node.exportKind === "type") {
	        this.unexpected();
	      }

	      return _superClass.prototype.parseExportNamespace.call(this, node);
	    };

	    _proto.parseClassId = function parseClassId(node, isStatement, optionalId) {
	      _superClass.prototype.parseClassId.call(this, node, isStatement, optionalId);

	      if (this.isRelational("<")) {
	        node.typeParameters = this.flowParseTypeParameterDeclaration();
	      }
	    };

	    _proto.isKeyword = function isKeyword$$1(name) {
	      if (this.state.inType && name === "void") {
	        return false;
	      } else {
	        return _superClass.prototype.isKeyword.call(this, name);
	      }
	    };

	    _proto.readToken = function readToken(code) {
	      var next = this.input.charCodeAt(this.state.pos + 1);

	      if (this.state.inType && (code === 62 || code === 60)) {
	        return this.finishOp(types.relational, 1);
	      } else if (isIteratorStart(code, next)) {
	        this.state.isIterator = true;
	        return _superClass.prototype.readWord.call(this);
	      } else {
	        return _superClass.prototype.readToken.call(this, code);
	      }
	    };

	    _proto.toAssignable = function toAssignable(node, isBinding, contextDescription) {
	      if (node.type === "TypeCastExpression") {
	        return _superClass.prototype.toAssignable.call(this, this.typeCastToParameter(node), isBinding, contextDescription);
	      } else {
	        return _superClass.prototype.toAssignable.call(this, node, isBinding, contextDescription);
	      }
	    };

	    _proto.toAssignableList = function toAssignableList(exprList, isBinding, contextDescription) {
	      for (var i = 0; i < exprList.length; i++) {
	        var expr = exprList[i];

	        if (expr && expr.type === "TypeCastExpression") {
	          exprList[i] = this.typeCastToParameter(expr);
	        }
	      }

	      return _superClass.prototype.toAssignableList.call(this, exprList, isBinding, contextDescription);
	    };

	    _proto.toReferencedList = function toReferencedList(exprList) {
	      for (var i = 0; i < exprList.length; i++) {
	        var expr = exprList[i];

	        if (expr && expr._exprListItem && expr.type === "TypeCastExpression") {
	          this.raise(expr.start, "Unexpected type cast");
	        }
	      }

	      return exprList;
	    };

	    _proto.parseExprListItem = function parseExprListItem(allowEmpty, refShorthandDefaultPos, refNeedsArrowPos) {
	      var container = this.startNode();

	      var node = _superClass.prototype.parseExprListItem.call(this, allowEmpty, refShorthandDefaultPos, refNeedsArrowPos);

	      if (this.match(types.colon)) {
	        container._exprListItem = true;
	        container.expression = node;
	        container.typeAnnotation = this.flowParseTypeAnnotation();
	        return this.finishNode(container, "TypeCastExpression");
	      } else {
	        return node;
	      }
	    };

	    _proto.checkLVal = function checkLVal(expr, isBinding, checkClashes, contextDescription) {
	      if (expr.type !== "TypeCastExpression") {
	        return _superClass.prototype.checkLVal.call(this, expr, isBinding, checkClashes, contextDescription);
	      }
	    };

	    _proto.parseClassProperty = function parseClassProperty(node) {
	      if (this.match(types.colon)) {
	        node.typeAnnotation = this.flowParseTypeAnnotation();
	      }

	      return _superClass.prototype.parseClassProperty.call(this, node);
	    };

	    _proto.parseClassPrivateProperty = function parseClassPrivateProperty(node) {
	      if (this.match(types.colon)) {
	        node.typeAnnotation = this.flowParseTypeAnnotation();
	      }

	      return _superClass.prototype.parseClassPrivateProperty.call(this, node);
	    };

	    _proto.isClassMethod = function isClassMethod() {
	      return this.isRelational("<") || _superClass.prototype.isClassMethod.call(this);
	    };

	    _proto.isClassProperty = function isClassProperty() {
	      return this.match(types.colon) || _superClass.prototype.isClassProperty.call(this);
	    };

	    _proto.isNonstaticConstructor = function isNonstaticConstructor(method) {
	      return !this.match(types.colon) && _superClass.prototype.isNonstaticConstructor.call(this, method);
	    };

	    _proto.pushClassMethod = function pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor) {
	      if (method.variance) {
	        this.unexpected(method.variance.start);
	      }

	      delete method.variance;

	      if (this.isRelational("<")) {
	        method.typeParameters = this.flowParseTypeParameterDeclaration(false);
	      }

	      _superClass.prototype.pushClassMethod.call(this, classBody, method, isGenerator, isAsync, isConstructor);
	    };

	    _proto.pushClassPrivateMethod = function pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
	      if (method.variance) {
	        this.unexpected(method.variance.start);
	      }

	      delete method.variance;

	      if (this.isRelational("<")) {
	        method.typeParameters = this.flowParseTypeParameterDeclaration();
	      }

	      _superClass.prototype.pushClassPrivateMethod.call(this, classBody, method, isGenerator, isAsync);
	    };

	    _proto.parseClassSuper = function parseClassSuper(node) {
	      _superClass.prototype.parseClassSuper.call(this, node);

	      if (node.superClass && this.isRelational("<")) {
	        node.superTypeParameters = this.flowParseTypeParameterInstantiation();
	      }

	      if (this.isContextual("implements")) {
	        this.next();
	        var implemented = node.implements = [];

	        do {
	          var _node2 = this.startNode();

	          _node2.id = this.flowParseRestrictedIdentifier(true);

	          if (this.isRelational("<")) {
	            _node2.typeParameters = this.flowParseTypeParameterInstantiation();
	          } else {
	            _node2.typeParameters = null;
	          }

	          implemented.push(this.finishNode(_node2, "ClassImplements"));
	        } while (this.eat(types.comma));
	      }
	    };

	    _proto.parsePropertyName = function parsePropertyName(node) {
	      var variance = this.flowParseVariance();

	      var key = _superClass.prototype.parsePropertyName.call(this, node);

	      node.variance = variance;
	      return key;
	    };

	    _proto.parseObjPropValue = function parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, refShorthandDefaultPos, containsEsc) {
	      if (prop.variance) {
	        this.unexpected(prop.variance.start);
	      }

	      delete prop.variance;
	      var typeParameters;

	      if (this.isRelational("<")) {
	        typeParameters = this.flowParseTypeParameterDeclaration(false);
	        if (!this.match(types.parenL)) this.unexpected();
	      }

	      _superClass.prototype.parseObjPropValue.call(this, prop, startPos, startLoc, isGenerator, isAsync, isPattern, refShorthandDefaultPos, containsEsc);

	      if (typeParameters) {
	        (prop.value || prop).typeParameters = typeParameters;
	      }
	    };

	    _proto.parseAssignableListItemTypes = function parseAssignableListItemTypes(param) {
	      if (this.eat(types.question)) {
	        if (param.type !== "Identifier") {
	          throw this.raise(param.start, "A binding pattern parameter cannot be optional in an implementation signature.");
	        }

	        param.optional = true;
	      }

	      if (this.match(types.colon)) {
	        param.typeAnnotation = this.flowParseTypeAnnotation();
	      }

	      this.finishNode(param, param.type);
	      return param;
	    };

	    _proto.parseMaybeDefault = function parseMaybeDefault(startPos, startLoc, left) {
	      var node = _superClass.prototype.parseMaybeDefault.call(this, startPos, startLoc, left);

	      if (node.type === "AssignmentPattern" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {
	        this.raise(node.typeAnnotation.start, "Type annotations must come before default assignments, " + "e.g. instead of `age = 25: number` use `age: number = 25`");
	      }

	      return node;
	    };

	    _proto.shouldParseDefaultImport = function shouldParseDefaultImport(node) {
	      if (!hasTypeImportKind(node)) {
	        return _superClass.prototype.shouldParseDefaultImport.call(this, node);
	      }

	      return isMaybeDefaultImport(this.state);
	    };

	    _proto.parseImportSpecifierLocal = function parseImportSpecifierLocal(node, specifier, type, contextDescription) {
	      specifier.local = hasTypeImportKind(node) ? this.flowParseRestrictedIdentifier(true) : this.parseIdentifier();
	      this.checkLVal(specifier.local, true, undefined, contextDescription);
	      node.specifiers.push(this.finishNode(specifier, type));
	    };

	    _proto.parseImportSpecifiers = function parseImportSpecifiers(node) {
	      node.importKind = "value";
	      var kind = null;

	      if (this.match(types._typeof)) {
	        kind = "typeof";
	      } else if (this.isContextual("type")) {
	        kind = "type";
	      }

	      if (kind) {
	        var lh = this.lookahead();

	        if (kind === "type" && lh.type === types.star) {
	          this.unexpected(lh.start);
	        }

	        if (isMaybeDefaultImport(lh) || lh.type === types.braceL || lh.type === types.star) {
	          this.next();
	          node.importKind = kind;
	        }
	      }

	      _superClass.prototype.parseImportSpecifiers.call(this, node);
	    };

	    _proto.parseImportSpecifier = function parseImportSpecifier(node) {
	      var specifier = this.startNode();
	      var firstIdentLoc = this.state.start;
	      var firstIdent = this.parseIdentifier(true);
	      var specifierTypeKind = null;

	      if (firstIdent.name === "type") {
	        specifierTypeKind = "type";
	      } else if (firstIdent.name === "typeof") {
	        specifierTypeKind = "typeof";
	      }

	      var isBinding = false;

	      if (this.isContextual("as") && !this.isLookaheadContextual("as")) {
	        var as_ident = this.parseIdentifier(true);

	        if (specifierTypeKind !== null && !this.match(types.name) && !this.state.type.keyword) {
	          specifier.imported = as_ident;
	          specifier.importKind = specifierTypeKind;
	          specifier.local = as_ident.__clone();
	        } else {
	          specifier.imported = firstIdent;
	          specifier.importKind = null;
	          specifier.local = this.parseIdentifier();
	        }
	      } else if (specifierTypeKind !== null && (this.match(types.name) || this.state.type.keyword)) {
	        specifier.imported = this.parseIdentifier(true);
	        specifier.importKind = specifierTypeKind;

	        if (this.eatContextual("as")) {
	          specifier.local = this.parseIdentifier();
	        } else {
	          isBinding = true;
	          specifier.local = specifier.imported.__clone();
	        }
	      } else {
	        isBinding = true;
	        specifier.imported = firstIdent;
	        specifier.importKind = null;
	        specifier.local = specifier.imported.__clone();
	      }

	      var nodeIsTypeImport = hasTypeImportKind(node);
	      var specifierIsTypeImport = hasTypeImportKind(specifier);

	      if (nodeIsTypeImport && specifierIsTypeImport) {
	        this.raise(firstIdentLoc, "The `type` and `typeof` keywords on named imports can only be used on regular " + "`import` statements. It cannot be used with `import type` or `import typeof` statements");
	      }

	      if (nodeIsTypeImport || specifierIsTypeImport) {
	        this.checkReservedType(specifier.local.name, specifier.local.start);
	      }

	      if (isBinding && !nodeIsTypeImport && !specifierIsTypeImport) {
	        this.checkReservedWord(specifier.local.name, specifier.start, true, true);
	      }

	      this.checkLVal(specifier.local, true, undefined, "import specifier");
	      node.specifiers.push(this.finishNode(specifier, "ImportSpecifier"));
	    };

	    _proto.parseFunctionParams = function parseFunctionParams(node) {
	      var kind = node.kind;

	      if (kind !== "get" && kind !== "set" && this.isRelational("<")) {
	        node.typeParameters = this.flowParseTypeParameterDeclaration(false);
	      }

	      _superClass.prototype.parseFunctionParams.call(this, node);
	    };

	    _proto.parseVarHead = function parseVarHead(decl) {
	      _superClass.prototype.parseVarHead.call(this, decl);

	      if (this.match(types.colon)) {
	        decl.id.typeAnnotation = this.flowParseTypeAnnotation();
	        this.finishNode(decl.id, decl.id.type);
	      }
	    };

	    _proto.parseAsyncArrowFromCallExpression = function parseAsyncArrowFromCallExpression(node, call) {
	      if (this.match(types.colon)) {
	        var oldNoAnonFunctionType = this.state.noAnonFunctionType;
	        this.state.noAnonFunctionType = true;
	        node.returnType = this.flowParseTypeAnnotation();
	        this.state.noAnonFunctionType = oldNoAnonFunctionType;
	      }

	      return _superClass.prototype.parseAsyncArrowFromCallExpression.call(this, node, call);
	    };

	    _proto.shouldParseAsyncArrow = function shouldParseAsyncArrow() {
	      return this.match(types.colon) || _superClass.prototype.shouldParseAsyncArrow.call(this);
	    };

	    _proto.parseMaybeAssign = function parseMaybeAssign(noIn, refShorthandDefaultPos, afterLeftParse, refNeedsArrowPos) {
	      var _this6 = this;

	      var jsxError = null;

	      if (types.jsxTagStart && this.match(types.jsxTagStart)) {
	        var state = this.state.clone();

	        try {
	          return _superClass.prototype.parseMaybeAssign.call(this, noIn, refShorthandDefaultPos, afterLeftParse, refNeedsArrowPos);
	        } catch (err) {
	          if (err instanceof SyntaxError) {
	            this.state = state;
	            this.state.context.length -= 2;
	            jsxError = err;
	          } else {
	            throw err;
	          }
	        }
	      }

	      if (jsxError != null || this.isRelational("<")) {
	        var arrowExpression;
	        var typeParameters;

	        try {
	          typeParameters = this.flowParseTypeParameterDeclaration();
	          arrowExpression = this.forwardNoArrowParamsConversionAt(typeParameters, function () {
	            return _superClass.prototype.parseMaybeAssign.call(_this6, noIn, refShorthandDefaultPos, afterLeftParse, refNeedsArrowPos);
	          });
	          arrowExpression.typeParameters = typeParameters;
	          this.resetStartLocationFromNode(arrowExpression, typeParameters);
	        } catch (err) {
	          throw jsxError || err;
	        }

	        if (arrowExpression.type === "ArrowFunctionExpression") {
	          return arrowExpression;
	        } else if (jsxError != null) {
	          throw jsxError;
	        } else {
	          this.raise(typeParameters.start, "Expected an arrow function after this type parameter declaration");
	        }
	      }

	      return _superClass.prototype.parseMaybeAssign.call(this, noIn, refShorthandDefaultPos, afterLeftParse, refNeedsArrowPos);
	    };

	    _proto.parseArrow = function parseArrow(node) {
	      if (this.match(types.colon)) {
	        var state = this.state.clone();

	        try {
	          var oldNoAnonFunctionType = this.state.noAnonFunctionType;
	          this.state.noAnonFunctionType = true;
	          var typeNode = this.startNode();

	          var _this$flowParseTypeAn3 = this.flowParseTypeAndPredicateInitialiser();

	          typeNode.typeAnnotation = _this$flowParseTypeAn3[0];
	          node.predicate = _this$flowParseTypeAn3[1];
	          this.state.noAnonFunctionType = oldNoAnonFunctionType;
	          if (this.canInsertSemicolon()) this.unexpected();
	          if (!this.match(types.arrow)) this.unexpected();
	          node.returnType = typeNode.typeAnnotation ? this.finishNode(typeNode, "TypeAnnotation") : null;
	        } catch (err) {
	          if (err instanceof SyntaxError) {
	            this.state = state;
	          } else {
	            throw err;
	          }
	        }
	      }

	      return _superClass.prototype.parseArrow.call(this, node);
	    };

	    _proto.shouldParseArrow = function shouldParseArrow() {
	      return this.match(types.colon) || _superClass.prototype.shouldParseArrow.call(this);
	    };

	    _proto.setArrowFunctionParameters = function setArrowFunctionParameters(node, params) {
	      if (this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {
	        node.params = params;
	      } else {
	        _superClass.prototype.setArrowFunctionParameters.call(this, node, params);
	      }
	    };

	    _proto.checkFunctionNameAndParams = function checkFunctionNameAndParams(node, isArrowFunction) {
	      if (isArrowFunction && this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {
	        return;
	      }

	      return _superClass.prototype.checkFunctionNameAndParams.call(this, node, isArrowFunction);
	    };

	    _proto.parseParenAndDistinguishExpression = function parseParenAndDistinguishExpression(canBeArrow) {
	      return _superClass.prototype.parseParenAndDistinguishExpression.call(this, canBeArrow && this.state.noArrowAt.indexOf(this.state.start) === -1);
	    };

	    _proto.parseSubscripts = function parseSubscripts(base, startPos, startLoc, noCalls) {
	      if (base.type === "Identifier" && base.name === "async" && this.state.noArrowAt.indexOf(startPos) !== -1) {
	        this.next();
	        var node = this.startNodeAt(startPos, startLoc);
	        node.callee = base;
	        node.arguments = this.parseCallExpressionArguments(types.parenR, false);
	        base = this.finishNode(node, "CallExpression");
	      } else if (base.type === "Identifier" && base.name === "async" && this.isRelational("<")) {
	        var state = this.state.clone();
	        var error;

	        try {
	          var _node3 = this.parseAsyncArrowWithTypeParameters(startPos, startLoc);

	          if (_node3) return _node3;
	        } catch (e) {
	          error = e;
	        }

	        this.state = state;

	        try {
	          return _superClass.prototype.parseSubscripts.call(this, base, startPos, startLoc, noCalls);
	        } catch (e) {
	          throw error || e;
	        }
	      }

	      return _superClass.prototype.parseSubscripts.call(this, base, startPos, startLoc, noCalls);
	    };

	    _proto.parseSubscript = function parseSubscript(base, startPos, startLoc, noCalls, subscriptState) {
	      if (this.match(types.questionDot) && this.isLookaheadRelational("<")) {
	        this.expectPlugin("optionalChaining");
	        subscriptState.optionalChainMember = true;

	        if (noCalls) {
	          subscriptState.stop = true;
	          return base;
	        }

	        this.next();
	        var node = this.startNodeAt(startPos, startLoc);
	        node.callee = base;
	        node.typeArguments = this.flowParseTypeParameterInstantiation();
	        this.expect(types.parenL);
	        node.arguments = this.parseCallExpressionArguments(types.parenR, false);
	        node.optional = true;
	        return this.finishNode(node, "OptionalCallExpression");
	      } else if (!noCalls && this.shouldParseTypes() && this.isRelational("<")) {
	        var _node4 = this.startNodeAt(startPos, startLoc);

	        _node4.callee = base;
	        var state = this.state.clone();

	        try {
	          _node4.typeArguments = this.flowParseTypeParameterInstantiation();
	          this.expect(types.parenL);
	          _node4.arguments = this.parseCallExpressionArguments(types.parenR, false);

	          if (subscriptState.optionalChainMember) {
	            _node4.optional = false;
	            return this.finishNode(_node4, "OptionalCallExpression");
	          }

	          return this.finishNode(_node4, "CallExpression");
	        } catch (e) {
	          if (e instanceof SyntaxError) {
	            this.state = state;
	          } else {
	            throw e;
	          }
	        }
	      }

	      return _superClass.prototype.parseSubscript.call(this, base, startPos, startLoc, noCalls, subscriptState);
	    };

	    _proto.parseNewArguments = function parseNewArguments(node) {
	      var targs = null;

	      if (this.shouldParseTypes() && this.isRelational("<")) {
	        var state = this.state.clone();

	        try {
	          targs = this.flowParseTypeParameterInstantiation();
	        } catch (e) {
	          if (e instanceof SyntaxError) {
	            this.state = state;
	          } else {
	            throw e;
	          }
	        }
	      }

	      node.typeArguments = targs;

	      _superClass.prototype.parseNewArguments.call(this, node);
	    };

	    _proto.parseAsyncArrowWithTypeParameters = function parseAsyncArrowWithTypeParameters(startPos, startLoc) {
	      var node = this.startNodeAt(startPos, startLoc);
	      this.parseFunctionParams(node);
	      if (!this.parseArrow(node)) return;
	      return this.parseArrowExpression(node, undefined, true);
	    };

	    _proto.readToken_mult_modulo = function readToken_mult_modulo(code) {
	      var next = this.input.charCodeAt(this.state.pos + 1);

	      if (code === 42 && next === 47 && this.state.hasFlowComment) {
	        this.state.hasFlowComment = false;
	        this.state.pos += 2;
	        this.nextToken();
	        return;
	      }

	      _superClass.prototype.readToken_mult_modulo.call(this, code);
	    };

	    _proto.skipBlockComment = function skipBlockComment() {
	      if (this.hasPlugin("flow") && this.hasPlugin("flowComments") && this.skipFlowComment()) {
	        this.hasFlowCommentCompletion();
	        this.state.pos += this.skipFlowComment();
	        this.state.hasFlowComment = true;
	        return;
	      }

	      var end;

	      if (this.hasPlugin("flow") && this.state.hasFlowComment) {
	        end = this.input.indexOf("*-/", this.state.pos += 2);
	        if (end === -1) this.raise(this.state.pos - 2, "Unterminated comment");
	        this.state.pos = end + 3;
	        return;
	      }

	      _superClass.prototype.skipBlockComment.call(this);
	    };

	    _proto.skipFlowComment = function skipFlowComment() {
	      var ch2 = this.input.charCodeAt(this.state.pos + 2);
	      var ch3 = this.input.charCodeAt(this.state.pos + 3);

	      if (ch2 === 58 && ch3 === 58) {
	        return 4;
	      }

	      if (this.input.slice(this.state.pos + 2, 14) === "flow-include") {
	        return 14;
	      }

	      if (ch2 === 58 && ch3 !== 58) {
	        return 2;
	      }

	      return false;
	    };

	    _proto.hasFlowCommentCompletion = function hasFlowCommentCompletion() {
	      var end = this.input.indexOf("*/", this.state.pos);

	      if (end === -1) {
	        this.raise(this.state.pos, "Unterminated comment");
	      }
	    };

	    return _class;
	  }(superClass);
	});

	var entities = {
	  quot: "\"",
	  amp: "&",
	  apos: "'",
	  lt: "<",
	  gt: ">",
	  nbsp: "\xA0",
	  iexcl: "\xA1",
	  cent: "\xA2",
	  pound: "\xA3",
	  curren: "\xA4",
	  yen: "\xA5",
	  brvbar: "\xA6",
	  sect: "\xA7",
	  uml: "\xA8",
	  copy: "\xA9",
	  ordf: "\xAA",
	  laquo: "\xAB",
	  not: "\xAC",
	  shy: "\xAD",
	  reg: "\xAE",
	  macr: "\xAF",
	  deg: "\xB0",
	  plusmn: "\xB1",
	  sup2: "\xB2",
	  sup3: "\xB3",
	  acute: "\xB4",
	  micro: "\xB5",
	  para: "\xB6",
	  middot: "\xB7",
	  cedil: "\xB8",
	  sup1: "\xB9",
	  ordm: "\xBA",
	  raquo: "\xBB",
	  frac14: "\xBC",
	  frac12: "\xBD",
	  frac34: "\xBE",
	  iquest: "\xBF",
	  Agrave: "\xC0",
	  Aacute: "\xC1",
	  Acirc: "\xC2",
	  Atilde: "\xC3",
	  Auml: "\xC4",
	  Aring: "\xC5",
	  AElig: "\xC6",
	  Ccedil: "\xC7",
	  Egrave: "\xC8",
	  Eacute: "\xC9",
	  Ecirc: "\xCA",
	  Euml: "\xCB",
	  Igrave: "\xCC",
	  Iacute: "\xCD",
	  Icirc: "\xCE",
	  Iuml: "\xCF",
	  ETH: "\xD0",
	  Ntilde: "\xD1",
	  Ograve: "\xD2",
	  Oacute: "\xD3",
	  Ocirc: "\xD4",
	  Otilde: "\xD5",
	  Ouml: "\xD6",
	  times: "\xD7",
	  Oslash: "\xD8",
	  Ugrave: "\xD9",
	  Uacute: "\xDA",
	  Ucirc: "\xDB",
	  Uuml: "\xDC",
	  Yacute: "\xDD",
	  THORN: "\xDE",
	  szlig: "\xDF",
	  agrave: "\xE0",
	  aacute: "\xE1",
	  acirc: "\xE2",
	  atilde: "\xE3",
	  auml: "\xE4",
	  aring: "\xE5",
	  aelig: "\xE6",
	  ccedil: "\xE7",
	  egrave: "\xE8",
	  eacute: "\xE9",
	  ecirc: "\xEA",
	  euml: "\xEB",
	  igrave: "\xEC",
	  iacute: "\xED",
	  icirc: "\xEE",
	  iuml: "\xEF",
	  eth: "\xF0",
	  ntilde: "\xF1",
	  ograve: "\xF2",
	  oacute: "\xF3",
	  ocirc: "\xF4",
	  otilde: "\xF5",
	  ouml: "\xF6",
	  divide: "\xF7",
	  oslash: "\xF8",
	  ugrave: "\xF9",
	  uacute: "\xFA",
	  ucirc: "\xFB",
	  uuml: "\xFC",
	  yacute: "\xFD",
	  thorn: "\xFE",
	  yuml: "\xFF",
	  OElig: "\u0152",
	  oelig: "\u0153",
	  Scaron: "\u0160",
	  scaron: "\u0161",
	  Yuml: "\u0178",
	  fnof: "\u0192",
	  circ: "\u02C6",
	  tilde: "\u02DC",
	  Alpha: "\u0391",
	  Beta: "\u0392",
	  Gamma: "\u0393",
	  Delta: "\u0394",
	  Epsilon: "\u0395",
	  Zeta: "\u0396",
	  Eta: "\u0397",
	  Theta: "\u0398",
	  Iota: "\u0399",
	  Kappa: "\u039A",
	  Lambda: "\u039B",
	  Mu: "\u039C",
	  Nu: "\u039D",
	  Xi: "\u039E",
	  Omicron: "\u039F",
	  Pi: "\u03A0",
	  Rho: "\u03A1",
	  Sigma: "\u03A3",
	  Tau: "\u03A4",
	  Upsilon: "\u03A5",
	  Phi: "\u03A6",
	  Chi: "\u03A7",
	  Psi: "\u03A8",
	  Omega: "\u03A9",
	  alpha: "\u03B1",
	  beta: "\u03B2",
	  gamma: "\u03B3",
	  delta: "\u03B4",
	  epsilon: "\u03B5",
	  zeta: "\u03B6",
	  eta: "\u03B7",
	  theta: "\u03B8",
	  iota: "\u03B9",
	  kappa: "\u03BA",
	  lambda: "\u03BB",
	  mu: "\u03BC",
	  nu: "\u03BD",
	  xi: "\u03BE",
	  omicron: "\u03BF",
	  pi: "\u03C0",
	  rho: "\u03C1",
	  sigmaf: "\u03C2",
	  sigma: "\u03C3",
	  tau: "\u03C4",
	  upsilon: "\u03C5",
	  phi: "\u03C6",
	  chi: "\u03C7",
	  psi: "\u03C8",
	  omega: "\u03C9",
	  thetasym: "\u03D1",
	  upsih: "\u03D2",
	  piv: "\u03D6",
	  ensp: "\u2002",
	  emsp: "\u2003",
	  thinsp: "\u2009",
	  zwnj: "\u200C",
	  zwj: "\u200D",
	  lrm: "\u200E",
	  rlm: "\u200F",
	  ndash: "\u2013",
	  mdash: "\u2014",
	  lsquo: "\u2018",
	  rsquo: "\u2019",
	  sbquo: "\u201A",
	  ldquo: "\u201C",
	  rdquo: "\u201D",
	  bdquo: "\u201E",
	  dagger: "\u2020",
	  Dagger: "\u2021",
	  bull: "\u2022",
	  hellip: "\u2026",
	  permil: "\u2030",
	  prime: "\u2032",
	  Prime: "\u2033",
	  lsaquo: "\u2039",
	  rsaquo: "\u203A",
	  oline: "\u203E",
	  frasl: "\u2044",
	  euro: "\u20AC",
	  image: "\u2111",
	  weierp: "\u2118",
	  real: "\u211C",
	  trade: "\u2122",
	  alefsym: "\u2135",
	  larr: "\u2190",
	  uarr: "\u2191",
	  rarr: "\u2192",
	  darr: "\u2193",
	  harr: "\u2194",
	  crarr: "\u21B5",
	  lArr: "\u21D0",
	  uArr: "\u21D1",
	  rArr: "\u21D2",
	  dArr: "\u21D3",
	  hArr: "\u21D4",
	  forall: "\u2200",
	  part: "\u2202",
	  exist: "\u2203",
	  empty: "\u2205",
	  nabla: "\u2207",
	  isin: "\u2208",
	  notin: "\u2209",
	  ni: "\u220B",
	  prod: "\u220F",
	  sum: "\u2211",
	  minus: "\u2212",
	  lowast: "\u2217",
	  radic: "\u221A",
	  prop: "\u221D",
	  infin: "\u221E",
	  ang: "\u2220",
	  and: "\u2227",
	  or: "\u2228",
	  cap: "\u2229",
	  cup: "\u222A",
	  int: "\u222B",
	  there4: "\u2234",
	  sim: "\u223C",
	  cong: "\u2245",
	  asymp: "\u2248",
	  ne: "\u2260",
	  equiv: "\u2261",
	  le: "\u2264",
	  ge: "\u2265",
	  sub: "\u2282",
	  sup: "\u2283",
	  nsub: "\u2284",
	  sube: "\u2286",
	  supe: "\u2287",
	  oplus: "\u2295",
	  otimes: "\u2297",
	  perp: "\u22A5",
	  sdot: "\u22C5",
	  lceil: "\u2308",
	  rceil: "\u2309",
	  lfloor: "\u230A",
	  rfloor: "\u230B",
	  lang: "\u2329",
	  rang: "\u232A",
	  loz: "\u25CA",
	  spades: "\u2660",
	  clubs: "\u2663",
	  hearts: "\u2665",
	  diams: "\u2666"
	};

	var lineBreak = /\r\n?|\n|\u2028|\u2029/;
	var lineBreakG = new RegExp(lineBreak.source, "g");
	function isNewLine(code) {
	  return code === 10 || code === 13 || code === 0x2028 || code === 0x2029;
	}
	var nonASCIIwhitespace = /[\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff]/;

	var TokContext = function TokContext(token, isExpr, preserveSpace, override) {
	  this.token = token;
	  this.isExpr = !!isExpr;
	  this.preserveSpace = !!preserveSpace;
	  this.override = override;
	};
	var types$1 = {
	  braceStatement: new TokContext("{", false),
	  braceExpression: new TokContext("{", true),
	  templateQuasi: new TokContext("${", true),
	  parenStatement: new TokContext("(", false),
	  parenExpression: new TokContext("(", true),
	  template: new TokContext("`", true, true, function (p) {
	    return p.readTmplToken();
	  }),
	  functionExpression: new TokContext("function", true)
	};

	types.parenR.updateContext = types.braceR.updateContext = function () {
	  if (this.state.context.length === 1) {
	    this.state.exprAllowed = true;
	    return;
	  }

	  var out = this.state.context.pop();

	  if (out === types$1.braceStatement && this.curContext() === types$1.functionExpression) {
	    this.state.context.pop();
	    this.state.exprAllowed = false;
	  } else if (out === types$1.templateQuasi) {
	    this.state.exprAllowed = true;
	  } else {
	    this.state.exprAllowed = !out.isExpr;
	  }
	};

	types.name.updateContext = function (prevType) {
	  if (this.state.value === "of" && this.curContext() === types$1.parenStatement) {
	    this.state.exprAllowed = !prevType.beforeExpr;
	    return;
	  }

	  this.state.exprAllowed = false;

	  if (prevType === types._let || prevType === types._const || prevType === types._var) {
	    if (lineBreak.test(this.input.slice(this.state.end))) {
	      this.state.exprAllowed = true;
	    }
	  }

	  if (this.state.isIterator) {
	    this.state.isIterator = false;
	  }
	};

	types.braceL.updateContext = function (prevType) {
	  this.state.context.push(this.braceIsBlock(prevType) ? types$1.braceStatement : types$1.braceExpression);
	  this.state.exprAllowed = true;
	};

	types.dollarBraceL.updateContext = function () {
	  this.state.context.push(types$1.templateQuasi);
	  this.state.exprAllowed = true;
	};

	types.parenL.updateContext = function (prevType) {
	  var statementParens = prevType === types._if || prevType === types._for || prevType === types._with || prevType === types._while;
	  this.state.context.push(statementParens ? types$1.parenStatement : types$1.parenExpression);
	  this.state.exprAllowed = true;
	};

	types.incDec.updateContext = function () {};

	types._function.updateContext = function (prevType) {
	  if (this.state.exprAllowed && !this.braceIsBlock(prevType)) {
	    this.state.context.push(types$1.functionExpression);
	  }

	  this.state.exprAllowed = false;
	};

	types.backQuote.updateContext = function () {
	  if (this.curContext() === types$1.template) {
	    this.state.context.pop();
	  } else {
	    this.state.context.push(types$1.template);
	  }

	  this.state.exprAllowed = false;
	};

	var HEX_NUMBER = /^[\da-fA-F]+$/;
	var DECIMAL_NUMBER = /^\d+$/;
	types$1.j_oTag = new TokContext("<tag", false);
	types$1.j_cTag = new TokContext("</tag", false);
	types$1.j_expr = new TokContext("<tag>...</tag>", true, true);
	types.jsxName = new TokenType("jsxName");
	types.jsxText = new TokenType("jsxText", {
	  beforeExpr: true
	});
	types.jsxTagStart = new TokenType("jsxTagStart", {
	  startsExpr: true
	});
	types.jsxTagEnd = new TokenType("jsxTagEnd");

	types.jsxTagStart.updateContext = function () {
	  this.state.context.push(types$1.j_expr);
	  this.state.context.push(types$1.j_oTag);
	  this.state.exprAllowed = false;
	};

	types.jsxTagEnd.updateContext = function (prevType) {
	  var out = this.state.context.pop();

	  if (out === types$1.j_oTag && prevType === types.slash || out === types$1.j_cTag) {
	    this.state.context.pop();
	    this.state.exprAllowed = this.curContext() === types$1.j_expr;
	  } else {
	    this.state.exprAllowed = true;
	  }
	};

	function isFragment(object) {
	  return object ? object.type === "JSXOpeningFragment" || object.type === "JSXClosingFragment" : false;
	}

	function getQualifiedJSXName(object) {
	  if (object.type === "JSXIdentifier") {
	    return object.name;
	  }

	  if (object.type === "JSXNamespacedName") {
	    return object.namespace.name + ":" + object.name.name;
	  }

	  if (object.type === "JSXMemberExpression") {
	    return getQualifiedJSXName(object.object) + "." + getQualifiedJSXName(object.property);
	  }

	  throw new Error("Node had unexpected type: " + object.type);
	}

	var jsx = (function (superClass) {
	  return function (_superClass) {
	    _inheritsLoose(_class, _superClass);

	    function _class() {
	      return _superClass.apply(this, arguments) || this;
	    }

	    var _proto = _class.prototype;

	    _proto.jsxReadToken = function jsxReadToken() {
	      var out = "";
	      var chunkStart = this.state.pos;

	      for (;;) {
	        if (this.state.pos >= this.input.length) {
	          this.raise(this.state.start, "Unterminated JSX contents");
	        }

	        var ch = this.input.charCodeAt(this.state.pos);

	        switch (ch) {
	          case 60:
	          case 123:
	            if (this.state.pos === this.state.start) {
	              if (ch === 60 && this.state.exprAllowed) {
	                ++this.state.pos;
	                return this.finishToken(types.jsxTagStart);
	              }

	              return this.getTokenFromCode(ch);
	            }

	            out += this.input.slice(chunkStart, this.state.pos);
	            return this.finishToken(types.jsxText, out);

	          case 38:
	            out += this.input.slice(chunkStart, this.state.pos);
	            out += this.jsxReadEntity();
	            chunkStart = this.state.pos;
	            break;

	          default:
	            if (isNewLine(ch)) {
	              out += this.input.slice(chunkStart, this.state.pos);
	              out += this.jsxReadNewLine(true);
	              chunkStart = this.state.pos;
	            } else {
	              ++this.state.pos;
	            }

	        }
	      }
	    };

	    _proto.jsxReadNewLine = function jsxReadNewLine(normalizeCRLF) {
	      var ch = this.input.charCodeAt(this.state.pos);
	      var out;
	      ++this.state.pos;

	      if (ch === 13 && this.input.charCodeAt(this.state.pos) === 10) {
	        ++this.state.pos;
	        out = normalizeCRLF ? "\n" : "\r\n";
	      } else {
	        out = String.fromCharCode(ch);
	      }

	      ++this.state.curLine;
	      this.state.lineStart = this.state.pos;
	      return out;
	    };

	    _proto.jsxReadString = function jsxReadString(quote) {
	      var out = "";
	      var chunkStart = ++this.state.pos;

	      for (;;) {
	        if (this.state.pos >= this.input.length) {
	          this.raise(this.state.start, "Unterminated string constant");
	        }

	        var ch = this.input.charCodeAt(this.state.pos);
	        if (ch === quote) break;

	        if (ch === 38) {
	          out += this.input.slice(chunkStart, this.state.pos);
	          out += this.jsxReadEntity();
	          chunkStart = this.state.pos;
	        } else if (isNewLine(ch)) {
	          out += this.input.slice(chunkStart, this.state.pos);
	          out += this.jsxReadNewLine(false);
	          chunkStart = this.state.pos;
	        } else {
	          ++this.state.pos;
	        }
	      }

	      out += this.input.slice(chunkStart, this.state.pos++);
	      return this.finishToken(types.string, out);
	    };

	    _proto.jsxReadEntity = function jsxReadEntity() {
	      var str = "";
	      var count = 0;
	      var entity;
	      var ch = this.input[this.state.pos];
	      var startPos = ++this.state.pos;

	      while (this.state.pos < this.input.length && count++ < 10) {
	        ch = this.input[this.state.pos++];

	        if (ch === ";") {
	          if (str[0] === "#") {
	            if (str[1] === "x") {
	              str = str.substr(2);

	              if (HEX_NUMBER.test(str)) {
	                entity = String.fromCodePoint(parseInt(str, 16));
	              }
	            } else {
	              str = str.substr(1);

	              if (DECIMAL_NUMBER.test(str)) {
	                entity = String.fromCodePoint(parseInt(str, 10));
	              }
	            }
	          } else {
	            entity = entities[str];
	          }

	          break;
	        }

	        str += ch;
	      }

	      if (!entity) {
	        this.state.pos = startPos;
	        return "&";
	      }

	      return entity;
	    };

	    _proto.jsxReadWord = function jsxReadWord() {
	      var ch;
	      var start = this.state.pos;

	      do {
	        ch = this.input.charCodeAt(++this.state.pos);
	      } while (isIdentifierChar(ch) || ch === 45);

	      return this.finishToken(types.jsxName, this.input.slice(start, this.state.pos));
	    };

	    _proto.jsxParseIdentifier = function jsxParseIdentifier() {
	      var node = this.startNode();

	      if (this.match(types.jsxName)) {
	        node.name = this.state.value;
	      } else if (this.state.type.keyword) {
	        node.name = this.state.type.keyword;
	      } else {
	        this.unexpected();
	      }

	      this.next();
	      return this.finishNode(node, "JSXIdentifier");
	    };

	    _proto.jsxParseNamespacedName = function jsxParseNamespacedName() {
	      var startPos = this.state.start;
	      var startLoc = this.state.startLoc;
	      var name = this.jsxParseIdentifier();
	      if (!this.eat(types.colon)) return name;
	      var node = this.startNodeAt(startPos, startLoc);
	      node.namespace = name;
	      node.name = this.jsxParseIdentifier();
	      return this.finishNode(node, "JSXNamespacedName");
	    };

	    _proto.jsxParseElementName = function jsxParseElementName() {
	      var startPos = this.state.start;
	      var startLoc = this.state.startLoc;
	      var node = this.jsxParseNamespacedName();

	      while (this.eat(types.dot)) {
	        var newNode = this.startNodeAt(startPos, startLoc);
	        newNode.object = node;
	        newNode.property = this.jsxParseIdentifier();
	        node = this.finishNode(newNode, "JSXMemberExpression");
	      }

	      return node;
	    };

	    _proto.jsxParseAttributeValue = function jsxParseAttributeValue() {
	      var node;

	      switch (this.state.type) {
	        case types.braceL:
	          node = this.jsxParseExpressionContainer();

	          if (node.expression.type === "JSXEmptyExpression") {
	            throw this.raise(node.start, "JSX attributes must only be assigned a non-empty expression");
	          } else {
	            return node;
	          }

	        case types.jsxTagStart:
	        case types.string:
	          return this.parseExprAtom();

	        default:
	          throw this.raise(this.state.start, "JSX value should be either an expression or a quoted JSX text");
	      }
	    };

	    _proto.jsxParseEmptyExpression = function jsxParseEmptyExpression() {
	      var node = this.startNodeAt(this.state.lastTokEnd, this.state.lastTokEndLoc);
	      return this.finishNodeAt(node, "JSXEmptyExpression", this.state.start, this.state.startLoc);
	    };

	    _proto.jsxParseSpreadChild = function jsxParseSpreadChild() {
	      var node = this.startNode();
	      this.expect(types.braceL);
	      this.expect(types.ellipsis);
	      node.expression = this.parseExpression();
	      this.expect(types.braceR);
	      return this.finishNode(node, "JSXSpreadChild");
	    };

	    _proto.jsxParseExpressionContainer = function jsxParseExpressionContainer() {
	      var node = this.startNode();
	      this.next();

	      if (this.match(types.braceR)) {
	        node.expression = this.jsxParseEmptyExpression();
	      } else {
	        node.expression = this.parseExpression();
	      }

	      this.expect(types.braceR);
	      return this.finishNode(node, "JSXExpressionContainer");
	    };

	    _proto.jsxParseAttribute = function jsxParseAttribute() {
	      var node = this.startNode();

	      if (this.eat(types.braceL)) {
	        this.expect(types.ellipsis);
	        node.argument = this.parseMaybeAssign();
	        this.expect(types.braceR);
	        return this.finishNode(node, "JSXSpreadAttribute");
	      }

	      node.name = this.jsxParseNamespacedName();
	      node.value = this.eat(types.eq) ? this.jsxParseAttributeValue() : null;
	      return this.finishNode(node, "JSXAttribute");
	    };

	    _proto.jsxParseOpeningElementAt = function jsxParseOpeningElementAt(startPos, startLoc) {
	      var node = this.startNodeAt(startPos, startLoc);

	      if (this.match(types.jsxTagEnd)) {
	        this.expect(types.jsxTagEnd);
	        return this.finishNode(node, "JSXOpeningFragment");
	      }

	      node.name = this.jsxParseElementName();
	      return this.jsxParseOpeningElementAfterName(node);
	    };

	    _proto.jsxParseOpeningElementAfterName = function jsxParseOpeningElementAfterName(node) {
	      var attributes = [];

	      while (!this.match(types.slash) && !this.match(types.jsxTagEnd)) {
	        attributes.push(this.jsxParseAttribute());
	      }

	      node.attributes = attributes;
	      node.selfClosing = this.eat(types.slash);
	      this.expect(types.jsxTagEnd);
	      return this.finishNode(node, "JSXOpeningElement");
	    };

	    _proto.jsxParseClosingElementAt = function jsxParseClosingElementAt(startPos, startLoc) {
	      var node = this.startNodeAt(startPos, startLoc);

	      if (this.match(types.jsxTagEnd)) {
	        this.expect(types.jsxTagEnd);
	        return this.finishNode(node, "JSXClosingFragment");
	      }

	      node.name = this.jsxParseElementName();
	      this.expect(types.jsxTagEnd);
	      return this.finishNode(node, "JSXClosingElement");
	    };

	    _proto.jsxParseElementAt = function jsxParseElementAt(startPos, startLoc) {
	      var node = this.startNodeAt(startPos, startLoc);
	      var children = [];
	      var openingElement = this.jsxParseOpeningElementAt(startPos, startLoc);
	      var closingElement = null;

	      if (!openingElement.selfClosing) {
	        contents: for (;;) {
	          switch (this.state.type) {
	            case types.jsxTagStart:
	              startPos = this.state.start;
	              startLoc = this.state.startLoc;
	              this.next();

	              if (this.eat(types.slash)) {
	                closingElement = this.jsxParseClosingElementAt(startPos, startLoc);
	                break contents;
	              }

	              children.push(this.jsxParseElementAt(startPos, startLoc));
	              break;

	            case types.jsxText:
	              children.push(this.parseExprAtom());
	              break;

	            case types.braceL:
	              if (this.lookahead().type === types.ellipsis) {
	                children.push(this.jsxParseSpreadChild());
	              } else {
	                children.push(this.jsxParseExpressionContainer());
	              }

	              break;

	            default:
	              throw this.unexpected();
	          }
	        }

	        if (isFragment(openingElement) && !isFragment(closingElement)) {
	          this.raise(closingElement.start, "Expected corresponding JSX closing tag for <>");
	        } else if (!isFragment(openingElement) && isFragment(closingElement)) {
	          this.raise(closingElement.start, "Expected corresponding JSX closing tag for <" + getQualifiedJSXName(openingElement.name) + ">");
	        } else if (!isFragment(openingElement) && !isFragment(closingElement)) {
	          if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) {
	            this.raise(closingElement.start, "Expected corresponding JSX closing tag for <" + getQualifiedJSXName(openingElement.name) + ">");
	          }
	        }
	      }

	      if (isFragment(openingElement)) {
	        node.openingFragment = openingElement;
	        node.closingFragment = closingElement;
	      } else {
	        node.openingElement = openingElement;
	        node.closingElement = closingElement;
	      }

	      node.children = children;

	      if (this.match(types.relational) && this.state.value === "<") {
	        this.raise(this.state.start, "Adjacent JSX elements must be wrapped in an enclosing tag. " + "Did you want a JSX fragment <>...</>?");
	      }

	      return isFragment(openingElement) ? this.finishNode(node, "JSXFragment") : this.finishNode(node, "JSXElement");
	    };

	    _proto.jsxParseElement = function jsxParseElement() {
	      var startPos = this.state.start;
	      var startLoc = this.state.startLoc;
	      this.next();
	      return this.jsxParseElementAt(startPos, startLoc);
	    };

	    _proto.parseExprAtom = function parseExprAtom(refShortHandDefaultPos) {
	      if (this.match(types.jsxText)) {
	        return this.parseLiteral(this.state.value, "JSXText");
	      } else if (this.match(types.jsxTagStart)) {
	        return this.jsxParseElement();
	      } else {
	        return _superClass.prototype.parseExprAtom.call(this, refShortHandDefaultPos);
	      }
	    };

	    _proto.readToken = function readToken(code) {
	      if (this.state.inPropertyName) return _superClass.prototype.readToken.call(this, code);
	      var context = this.curContext();

	      if (context === types$1.j_expr) {
	        return this.jsxReadToken();
	      }

	      if (context === types$1.j_oTag || context === types$1.j_cTag) {
	        if (isIdentifierStart(code)) {
	          return this.jsxReadWord();
	        }

	        if (code === 62) {
	          ++this.state.pos;
	          return this.finishToken(types.jsxTagEnd);
	        }

	        if ((code === 34 || code === 39) && context === types$1.j_oTag) {
	          return this.jsxReadString(code);
	        }
	      }

	      if (code === 60 && this.state.exprAllowed) {
	        ++this.state.pos;
	        return this.finishToken(types.jsxTagStart);
	      }

	      return _superClass.prototype.readToken.call(this, code);
	    };

	    _proto.updateContext = function updateContext(prevType) {
	      if (this.match(types.braceL)) {
	        var curContext = this.curContext();

	        if (curContext === types$1.j_oTag) {
	          this.state.context.push(types$1.braceExpression);
	        } else if (curContext === types$1.j_expr) {
	          this.state.context.push(types$1.templateQuasi);
	        } else {
	          _superClass.prototype.updateContext.call(this, prevType);
	        }

	        this.state.exprAllowed = true;
	      } else if (this.match(types.slash) && prevType === types.jsxTagStart) {
	        this.state.context.length -= 2;
	        this.state.context.push(types$1.j_cTag);
	        this.state.exprAllowed = false;
	      } else {
	        return _superClass.prototype.updateContext.call(this, prevType);
	      }
	    };

	    return _class;
	  }(superClass);
	});

	var defaultOptions = {
	  sourceType: "script",
	  sourceFilename: undefined,
	  startLine: 1,
	  allowAwaitOutsideFunction: false,
	  allowReturnOutsideFunction: false,
	  allowImportExportEverywhere: false,
	  allowSuperOutsideMethod: false,
	  plugins: [],
	  strictMode: null,
	  ranges: false,
	  tokens: false
	};
	function getOptions(opts) {
	  var options = {};

	  for (var key in defaultOptions) {
	    options[key] = opts && opts[key] != null ? opts[key] : defaultOptions[key];
	  }

	  return options;
	}

	var Position = function Position(line, col) {
	  this.line = line;
	  this.column = col;
	};
	var SourceLocation = function SourceLocation(start, end) {
	  this.start = start;
	  this.end = end;
	};
	function getLineInfo(input, offset) {
	  for (var line = 1, cur = 0;;) {
	    lineBreakG.lastIndex = cur;
	    var match = lineBreakG.exec(input);

	    if (match && match.index < offset) {
	      ++line;
	      cur = match.index + match[0].length;
	    } else {
	      return new Position(line, offset - cur);
	    }
	  }

	  throw new Error("Unreachable");
	}

	var BaseParser = function () {
	  function BaseParser() {
	    this.sawUnambiguousESM = false;
	  }

	  var _proto = BaseParser.prototype;

	  _proto.isReservedWord = function isReservedWord(word) {
	    if (word === "await") {
	      return this.inModule;
	    } else {
	      return reservedWords[6](word);
	    }
	  };

	  _proto.hasPlugin = function hasPlugin(name) {
	    return Object.hasOwnProperty.call(this.plugins, name);
	  };

	  _proto.getPluginOption = function getPluginOption(plugin, name) {
	    if (this.hasPlugin(plugin)) return this.plugins[plugin][name];
	  };

	  return BaseParser;
	}();

	function last(stack) {
	  return stack[stack.length - 1];
	}

	var CommentsParser = function (_BaseParser) {
	  _inheritsLoose(CommentsParser, _BaseParser);

	  function CommentsParser() {
	    return _BaseParser.apply(this, arguments) || this;
	  }

	  var _proto = CommentsParser.prototype;

	  _proto.addComment = function addComment(comment) {
	    if (this.filename) comment.loc.filename = this.filename;
	    this.state.trailingComments.push(comment);
	    this.state.leadingComments.push(comment);
	  };

	  _proto.processComment = function processComment(node) {
	    if (node.type === "Program" && node.body.length > 0) return;
	    var stack = this.state.commentStack;
	    var firstChild, lastChild, trailingComments, i, j;

	    if (this.state.trailingComments.length > 0) {
	      if (this.state.trailingComments[0].start >= node.end) {
	        trailingComments = this.state.trailingComments;
	        this.state.trailingComments = [];
	      } else {
	        this.state.trailingComments.length = 0;
	      }
	    } else if (stack.length > 0) {
	      var lastInStack = last(stack);

	      if (lastInStack.trailingComments && lastInStack.trailingComments[0].start >= node.end) {
	        trailingComments = lastInStack.trailingComments;
	        delete lastInStack.trailingComments;
	      }
	    }

	    if (stack.length > 0 && last(stack).start >= node.start) {
	      firstChild = stack.pop();
	    }

	    while (stack.length > 0 && last(stack).start >= node.start) {
	      lastChild = stack.pop();
	    }

	    if (!lastChild && firstChild) lastChild = firstChild;

	    if (firstChild && this.state.leadingComments.length > 0) {
	      var lastComment = last(this.state.leadingComments);

	      if (firstChild.type === "ObjectProperty") {
	        if (lastComment.start >= node.start) {
	          if (this.state.commentPreviousNode) {
	            for (j = 0; j < this.state.leadingComments.length; j++) {
	              if (this.state.leadingComments[j].end < this.state.commentPreviousNode.end) {
	                this.state.leadingComments.splice(j, 1);
	                j--;
	              }
	            }

	            if (this.state.leadingComments.length > 0) {
	              firstChild.trailingComments = this.state.leadingComments;
	              this.state.leadingComments = [];
	            }
	          }
	        }
	      } else if (node.type === "CallExpression" && node.arguments && node.arguments.length) {
	        var lastArg = last(node.arguments);

	        if (lastArg && lastComment.start >= lastArg.start && lastComment.end <= node.end) {
	          if (this.state.commentPreviousNode) {
	            if (this.state.leadingComments.length > 0) {
	              lastArg.trailingComments = this.state.leadingComments;
	              this.state.leadingComments = [];
	            }
	          }
	        }
	      }
	    }

	    if (lastChild) {
	      if (lastChild.leadingComments) {
	        if (lastChild !== node && lastChild.leadingComments.length > 0 && last(lastChild.leadingComments).end <= node.start) {
	          node.leadingComments = lastChild.leadingComments;
	          delete lastChild.leadingComments;
	        } else {
	          for (i = lastChild.leadingComments.length - 2; i >= 0; --i) {
	            if (lastChild.leadingComments[i].end <= node.start) {
	              node.leadingComments = lastChild.leadingComments.splice(0, i + 1);
	              break;
	            }
	          }
	        }
	      }
	    } else if (this.state.leadingComments.length > 0) {
	      if (last(this.state.leadingComments).end <= node.start) {
	        if (this.state.commentPreviousNode) {
	          for (j = 0; j < this.state.leadingComments.length; j++) {
	            if (this.state.leadingComments[j].end < this.state.commentPreviousNode.end) {
	              this.state.leadingComments.splice(j, 1);
	              j--;
	            }
	          }
	        }

	        if (this.state.leadingComments.length > 0) {
	          node.leadingComments = this.state.leadingComments;
	          this.state.leadingComments = [];
	        }
	      } else {
	        for (i = 0; i < this.state.leadingComments.length; i++) {
	          if (this.state.leadingComments[i].end > node.start) {
	            break;
	          }
	        }

	        var leadingComments = this.state.leadingComments.slice(0, i);

	        if (leadingComments.length) {
	          node.leadingComments = leadingComments;
	        }

	        trailingComments = this.state.leadingComments.slice(i);

	        if (trailingComments.length === 0) {
	          trailingComments = null;
	        }
	      }
	    }

	    this.state.commentPreviousNode = node;

	    if (trailingComments) {
	      if (trailingComments.length && trailingComments[0].start >= node.start && last(trailingComments).end <= node.end) {
	        node.innerComments = trailingComments;
	      } else {
	        node.trailingComments = trailingComments;
	      }
	    }

	    stack.push(node);
	  };

	  return CommentsParser;
	}(BaseParser);

	var LocationParser = function (_CommentsParser) {
	  _inheritsLoose(LocationParser, _CommentsParser);

	  function LocationParser() {
	    return _CommentsParser.apply(this, arguments) || this;
	  }

	  var _proto = LocationParser.prototype;

	  _proto.raise = function raise(pos, message, _temp) {
	    var _ref = _temp === void 0 ? {} : _temp,
	        missingPluginNames = _ref.missingPluginNames,
	        code = _ref.code;

	    var loc = getLineInfo(this.input, pos);
	    message += " (" + loc.line + ":" + loc.column + ")";
	    var err = new SyntaxError(message);
	    err.pos = pos;
	    err.loc = loc;

	    if (missingPluginNames) {
	      err.missingPlugin = missingPluginNames;
	    }

	    if (code !== undefined) {
	      err.code = code;
	    }

	    throw err;
	  };

	  return LocationParser;
	}(CommentsParser);

	var State = function () {
	  function State() {}

	  var _proto = State.prototype;

	  _proto.init = function init(options, input) {
	    this.strict = options.strictMode === false ? false : options.sourceType === "module";
	    this.input = input;
	    this.potentialArrowAt = -1;
	    this.noArrowAt = [];
	    this.noArrowParamsConversionAt = [];
	    this.inMethod = false;
	    this.inFunction = false;
	    this.inParameters = false;
	    this.maybeInArrowParameters = false;
	    this.inGenerator = false;
	    this.inAsync = false;
	    this.inPropertyName = false;
	    this.inType = false;
	    this.inClassProperty = false;
	    this.noAnonFunctionType = false;
	    this.hasFlowComment = false;
	    this.isIterator = false;
	    this.classLevel = 0;
	    this.labels = [];
	    this.decoratorStack = [[]];
	    this.yieldInPossibleArrowParameters = null;
	    this.tokens = [];
	    this.comments = [];
	    this.trailingComments = [];
	    this.leadingComments = [];
	    this.commentStack = [];
	    this.commentPreviousNode = null;
	    this.pos = this.lineStart = 0;
	    this.curLine = options.startLine;
	    this.type = types.eof;
	    this.value = null;
	    this.start = this.end = this.pos;
	    this.startLoc = this.endLoc = this.curPosition();
	    this.lastTokEndLoc = this.lastTokStartLoc = null;
	    this.lastTokStart = this.lastTokEnd = this.pos;
	    this.context = [types$1.braceStatement];
	    this.exprAllowed = true;
	    this.containsEsc = this.containsOctal = false;
	    this.octalPosition = null;
	    this.invalidTemplateEscapePosition = null;
	    this.exportedIdentifiers = [];
	  };

	  _proto.curPosition = function curPosition() {
	    return new Position(this.curLine, this.pos - this.lineStart);
	  };

	  _proto.clone = function clone(skipArrays) {
	    var _this = this;

	    var state = new State();
	    Object.keys(this).forEach(function (key) {
	      var val = _this[key];

	      if ((!skipArrays || key === "context") && Array.isArray(val)) {
	        val = val.slice();
	      }

	      state[key] = val;
	    });
	    return state;
	  };

	  return State;
	}();

	var _isDigit = function isDigit(code) {
	  return code >= 48 && code <= 57;
	};

	var VALID_REGEX_FLAGS = "gmsiyu";
	var forbiddenNumericSeparatorSiblings = {
	  decBinOct: [46, 66, 69, 79, 95, 98, 101, 111],
	  hex: [46, 88, 95, 120]
	};
	var allowedNumericSeparatorSiblings = {};
	allowedNumericSeparatorSiblings.bin = [48, 49];
	allowedNumericSeparatorSiblings.oct = allowedNumericSeparatorSiblings.bin.concat([50, 51, 52, 53, 54, 55]);
	allowedNumericSeparatorSiblings.dec = allowedNumericSeparatorSiblings.oct.concat([56, 57]);
	allowedNumericSeparatorSiblings.hex = allowedNumericSeparatorSiblings.dec.concat([65, 66, 67, 68, 69, 70, 97, 98, 99, 100, 101, 102]);
	var Token = function Token(state) {
	  this.type = state.type;
	  this.value = state.value;
	  this.start = state.start;
	  this.end = state.end;
	  this.loc = new SourceLocation(state.startLoc, state.endLoc);
	};

	function codePointToString(code) {
	  if (code <= 0xffff) {
	    return String.fromCharCode(code);
	  } else {
	    return String.fromCharCode((code - 0x10000 >> 10) + 0xd800, (code - 0x10000 & 1023) + 0xdc00);
	  }
	}

	var Tokenizer = function (_LocationParser) {
	  _inheritsLoose(Tokenizer, _LocationParser);

	  function Tokenizer(options, input) {
	    var _this;

	    _this = _LocationParser.call(this) || this;
	    _this.state = new State();

	    _this.state.init(options, input);

	    _this.isLookahead = false;
	    return _this;
	  }

	  var _proto = Tokenizer.prototype;

	  _proto.next = function next() {
	    if (this.options.tokens && !this.isLookahead) {
	      this.state.tokens.push(new Token(this.state));
	    }

	    this.state.lastTokEnd = this.state.end;
	    this.state.lastTokStart = this.state.start;
	    this.state.lastTokEndLoc = this.state.endLoc;
	    this.state.lastTokStartLoc = this.state.startLoc;
	    this.nextToken();
	  };

	  _proto.eat = function eat(type) {
	    if (this.match(type)) {
	      this.next();
	      return true;
	    } else {
	      return false;
	    }
	  };

	  _proto.match = function match(type) {
	    return this.state.type === type;
	  };

	  _proto.isKeyword = function isKeyword$$1(word) {
	    return isKeyword(word);
	  };

	  _proto.lookahead = function lookahead() {
	    var old = this.state;
	    this.state = old.clone(true);
	    this.isLookahead = true;
	    this.next();
	    this.isLookahead = false;
	    var curr = this.state;
	    this.state = old;
	    return curr;
	  };

	  _proto.setStrict = function setStrict(strict) {
	    this.state.strict = strict;
	    if (!this.match(types.num) && !this.match(types.string)) return;
	    this.state.pos = this.state.start;

	    while (this.state.pos < this.state.lineStart) {
	      this.state.lineStart = this.input.lastIndexOf("\n", this.state.lineStart - 2) + 1;
	      --this.state.curLine;
	    }

	    this.nextToken();
	  };

	  _proto.curContext = function curContext() {
	    return this.state.context[this.state.context.length - 1];
	  };

	  _proto.nextToken = function nextToken() {
	    var curContext = this.curContext();
	    if (!curContext || !curContext.preserveSpace) this.skipSpace();
	    this.state.containsOctal = false;
	    this.state.octalPosition = null;
	    this.state.start = this.state.pos;
	    this.state.startLoc = this.state.curPosition();

	    if (this.state.pos >= this.input.length) {
	      this.finishToken(types.eof);
	      return;
	    }

	    if (curContext.override) {
	      curContext.override(this);
	    } else {
	      this.readToken(this.fullCharCodeAtPos());
	    }
	  };

	  _proto.readToken = function readToken(code) {
	    if (isIdentifierStart(code) || code === 92) {
	      this.readWord();
	    } else {
	      this.getTokenFromCode(code);
	    }
	  };

	  _proto.fullCharCodeAtPos = function fullCharCodeAtPos() {
	    var code = this.input.charCodeAt(this.state.pos);
	    if (code <= 0xd7ff || code >= 0xe000) return code;
	    var next = this.input.charCodeAt(this.state.pos + 1);
	    return (code << 10) + next - 0x35fdc00;
	  };

	  _proto.pushComment = function pushComment(block, text, start, end, startLoc, endLoc) {
	    var comment = {
	      type: block ? "CommentBlock" : "CommentLine",
	      value: text,
	      start: start,
	      end: end,
	      loc: new SourceLocation(startLoc, endLoc)
	    };

	    if (!this.isLookahead) {
	      if (this.options.tokens) this.state.tokens.push(comment);
	      this.state.comments.push(comment);
	      this.addComment(comment);
	    }
	  };

	  _proto.skipBlockComment = function skipBlockComment() {
	    var startLoc = this.state.curPosition();
	    var start = this.state.pos;
	    var end = this.input.indexOf("*/", this.state.pos += 2);
	    if (end === -1) this.raise(this.state.pos - 2, "Unterminated comment");
	    this.state.pos = end + 2;
	    lineBreakG.lastIndex = start;
	    var match;

	    while ((match = lineBreakG.exec(this.input)) && match.index < this.state.pos) {
	      ++this.state.curLine;
	      this.state.lineStart = match.index + match[0].length;
	    }

	    this.pushComment(true, this.input.slice(start + 2, end), start, this.state.pos, startLoc, this.state.curPosition());
	  };

	  _proto.skipLineComment = function skipLineComment(startSkip) {
	    var start = this.state.pos;
	    var startLoc = this.state.curPosition();
	    var ch = this.input.charCodeAt(this.state.pos += startSkip);

	    if (this.state.pos < this.input.length) {
	      while (ch !== 10 && ch !== 13 && ch !== 8232 && ch !== 8233 && ++this.state.pos < this.input.length) {
	        ch = this.input.charCodeAt(this.state.pos);
	      }
	    }

	    this.pushComment(false, this.input.slice(start + startSkip, this.state.pos), start, this.state.pos, startLoc, this.state.curPosition());
	  };

	  _proto.skipSpace = function skipSpace() {
	    loop: while (this.state.pos < this.input.length) {
	      var ch = this.input.charCodeAt(this.state.pos);

	      switch (ch) {
	        case 32:
	        case 160:
	          ++this.state.pos;
	          break;

	        case 13:
	          if (this.input.charCodeAt(this.state.pos + 1) === 10) {
	            ++this.state.pos;
	          }

	        case 10:
	        case 8232:
	        case 8233:
	          ++this.state.pos;
	          ++this.state.curLine;
	          this.state.lineStart = this.state.pos;
	          break;

	        case 47:
	          switch (this.input.charCodeAt(this.state.pos + 1)) {
	            case 42:
	              this.skipBlockComment();
	              break;

	            case 47:
	              this.skipLineComment(2);
	              break;

	            default:
	              break loop;
	          }

	          break;

	        default:
	          if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {
	            ++this.state.pos;
	          } else {
	            break loop;
	          }

	      }
	    }
	  };

	  _proto.finishToken = function finishToken(type, val) {
	    this.state.end = this.state.pos;
	    this.state.endLoc = this.state.curPosition();
	    var prevType = this.state.type;
	    this.state.type = type;
	    this.state.value = val;
	    this.updateContext(prevType);
	  };

	  _proto.readToken_dot = function readToken_dot() {
	    var next = this.input.charCodeAt(this.state.pos + 1);

	    if (next >= 48 && next <= 57) {
	      this.readNumber(true);
	      return;
	    }

	    var next2 = this.input.charCodeAt(this.state.pos + 2);

	    if (next === 46 && next2 === 46) {
	      this.state.pos += 3;
	      this.finishToken(types.ellipsis);
	    } else {
	      ++this.state.pos;
	      this.finishToken(types.dot);
	    }
	  };

	  _proto.readToken_slash = function readToken_slash() {
	    if (this.state.exprAllowed && !this.state.inType) {
	      ++this.state.pos;
	      this.readRegexp();
	      return;
	    }

	    var next = this.input.charCodeAt(this.state.pos + 1);

	    if (next === 61) {
	      this.finishOp(types.assign, 2);
	    } else {
	      this.finishOp(types.slash, 1);
	    }
	  };

	  _proto.readToken_interpreter = function readToken_interpreter() {
	    if (this.state.pos !== 0 || this.state.input.length < 2) return false;
	    var start = this.state.pos;
	    this.state.pos += 1;
	    var ch = this.input.charCodeAt(this.state.pos);
	    if (ch !== 33) return false;

	    while (ch !== 10 && ch !== 13 && ch !== 8232 && ch !== 8233 && ++this.state.pos < this.input.length) {
	      ch = this.input.charCodeAt(this.state.pos);
	    }

	    var value = this.input.slice(start + 2, this.state.pos);
	    this.finishToken(types.interpreterDirective, value);
	    return true;
	  };

	  _proto.readToken_mult_modulo = function readToken_mult_modulo(code) {
	    var type = code === 42 ? types.star : types.modulo;
	    var width = 1;
	    var next = this.input.charCodeAt(this.state.pos + 1);
	    var exprAllowed = this.state.exprAllowed;

	    if (code === 42 && next === 42) {
	      width++;
	      next = this.input.charCodeAt(this.state.pos + 2);
	      type = types.exponent;
	    }

	    if (next === 61 && !exprAllowed) {
	      width++;
	      type = types.assign;
	    }

	    this.finishOp(type, width);
	  };

	  _proto.readToken_pipe_amp = function readToken_pipe_amp(code) {
	    var next = this.input.charCodeAt(this.state.pos + 1);

	    if (next === code) {
	      if (this.input.charCodeAt(this.state.pos + 2) === 61) {
	        this.finishOp(types.assign, 3);
	      } else {
	        this.finishOp(code === 124 ? types.logicalOR : types.logicalAND, 2);
	      }

	      return;
	    }

	    if (code === 124) {
	      if (next === 62) {
	        this.finishOp(types.pipeline, 2);
	        return;
	      } else if (next === 125 && this.hasPlugin("flow")) {
	        this.finishOp(types.braceBarR, 2);
	        return;
	      }
	    }

	    if (next === 61) {
	      this.finishOp(types.assign, 2);
	      return;
	    }

	    this.finishOp(code === 124 ? types.bitwiseOR : types.bitwiseAND, 1);
	  };

	  _proto.readToken_caret = function readToken_caret() {
	    var next = this.input.charCodeAt(this.state.pos + 1);

	    if (next === 61) {
	      this.finishOp(types.assign, 2);
	    } else {
	      this.finishOp(types.bitwiseXOR, 1);
	    }
	  };

	  _proto.readToken_plus_min = function readToken_plus_min(code) {
	    var next = this.input.charCodeAt(this.state.pos + 1);

	    if (next === code) {
	      if (next === 45 && !this.inModule && this.input.charCodeAt(this.state.pos + 2) === 62 && lineBreak.test(this.input.slice(this.state.lastTokEnd, this.state.pos))) {
	        this.skipLineComment(3);
	        this.skipSpace();
	        this.nextToken();
	        return;
	      }

	      this.finishOp(types.incDec, 2);
	      return;
	    }

	    if (next === 61) {
	      this.finishOp(types.assign, 2);
	    } else {
	      this.finishOp(types.plusMin, 1);
	    }
	  };

	  _proto.readToken_lt_gt = function readToken_lt_gt(code) {
	    var next = this.input.charCodeAt(this.state.pos + 1);
	    var size = 1;

	    if (next === code) {
	      size = code === 62 && this.input.charCodeAt(this.state.pos + 2) === 62 ? 3 : 2;

	      if (this.input.charCodeAt(this.state.pos + size) === 61) {
	        this.finishOp(types.assign, size + 1);
	        return;
	      }

	      this.finishOp(types.bitShift, size);
	      return;
	    }

	    if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.state.pos + 2) === 45 && this.input.charCodeAt(this.state.pos + 3) === 45) {
	      this.skipLineComment(4);
	      this.skipSpace();
	      this.nextToken();
	      return;
	    }

	    if (next === 61) {
	      size = 2;
	    }

	    this.finishOp(types.relational, size);
	  };

	  _proto.readToken_eq_excl = function readToken_eq_excl(code) {
	    var next = this.input.charCodeAt(this.state.pos + 1);

	    if (next === 61) {
	      this.finishOp(types.equality, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);
	      return;
	    }

	    if (code === 61 && next === 62) {
	      this.state.pos += 2;
	      this.finishToken(types.arrow);
	      return;
	    }

	    this.finishOp(code === 61 ? types.eq : types.bang, 1);
	  };

	  _proto.readToken_question = function readToken_question() {
	    var next = this.input.charCodeAt(this.state.pos + 1);
	    var next2 = this.input.charCodeAt(this.state.pos + 2);

	    if (next === 63 && !this.state.inType) {
	      if (next2 === 61) {
	        this.finishOp(types.assign, 3);
	      } else {
	        this.finishOp(types.nullishCoalescing, 2);
	      }
	    } else if (next === 46 && !(next2 >= 48 && next2 <= 57)) {
	      this.state.pos += 2;
	      this.finishToken(types.questionDot);
	    } else {
	      ++this.state.pos;
	      this.finishToken(types.question);
	    }
	  };

	  _proto.getTokenFromCode = function getTokenFromCode(code) {
	    switch (code) {
	      case 35:
	        if (this.state.pos === 0 && this.readToken_interpreter()) {
	          return;
	        }

	        if ((this.hasPlugin("classPrivateProperties") || this.hasPlugin("classPrivateMethods")) && this.state.classLevel > 0) {
	          ++this.state.pos;
	          this.finishToken(types.hash);
	          return;
	        } else {
	          this.raise(this.state.pos, "Unexpected character '" + codePointToString(code) + "'");
	        }

	      case 46:
	        this.readToken_dot();
	        return;

	      case 40:
	        ++this.state.pos;
	        this.finishToken(types.parenL);
	        return;

	      case 41:
	        ++this.state.pos;
	        this.finishToken(types.parenR);
	        return;

	      case 59:
	        ++this.state.pos;
	        this.finishToken(types.semi);
	        return;

	      case 44:
	        ++this.state.pos;
	        this.finishToken(types.comma);
	        return;

	      case 91:
	        ++this.state.pos;
	        this.finishToken(types.bracketL);
	        return;

	      case 93:
	        ++this.state.pos;
	        this.finishToken(types.bracketR);
	        return;

	      case 123:
	        if (this.hasPlugin("flow") && this.input.charCodeAt(this.state.pos + 1) === 124) {
	          this.finishOp(types.braceBarL, 2);
	        } else {
	          ++this.state.pos;
	          this.finishToken(types.braceL);
	        }

	        return;

	      case 125:
	        ++this.state.pos;
	        this.finishToken(types.braceR);
	        return;

	      case 58:
	        if (this.hasPlugin("functionBind") && this.input.charCodeAt(this.state.pos + 1) === 58) {
	          this.finishOp(types.doubleColon, 2);
	        } else {
	          ++this.state.pos;
	          this.finishToken(types.colon);
	        }

	        return;

	      case 63:
	        this.readToken_question();
	        return;

	      case 64:
	        ++this.state.pos;
	        this.finishToken(types.at);
	        return;

	      case 96:
	        ++this.state.pos;
	        this.finishToken(types.backQuote);
	        return;

	      case 48:
	        {
	          var next = this.input.charCodeAt(this.state.pos + 1);

	          if (next === 120 || next === 88) {
	            this.readRadixNumber(16);
	            return;
	          }

	          if (next === 111 || next === 79) {
	            this.readRadixNumber(8);
	            return;
	          }

	          if (next === 98 || next === 66) {
	            this.readRadixNumber(2);
	            return;
	          }
	        }

	      case 49:
	      case 50:
	      case 51:
	      case 52:
	      case 53:
	      case 54:
	      case 55:
	      case 56:
	      case 57:
	        this.readNumber(false);
	        return;

	      case 34:
	      case 39:
	        this.readString(code);
	        return;

	      case 47:
	        this.readToken_slash();
	        return;

	      case 37:
	      case 42:
	        this.readToken_mult_modulo(code);
	        return;

	      case 124:
	      case 38:
	        this.readToken_pipe_amp(code);
	        return;

	      case 94:
	        this.readToken_caret();
	        return;

	      case 43:
	      case 45:
	        this.readToken_plus_min(code);
	        return;

	      case 60:
	      case 62:
	        this.readToken_lt_gt(code);
	        return;

	      case 61:
	      case 33:
	        this.readToken_eq_excl(code);
	        return;

	      case 126:
	        this.finishOp(types.tilde, 1);
	        return;
	    }

	    this.raise(this.state.pos, "Unexpected character '" + codePointToString(code) + "'");
	  };

	  _proto.finishOp = function finishOp(type, size) {
	    var str = this.input.slice(this.state.pos, this.state.pos + size);
	    this.state.pos += size;
	    this.finishToken(type, str);
	  };

	  _proto.readRegexp = function readRegexp() {
	    var start = this.state.pos;
	    var escaped, inClass;

	    for (;;) {
	      if (this.state.pos >= this.input.length) {
	        this.raise(start, "Unterminated regular expression");
	      }

	      var ch = this.input.charAt(this.state.pos);

	      if (lineBreak.test(ch)) {
	        this.raise(start, "Unterminated regular expression");
	      }

	      if (escaped) {
	        escaped = false;
	      } else {
	        if (ch === "[") {
	          inClass = true;
	        } else if (ch === "]" && inClass) {
	          inClass = false;
	        } else if (ch === "/" && !inClass) {
	          break;
	        }

	        escaped = ch === "\\";
	      }

	      ++this.state.pos;
	    }

	    var content = this.input.slice(start, this.state.pos);
	    ++this.state.pos;
	    var mods = "";

	    while (this.state.pos < this.input.length) {
	      var char = this.input[this.state.pos];
	      var charCode = this.fullCharCodeAtPos();

	      if (VALID_REGEX_FLAGS.indexOf(char) > -1) {
	        if (mods.indexOf(char) > -1) {
	          this.raise(this.state.pos + 1, "Duplicate regular expression flag");
	        }

	        ++this.state.pos;
	        mods += char;
	      } else if (isIdentifierChar(charCode) || charCode === 92) {
	        this.raise(this.state.pos + 1, "Invalid regular expression flag");
	      } else {
	        break;
	      }
	    }

	    this.finishToken(types.regexp, {
	      pattern: content,
	      flags: mods
	    });
	  };

	  _proto.readInt = function readInt(radix, len) {
	    var start = this.state.pos;
	    var forbiddenSiblings = radix === 16 ? forbiddenNumericSeparatorSiblings.hex : forbiddenNumericSeparatorSiblings.decBinOct;
	    var allowedSiblings = radix === 16 ? allowedNumericSeparatorSiblings.hex : radix === 10 ? allowedNumericSeparatorSiblings.dec : radix === 8 ? allowedNumericSeparatorSiblings.oct : allowedNumericSeparatorSiblings.bin;
	    var total = 0;

	    for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {
	      var code = this.input.charCodeAt(this.state.pos);
	      var val = void 0;

	      if (this.hasPlugin("numericSeparator")) {
	        var prev = this.input.charCodeAt(this.state.pos - 1);
	        var next = this.input.charCodeAt(this.state.pos + 1);

	        if (code === 95) {
	          if (allowedSiblings.indexOf(next) === -1) {
	            this.raise(this.state.pos, "Invalid or unexpected token");
	          }

	          if (forbiddenSiblings.indexOf(prev) > -1 || forbiddenSiblings.indexOf(next) > -1 || Number.isNaN(next)) {
	            this.raise(this.state.pos, "Invalid or unexpected token");
	          }

	          ++this.state.pos;
	          continue;
	        }
	      }

	      if (code >= 97) {
	        val = code - 97 + 10;
	      } else if (code >= 65) {
	        val = code - 65 + 10;
	      } else if (_isDigit(code)) {
	        val = code - 48;
	      } else {
	        val = Infinity;
	      }

	      if (val >= radix) break;
	      ++this.state.pos;
	      total = total * radix + val;
	    }

	    if (this.state.pos === start || len != null && this.state.pos - start !== len) {
	      return null;
	    }

	    return total;
	  };

	  _proto.readRadixNumber = function readRadixNumber(radix) {
	    var start = this.state.pos;
	    var isBigInt = false;
	    this.state.pos += 2;
	    var val = this.readInt(radix);

	    if (val == null) {
	      this.raise(this.state.start + 2, "Expected number in radix " + radix);
	    }

	    if (this.hasPlugin("bigInt")) {
	      if (this.input.charCodeAt(this.state.pos) === 110) {
	        ++this.state.pos;
	        isBigInt = true;
	      }
	    }

	    if (isIdentifierStart(this.fullCharCodeAtPos())) {
	      this.raise(this.state.pos, "Identifier directly after number");
	    }

	    if (isBigInt) {
	      var str = this.input.slice(start, this.state.pos).replace(/[_n]/g, "");
	      this.finishToken(types.bigint, str);
	      return;
	    }

	    this.finishToken(types.num, val);
	  };

	  _proto.readNumber = function readNumber(startsWithDot) {
	    var start = this.state.pos;
	    var octal = this.input.charCodeAt(start) === 48;
	    var isFloat = false;
	    var isBigInt = false;

	    if (!startsWithDot && this.readInt(10) === null) {
	      this.raise(start, "Invalid number");
	    }

	    if (octal && this.state.pos == start + 1) octal = false;
	    var next = this.input.charCodeAt(this.state.pos);

	    if (next === 46 && !octal) {
	      ++this.state.pos;
	      this.readInt(10);
	      isFloat = true;
	      next = this.input.charCodeAt(this.state.pos);
	    }

	    if ((next === 69 || next === 101) && !octal) {
	      next = this.input.charCodeAt(++this.state.pos);

	      if (next === 43 || next === 45) {
	        ++this.state.pos;
	      }

	      if (this.readInt(10) === null) this.raise(start, "Invalid number");
	      isFloat = true;
	      next = this.input.charCodeAt(this.state.pos);
	    }

	    if (this.hasPlugin("bigInt")) {
	      if (next === 110) {
	        if (isFloat || octal) this.raise(start, "Invalid BigIntLiteral");
	        ++this.state.pos;
	        isBigInt = true;
	      }
	    }

	    if (isIdentifierStart(this.fullCharCodeAtPos())) {
	      this.raise(this.state.pos, "Identifier directly after number");
	    }

	    var str = this.input.slice(start, this.state.pos).replace(/[_n]/g, "");

	    if (isBigInt) {
	      this.finishToken(types.bigint, str);
	      return;
	    }

	    var val;

	    if (isFloat) {
	      val = parseFloat(str);
	    } else if (!octal || str.length === 1) {
	      val = parseInt(str, 10);
	    } else if (this.state.strict) {
	      this.raise(start, "Invalid number");
	    } else if (/[89]/.test(str)) {
	      val = parseInt(str, 10);
	    } else {
	      val = parseInt(str, 8);
	    }

	    this.finishToken(types.num, val);
	  };

	  _proto.readCodePoint = function readCodePoint(throwOnInvalid) {
	    var ch = this.input.charCodeAt(this.state.pos);
	    var code;

	    if (ch === 123) {
	      var codePos = ++this.state.pos;
	      code = this.readHexChar(this.input.indexOf("}", this.state.pos) - this.state.pos, throwOnInvalid);
	      ++this.state.pos;

	      if (code === null) {
	        --this.state.invalidTemplateEscapePosition;
	      } else if (code > 0x10ffff) {
	        if (throwOnInvalid) {
	          this.raise(codePos, "Code point out of bounds");
	        } else {
	          this.state.invalidTemplateEscapePosition = codePos - 2;
	          return null;
	        }
	      }
	    } else {
	      code = this.readHexChar(4, throwOnInvalid);
	    }

	    return code;
	  };

	  _proto.readString = function readString(quote) {
	    var out = "",
	        chunkStart = ++this.state.pos;
	    var hasJsonStrings = this.hasPlugin("jsonStrings");

	    for (;;) {
	      if (this.state.pos >= this.input.length) {
	        this.raise(this.state.start, "Unterminated string constant");
	      }

	      var ch = this.input.charCodeAt(this.state.pos);
	      if (ch === quote) break;

	      if (ch === 92) {
	        out += this.input.slice(chunkStart, this.state.pos);
	        out += this.readEscapedChar(false);
	        chunkStart = this.state.pos;
	      } else if (hasJsonStrings && (ch === 8232 || ch === 8233)) {
	        ++this.state.pos;
	      } else if (isNewLine(ch)) {
	        this.raise(this.state.start, "Unterminated string constant");
	      } else {
	        ++this.state.pos;
	      }
	    }

	    out += this.input.slice(chunkStart, this.state.pos++);
	    this.finishToken(types.string, out);
	  };

	  _proto.readTmplToken = function readTmplToken() {
	    var out = "",
	        chunkStart = this.state.pos,
	        containsInvalid = false;

	    for (;;) {
	      if (this.state.pos >= this.input.length) {
	        this.raise(this.state.start, "Unterminated template");
	      }

	      var ch = this.input.charCodeAt(this.state.pos);

	      if (ch === 96 || ch === 36 && this.input.charCodeAt(this.state.pos + 1) === 123) {
	        if (this.state.pos === this.state.start && this.match(types.template)) {
	          if (ch === 36) {
	            this.state.pos += 2;
	            this.finishToken(types.dollarBraceL);
	            return;
	          } else {
	            ++this.state.pos;
	            this.finishToken(types.backQuote);
	            return;
	          }
	        }

	        out += this.input.slice(chunkStart, this.state.pos);
	        this.finishToken(types.template, containsInvalid ? null : out);
	        return;
	      }

	      if (ch === 92) {
	        out += this.input.slice(chunkStart, this.state.pos);
	        var escaped = this.readEscapedChar(true);

	        if (escaped === null) {
	          containsInvalid = true;
	        } else {
	          out += escaped;
	        }

	        chunkStart = this.state.pos;
	      } else if (isNewLine(ch)) {
	        out += this.input.slice(chunkStart, this.state.pos);
	        ++this.state.pos;

	        switch (ch) {
	          case 13:
	            if (this.input.charCodeAt(this.state.pos) === 10) {
	              ++this.state.pos;
	            }

	          case 10:
	            out += "\n";
	            break;

	          default:
	            out += String.fromCharCode(ch);
	            break;
	        }

	        ++this.state.curLine;
	        this.state.lineStart = this.state.pos;
	        chunkStart = this.state.pos;
	      } else {
	        ++this.state.pos;
	      }
	    }
	  };

	  _proto.readEscapedChar = function readEscapedChar(inTemplate) {
	    var throwOnInvalid = !inTemplate;
	    var ch = this.input.charCodeAt(++this.state.pos);
	    ++this.state.pos;

	    switch (ch) {
	      case 110:
	        return "\n";

	      case 114:
	        return "\r";

	      case 120:
	        {
	          var code = this.readHexChar(2, throwOnInvalid);
	          return code === null ? null : String.fromCharCode(code);
	        }

	      case 117:
	        {
	          var _code = this.readCodePoint(throwOnInvalid);

	          return _code === null ? null : codePointToString(_code);
	        }

	      case 116:
	        return "\t";

	      case 98:
	        return "\b";

	      case 118:
	        return "\x0B";

	      case 102:
	        return "\f";

	      case 13:
	        if (this.input.charCodeAt(this.state.pos) === 10) {
	          ++this.state.pos;
	        }

	      case 10:
	        this.state.lineStart = this.state.pos;
	        ++this.state.curLine;
	        return "";

	      default:
	        if (ch >= 48 && ch <= 55) {
	          var codePos = this.state.pos - 1;
	          var octalStr = this.input.substr(this.state.pos - 1, 3).match(/^[0-7]+/)[0];
	          var octal = parseInt(octalStr, 8);

	          if (octal > 255) {
	            octalStr = octalStr.slice(0, -1);
	            octal = parseInt(octalStr, 8);
	          }

	          if (octal > 0) {
	            if (inTemplate) {
	              this.state.invalidTemplateEscapePosition = codePos;
	              return null;
	            } else if (this.state.strict) {
	              this.raise(codePos, "Octal literal in strict mode");
	            } else if (!this.state.containsOctal) {
	              this.state.containsOctal = true;
	              this.state.octalPosition = codePos;
	            }
	          }

	          this.state.pos += octalStr.length - 1;
	          return String.fromCharCode(octal);
	        }

	        return String.fromCharCode(ch);
	    }
	  };

	  _proto.readHexChar = function readHexChar(len, throwOnInvalid) {
	    var codePos = this.state.pos;
	    var n = this.readInt(16, len);

	    if (n === null) {
	      if (throwOnInvalid) {
	        this.raise(codePos, "Bad character escape sequence");
	      } else {
	        this.state.pos = codePos - 1;
	        this.state.invalidTemplateEscapePosition = codePos - 1;
	      }
	    }

	    return n;
	  };

	  _proto.readWord1 = function readWord1() {
	    this.state.containsEsc = false;
	    var word = "",
	        first = true,
	        chunkStart = this.state.pos;

	    while (this.state.pos < this.input.length) {
	      var ch = this.fullCharCodeAtPos();

	      if (isIdentifierChar(ch)) {
	        this.state.pos += ch <= 0xffff ? 1 : 2;
	      } else if (this.state.isIterator && ch === 64) {
	        this.state.pos += 1;
	      } else if (ch === 92) {
	        this.state.containsEsc = true;
	        word += this.input.slice(chunkStart, this.state.pos);
	        var escStart = this.state.pos;

	        if (this.input.charCodeAt(++this.state.pos) !== 117) {
	          this.raise(this.state.pos, "Expecting Unicode escape sequence \\uXXXX");
	        }

	        ++this.state.pos;
	        var esc = this.readCodePoint(true);

	        if (!(first ? isIdentifierStart : isIdentifierChar)(esc, true)) {
	          this.raise(escStart, "Invalid Unicode escape");
	        }

	        word += codePointToString(esc);
	        chunkStart = this.state.pos;
	      } else {
	        break;
	      }

	      first = false;
	    }

	    return word + this.input.slice(chunkStart, this.state.pos);
	  };

	  _proto.isIterator = function isIterator(word) {
	    return word === "@@iterator" || word === "@@asyncIterator";
	  };

	  _proto.readWord = function readWord() {
	    var word = this.readWord1();
	    var type = types.name;

	    if (this.isKeyword(word)) {
	      if (this.state.containsEsc) {
	        this.raise(this.state.pos, "Escape sequence in keyword " + word);
	      }

	      type = keywords[word];
	    }

	    if (this.state.isIterator && (!this.isIterator(word) || !this.state.inType)) {
	      this.raise(this.state.pos, "Invalid identifier " + word);
	    }

	    this.finishToken(type, word);
	  };

	  _proto.braceIsBlock = function braceIsBlock(prevType) {
	    if (prevType === types.colon) {
	      var parent = this.curContext();

	      if (parent === types$1.braceStatement || parent === types$1.braceExpression) {
	        return !parent.isExpr;
	      }
	    }

	    if (prevType === types._return) {
	      return lineBreak.test(this.input.slice(this.state.lastTokEnd, this.state.start));
	    }

	    if (prevType === types._else || prevType === types.semi || prevType === types.eof || prevType === types.parenR) {
	      return true;
	    }

	    if (prevType === types.braceL) {
	      return this.curContext() === types$1.braceStatement;
	    }

	    if (prevType === types.relational) {
	      return true;
	    }

	    return !this.state.exprAllowed;
	  };

	  _proto.updateContext = function updateContext(prevType) {
	    var type = this.state.type;
	    var update;

	    if (type.keyword && (prevType === types.dot || prevType === types.questionDot)) {
	      this.state.exprAllowed = false;
	    } else if (update = type.updateContext) {
	      update.call(this, prevType);
	    } else {
	      this.state.exprAllowed = type.beforeExpr;
	    }
	  };

	  return Tokenizer;
	}(LocationParser);

	var UtilParser = function (_Tokenizer) {
	  _inheritsLoose(UtilParser, _Tokenizer);

	  function UtilParser() {
	    return _Tokenizer.apply(this, arguments) || this;
	  }

	  var _proto = UtilParser.prototype;

	  _proto.addExtra = function addExtra(node, key, val) {
	    if (!node) return;
	    var extra = node.extra = node.extra || {};
	    extra[key] = val;
	  };

	  _proto.isRelational = function isRelational(op) {
	    return this.match(types.relational) && this.state.value === op;
	  };

	  _proto.isLookaheadRelational = function isLookaheadRelational(op) {
	    var l = this.lookahead();
	    return l.type == types.relational && l.value == op;
	  };

	  _proto.expectRelational = function expectRelational(op) {
	    if (this.isRelational(op)) {
	      this.next();
	    } else {
	      this.unexpected(null, types.relational);
	    }
	  };

	  _proto.eatRelational = function eatRelational(op) {
	    if (this.isRelational(op)) {
	      this.next();
	      return true;
	    }

	    return false;
	  };

	  _proto.isContextual = function isContextual(name) {
	    return this.match(types.name) && this.state.value === name && !this.state.containsEsc;
	  };

	  _proto.isLookaheadContextual = function isLookaheadContextual(name) {
	    var l = this.lookahead();
	    return l.type === types.name && l.value === name;
	  };

	  _proto.eatContextual = function eatContextual(name) {
	    return this.isContextual(name) && this.eat(types.name);
	  };

	  _proto.expectContextual = function expectContextual(name, message) {
	    if (!this.eatContextual(name)) this.unexpected(null, message);
	  };

	  _proto.canInsertSemicolon = function canInsertSemicolon() {
	    return this.match(types.eof) || this.match(types.braceR) || this.hasPrecedingLineBreak();
	  };

	  _proto.hasPrecedingLineBreak = function hasPrecedingLineBreak() {
	    return lineBreak.test(this.input.slice(this.state.lastTokEnd, this.state.start));
	  };

	  _proto.isLineTerminator = function isLineTerminator() {
	    return this.eat(types.semi) || this.canInsertSemicolon();
	  };

	  _proto.semicolon = function semicolon() {
	    if (!this.isLineTerminator()) this.unexpected(null, types.semi);
	  };

	  _proto.expect = function expect(type, pos) {
	    this.eat(type) || this.unexpected(pos, type);
	  };

	  _proto.unexpected = function unexpected(pos, messageOrType) {
	    if (messageOrType === void 0) {
	      messageOrType = "Unexpected token";
	    }

	    if (typeof messageOrType !== "string") {
	      messageOrType = "Unexpected token, expected \"" + messageOrType.label + "\"";
	    }

	    throw this.raise(pos != null ? pos : this.state.start, messageOrType);
	  };

	  _proto.expectPlugin = function expectPlugin(name, pos) {
	    if (!this.hasPlugin(name)) {
	      throw this.raise(pos != null ? pos : this.state.start, "This experimental syntax requires enabling the parser plugin: '" + name + "'", {
	        missingPluginNames: [name]
	      });
	    }

	    return true;
	  };

	  _proto.expectOnePlugin = function expectOnePlugin(names, pos) {
	    var _this = this;

	    if (!names.some(function (n) {
	      return _this.hasPlugin(n);
	    })) {
	      throw this.raise(pos != null ? pos : this.state.start, "This experimental syntax requires enabling one of the following parser plugin(s): '" + names.join(", ") + "'", {
	        missingPluginNames: names
	      });
	    }
	  };

	  return UtilParser;
	}(Tokenizer);

	var commentKeys = ["leadingComments", "trailingComments", "innerComments"];

	var Node = function () {
	  function Node(parser, pos, loc) {
	    this.type = "";
	    this.start = pos;
	    this.end = 0;
	    this.loc = new SourceLocation(loc);
	    if (parser && parser.options.ranges) this.range = [pos, 0];
	    if (parser && parser.filename) this.loc.filename = parser.filename;
	  }

	  var _proto = Node.prototype;

	  _proto.__clone = function __clone() {
	    var _this = this;

	    var node2 = new Node();
	    Object.keys(this).forEach(function (key) {
	      if (commentKeys.indexOf(key) < 0) {
	        node2[key] = _this[key];
	      }
	    });
	    return node2;
	  };

	  return Node;
	}();

	var NodeUtils = function (_UtilParser) {
	  _inheritsLoose(NodeUtils, _UtilParser);

	  function NodeUtils() {
	    return _UtilParser.apply(this, arguments) || this;
	  }

	  var _proto2 = NodeUtils.prototype;

	  _proto2.startNode = function startNode() {
	    return new Node(this, this.state.start, this.state.startLoc);
	  };

	  _proto2.startNodeAt = function startNodeAt(pos, loc) {
	    return new Node(this, pos, loc);
	  };

	  _proto2.startNodeAtNode = function startNodeAtNode(type) {
	    return this.startNodeAt(type.start, type.loc.start);
	  };

	  _proto2.finishNode = function finishNode(node, type) {
	    return this.finishNodeAt(node, type, this.state.lastTokEnd, this.state.lastTokEndLoc);
	  };

	  _proto2.finishNodeAt = function finishNodeAt(node, type, pos, loc) {
	    node.type = type;
	    node.end = pos;
	    node.loc.end = loc;
	    if (this.options.ranges) node.range[1] = pos;
	    this.processComment(node);
	    return node;
	  };

	  _proto2.resetStartLocationFromNode = function resetStartLocationFromNode(node, locationNode) {
	    node.start = locationNode.start;
	    node.loc.start = locationNode.loc.start;
	    if (this.options.ranges) node.range[0] = locationNode.range[0];
	  };

	  return NodeUtils;
	}(UtilParser);

	var LValParser = function (_NodeUtils) {
	  _inheritsLoose(LValParser, _NodeUtils);

	  function LValParser() {
	    return _NodeUtils.apply(this, arguments) || this;
	  }

	  var _proto = LValParser.prototype;

	  _proto.toAssignable = function toAssignable(node, isBinding, contextDescription) {
	    if (node) {
	      switch (node.type) {
	        case "Identifier":
	        case "ObjectPattern":
	        case "ArrayPattern":
	        case "AssignmentPattern":
	          break;

	        case "ObjectExpression":
	          node.type = "ObjectPattern";

	          for (var index = 0; index < node.properties.length; index++) {
	            var prop = node.properties[index];
	            var isLast = index === node.properties.length - 1;
	            this.toAssignableObjectExpressionProp(prop, isBinding, isLast);
	          }

	          break;

	        case "ObjectProperty":
	          this.toAssignable(node.value, isBinding, contextDescription);
	          break;

	        case "SpreadElement":
	          {
	            this.checkToRestConversion(node);
	            node.type = "RestElement";
	            var arg = node.argument;
	            this.toAssignable(arg, isBinding, contextDescription);
	            break;
	          }

	        case "ArrayExpression":
	          node.type = "ArrayPattern";
	          this.toAssignableList(node.elements, isBinding, contextDescription);
	          break;

	        case "AssignmentExpression":
	          if (node.operator === "=") {
	            node.type = "AssignmentPattern";
	            delete node.operator;
	          } else {
	            this.raise(node.left.end, "Only '=' operator can be used for specifying default value.");
	          }

	          break;

	        case "MemberExpression":
	          if (!isBinding) break;

	        default:
	          {
	            var message = "Invalid left-hand side" + (contextDescription ? " in " + contextDescription : "expression");
	            this.raise(node.start, message);
	          }
	      }
	    }

	    return node;
	  };

	  _proto.toAssignableObjectExpressionProp = function toAssignableObjectExpressionProp(prop, isBinding, isLast) {
	    if (prop.type === "ObjectMethod") {
	      var error = prop.kind === "get" || prop.kind === "set" ? "Object pattern can't contain getter or setter" : "Object pattern can't contain methods";
	      this.raise(prop.key.start, error);
	    } else if (prop.type === "SpreadElement" && !isLast) {
	      this.raise(prop.start, "The rest element has to be the last element when destructuring");
	    } else {
	      this.toAssignable(prop, isBinding, "object destructuring pattern");
	    }
	  };

	  _proto.toAssignableList = function toAssignableList(exprList, isBinding, contextDescription) {
	    var end = exprList.length;

	    if (end) {
	      var last = exprList[end - 1];

	      if (last && last.type === "RestElement") {
	        --end;
	      } else if (last && last.type === "SpreadElement") {
	        last.type = "RestElement";
	        var arg = last.argument;
	        this.toAssignable(arg, isBinding, contextDescription);

	        if (["Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern"].indexOf(arg.type) === -1) {
	          this.unexpected(arg.start);
	        }

	        --end;
	      }
	    }

	    for (var i = 0; i < end; i++) {
	      var elt = exprList[i];

	      if (elt && elt.type === "SpreadElement") {
	        this.raise(elt.start, "The rest element has to be the last element when destructuring");
	      }

	      if (elt) this.toAssignable(elt, isBinding, contextDescription);
	    }

	    return exprList;
	  };

	  _proto.toReferencedList = function toReferencedList(exprList) {
	    return exprList;
	  };

	  _proto.parseSpread = function parseSpread(refShorthandDefaultPos, refNeedsArrowPos) {
	    var node = this.startNode();
	    this.next();
	    node.argument = this.parseMaybeAssign(false, refShorthandDefaultPos, undefined, refNeedsArrowPos);
	    return this.finishNode(node, "SpreadElement");
	  };

	  _proto.parseRest = function parseRest() {
	    var node = this.startNode();
	    this.next();
	    node.argument = this.parseBindingAtom();
	    return this.finishNode(node, "RestElement");
	  };

	  _proto.shouldAllowYieldIdentifier = function shouldAllowYieldIdentifier() {
	    return this.match(types._yield) && !this.state.strict && !this.state.inGenerator;
	  };

	  _proto.parseBindingIdentifier = function parseBindingIdentifier() {
	    return this.parseIdentifier(this.shouldAllowYieldIdentifier());
	  };

	  _proto.parseBindingAtom = function parseBindingAtom() {
	    switch (this.state.type) {
	      case types._yield:
	      case types.name:
	        return this.parseBindingIdentifier();

	      case types.bracketL:
	        {
	          var node = this.startNode();
	          this.next();
	          node.elements = this.parseBindingList(types.bracketR, true);
	          return this.finishNode(node, "ArrayPattern");
	        }

	      case types.braceL:
	        return this.parseObj(true);

	      default:
	        throw this.unexpected();
	    }
	  };

	  _proto.parseBindingList = function parseBindingList(close, allowEmpty, allowModifiers) {
	    var elts = [];
	    var first = true;

	    while (!this.eat(close)) {
	      if (first) {
	        first = false;
	      } else {
	        this.expect(types.comma);
	      }

	      if (allowEmpty && this.match(types.comma)) {
	        elts.push(null);
	      } else if (this.eat(close)) {
	        break;
	      } else if (this.match(types.ellipsis)) {
	        elts.push(this.parseAssignableListItemTypes(this.parseRest()));
	        this.expect(close);
	        break;
	      } else {
	        var decorators = [];

	        if (this.match(types.at) && this.hasPlugin("decorators")) {
	          this.raise(this.state.start, "Stage 2 decorators cannot be used to decorate parameters");
	        }

	        while (this.match(types.at)) {
	          decorators.push(this.parseDecorator());
	        }

	        elts.push(this.parseAssignableListItem(allowModifiers, decorators));
	      }
	    }

	    return elts;
	  };

	  _proto.parseAssignableListItem = function parseAssignableListItem(allowModifiers, decorators) {
	    var left = this.parseMaybeDefault();
	    this.parseAssignableListItemTypes(left);
	    var elt = this.parseMaybeDefault(left.start, left.loc.start, left);

	    if (decorators.length) {
	      left.decorators = decorators;
	    }

	    return elt;
	  };

	  _proto.parseAssignableListItemTypes = function parseAssignableListItemTypes(param) {
	    return param;
	  };

	  _proto.parseMaybeDefault = function parseMaybeDefault(startPos, startLoc, left) {
	    startLoc = startLoc || this.state.startLoc;
	    startPos = startPos || this.state.start;
	    left = left || this.parseBindingAtom();
	    if (!this.eat(types.eq)) return left;
	    var node = this.startNodeAt(startPos, startLoc);
	    node.left = left;
	    node.right = this.parseMaybeAssign();
	    return this.finishNode(node, "AssignmentPattern");
	  };

	  _proto.checkLVal = function checkLVal(expr, isBinding, checkClashes, contextDescription) {
	    switch (expr.type) {
	      case "Identifier":
	        this.checkReservedWord(expr.name, expr.start, false, true);

	        if (checkClashes) {
	          var _key = "_" + expr.name;

	          if (checkClashes[_key]) {
	            this.raise(expr.start, "Argument name clash in strict mode");
	          } else {
	            checkClashes[_key] = true;
	          }
	        }

	        break;

	      case "MemberExpression":
	        if (isBinding) this.raise(expr.start, "Binding member expression");
	        break;

	      case "ObjectPattern":
	        for (var _i2 = 0, _expr$properties2 = expr.properties; _i2 < _expr$properties2.length; _i2++) {
	          var prop = _expr$properties2[_i2];
	          if (prop.type === "ObjectProperty") prop = prop.value;
	          this.checkLVal(prop, isBinding, checkClashes, "object destructuring pattern");
	        }

	        break;

	      case "ArrayPattern":
	        for (var _i4 = 0, _expr$elements2 = expr.elements; _i4 < _expr$elements2.length; _i4++) {
	          var elem = _expr$elements2[_i4];

	          if (elem) {
	            this.checkLVal(elem, isBinding, checkClashes, "array destructuring pattern");
	          }
	        }

	        break;

	      case "AssignmentPattern":
	        this.checkLVal(expr.left, isBinding, checkClashes, "assignment pattern");
	        break;

	      case "RestElement":
	        this.checkLVal(expr.argument, isBinding, checkClashes, "rest element");
	        break;

	      default:
	        {
	          var message = (isBinding ? "Binding invalid" : "Invalid") + " left-hand side" + (contextDescription ? " in " + contextDescription : "expression");
	          this.raise(expr.start, message);
	        }
	    }
	  };

	  _proto.checkToRestConversion = function checkToRestConversion(node) {
	    var validArgumentTypes = ["Identifier", "MemberExpression"];

	    if (validArgumentTypes.indexOf(node.argument.type) !== -1) {
	      return;
	    }

	    this.raise(node.argument.start, "Invalid rest operator's argument");
	  };

	  return LValParser;
	}(NodeUtils);

	var ExpressionParser = function (_LValParser) {
	  _inheritsLoose(ExpressionParser, _LValParser);

	  function ExpressionParser() {
	    return _LValParser.apply(this, arguments) || this;
	  }

	  var _proto = ExpressionParser.prototype;

	  _proto.checkPropClash = function checkPropClash(prop, propHash) {
	    if (prop.computed || prop.kind) return;
	    var key = prop.key;
	    var name = key.type === "Identifier" ? key.name : String(key.value);

	    if (name === "__proto__") {
	      if (propHash.proto) {
	        this.raise(key.start, "Redefinition of __proto__ property");
	      }

	      propHash.proto = true;
	    }
	  };

	  _proto.getExpression = function getExpression() {
	    this.nextToken();
	    var expr = this.parseExpression();

	    if (!this.match(types.eof)) {
	      this.unexpected();
	    }

	    expr.comments = this.state.comments;
	    return expr;
	  };

	  _proto.parseExpression = function parseExpression(noIn, refShorthandDefaultPos) {
	    var startPos = this.state.start;
	    var startLoc = this.state.startLoc;
	    var expr = this.parseMaybeAssign(noIn, refShorthandDefaultPos);

	    if (this.match(types.comma)) {
	      var _node = this.startNodeAt(startPos, startLoc);

	      _node.expressions = [expr];

	      while (this.eat(types.comma)) {
	        _node.expressions.push(this.parseMaybeAssign(noIn, refShorthandDefaultPos));
	      }

	      this.toReferencedList(_node.expressions);
	      return this.finishNode(_node, "SequenceExpression");
	    }

	    return expr;
	  };

	  _proto.parseMaybeAssign = function parseMaybeAssign(noIn, refShorthandDefaultPos, afterLeftParse, refNeedsArrowPos) {
	    var startPos = this.state.start;
	    var startLoc = this.state.startLoc;

	    if (this.match(types._yield) && this.state.inGenerator) {
	      var _left = this.parseYield();

	      if (afterLeftParse) {
	        _left = afterLeftParse.call(this, _left, startPos, startLoc);
	      }

	      return _left;
	    }

	    var failOnShorthandAssign;

	    if (refShorthandDefaultPos) {
	      failOnShorthandAssign = false;
	    } else {
	      refShorthandDefaultPos = {
	        start: 0
	      };
	      failOnShorthandAssign = true;
	    }

	    if (this.match(types.parenL) || this.match(types.name) || this.match(types._yield)) {
	      this.state.potentialArrowAt = this.state.start;
	    }

	    var left = this.parseMaybeConditional(noIn, refShorthandDefaultPos, refNeedsArrowPos);

	    if (afterLeftParse) {
	      left = afterLeftParse.call(this, left, startPos, startLoc);
	    }

	    if (this.state.type.isAssign) {
	      var _node2 = this.startNodeAt(startPos, startLoc);

	      var operator = this.state.value;
	      _node2.operator = operator;

	      if (operator === "??=") {
	        this.expectPlugin("nullishCoalescingOperator");
	        this.expectPlugin("logicalAssignment");
	      }

	      if (operator === "||=" || operator === "&&=") {
	        this.expectPlugin("logicalAssignment");
	      }

	      _node2.left = this.match(types.eq) ? this.toAssignable(left, undefined, "assignment expression") : left;
	      refShorthandDefaultPos.start = 0;
	      this.checkLVal(left, undefined, undefined, "assignment expression");

	      if (left.extra && left.extra.parenthesized) {
	        var errorMsg;

	        if (left.type === "ObjectPattern") {
	          errorMsg = "`({a}) = 0` use `({a} = 0)`";
	        } else if (left.type === "ArrayPattern") {
	          errorMsg = "`([a]) = 0` use `([a] = 0)`";
	        }

	        if (errorMsg) {
	          this.raise(left.start, "You're trying to assign to a parenthesized expression, eg. instead of " + errorMsg);
	        }
	      }

	      this.next();
	      _node2.right = this.parseMaybeAssign(noIn);
	      return this.finishNode(_node2, "AssignmentExpression");
	    } else if (failOnShorthandAssign && refShorthandDefaultPos.start) {
	      this.unexpected(refShorthandDefaultPos.start);
	    }

	    return left;
	  };

	  _proto.parseMaybeConditional = function parseMaybeConditional(noIn, refShorthandDefaultPos, refNeedsArrowPos) {
	    var startPos = this.state.start;
	    var startLoc = this.state.startLoc;
	    var potentialArrowAt = this.state.potentialArrowAt;
	    var expr = this.parseExprOps(noIn, refShorthandDefaultPos);

	    if (expr.type === "ArrowFunctionExpression" && expr.start === potentialArrowAt) {
	      return expr;
	    }

	    if (refShorthandDefaultPos && refShorthandDefaultPos.start) return expr;
	    return this.parseConditional(expr, noIn, startPos, startLoc, refNeedsArrowPos);
	  };

	  _proto.parseConditional = function parseConditional(expr, noIn, startPos, startLoc, refNeedsArrowPos) {
	    if (this.eat(types.question)) {
	      var _node3 = this.startNodeAt(startPos, startLoc);

	      _node3.test = expr;
	      _node3.consequent = this.parseMaybeAssign();
	      this.expect(types.colon);
	      _node3.alternate = this.parseMaybeAssign(noIn);
	      return this.finishNode(_node3, "ConditionalExpression");
	    }

	    return expr;
	  };

	  _proto.parseExprOps = function parseExprOps(noIn, refShorthandDefaultPos) {
	    var startPos = this.state.start;
	    var startLoc = this.state.startLoc;
	    var potentialArrowAt = this.state.potentialArrowAt;
	    var expr = this.parseMaybeUnary(refShorthandDefaultPos);

	    if (expr.type === "ArrowFunctionExpression" && expr.start === potentialArrowAt) {
	      return expr;
	    }

	    if (refShorthandDefaultPos && refShorthandDefaultPos.start) {
	      return expr;
	    }

	    return this.parseExprOp(expr, startPos, startLoc, -1, noIn);
	  };

	  _proto.parseExprOp = function parseExprOp(left, leftStartPos, leftStartLoc, minPrec, noIn) {
	    var prec = this.state.type.binop;

	    if (prec != null && (!noIn || !this.match(types._in))) {
	      if (prec > minPrec) {
	        var _node4 = this.startNodeAt(leftStartPos, leftStartLoc);

	        var operator = this.state.value;
	        _node4.left = left;
	        _node4.operator = operator;

	        if (operator === "**" && left.type === "UnaryExpression" && !(left.extra && left.extra.parenthesized)) {
	          this.raise(left.argument.start, "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.");
	        }

	        var op = this.state.type;

	        if (op === types.nullishCoalescing) {
	          this.expectPlugin("nullishCoalescingOperator");
	        } else if (op === types.pipeline) {
	          this.expectPlugin("pipelineOperator");
	        }

	        this.next();
	        var startPos = this.state.start;
	        var startLoc = this.state.startLoc;

	        if (op === types.pipeline) {
	          if (this.match(types.name) && this.state.value === "await" && this.state.inAsync) {
	            throw this.raise(this.state.start, "Unexpected \"await\" after pipeline body; await must have parentheses in minimal proposal");
	          }
	        }

	        _node4.right = this.parseExprOp(this.parseMaybeUnary(), startPos, startLoc, op.rightAssociative ? prec - 1 : prec, noIn);
	        this.finishNode(_node4, op === types.logicalOR || op === types.logicalAND || op === types.nullishCoalescing ? "LogicalExpression" : "BinaryExpression");
	        return this.parseExprOp(_node4, leftStartPos, leftStartLoc, minPrec, noIn);
	      }
	    }

	    return left;
	  };

	  _proto.parseMaybeUnary = function parseMaybeUnary(refShorthandDefaultPos) {
	    if (this.state.type.prefix) {
	      var _node5 = this.startNode();

	      var update = this.match(types.incDec);
	      _node5.operator = this.state.value;
	      _node5.prefix = true;

	      if (_node5.operator === "throw") {
	        this.expectPlugin("throwExpressions");
	      }

	      this.next();
	      _node5.argument = this.parseMaybeUnary();

	      if (refShorthandDefaultPos && refShorthandDefaultPos.start) {
	        this.unexpected(refShorthandDefaultPos.start);
	      }

	      if (update) {
	        this.checkLVal(_node5.argument, undefined, undefined, "prefix operation");
	      } else if (this.state.strict && _node5.operator === "delete") {
	        var arg = _node5.argument;

	        if (arg.type === "Identifier") {
	          this.raise(_node5.start, "Deleting local variable in strict mode");
	        } else if (arg.type === "MemberExpression" && arg.property.type === "PrivateName") {
	          this.raise(_node5.start, "Deleting a private field is not allowed");
	        }
	      }

	      return this.finishNode(_node5, update ? "UpdateExpression" : "UnaryExpression");
	    }

	    var startPos = this.state.start;
	    var startLoc = this.state.startLoc;
	    var expr = this.parseExprSubscripts(refShorthandDefaultPos);
	    if (refShorthandDefaultPos && refShorthandDefaultPos.start) return expr;

	    while (this.state.type.postfix && !this.canInsertSemicolon()) {
	      var _node6 = this.startNodeAt(startPos, startLoc);

	      _node6.operator = this.state.value;
	      _node6.prefix = false;
	      _node6.argument = expr;
	      this.checkLVal(expr, undefined, undefined, "postfix operation");
	      this.next();
	      expr = this.finishNode(_node6, "UpdateExpression");
	    }

	    return expr;
	  };

	  _proto.parseExprSubscripts = function parseExprSubscripts(refShorthandDefaultPos) {
	    var startPos = this.state.start;
	    var startLoc = this.state.startLoc;
	    var potentialArrowAt = this.state.potentialArrowAt;
	    var expr = this.parseExprAtom(refShorthandDefaultPos);

	    if (expr.type === "ArrowFunctionExpression" && expr.start === potentialArrowAt) {
	      return expr;
	    }

	    if (refShorthandDefaultPos && refShorthandDefaultPos.start) {
	      return expr;
	    }

	    return this.parseSubscripts(expr, startPos, startLoc);
	  };

	  _proto.parseSubscripts = function parseSubscripts(base, startPos, startLoc, noCalls) {
	    var state = {
	      optionalChainMember: false,
	      stop: false
	    };

	    do {
	      base = this.parseSubscript(base, startPos, startLoc, noCalls, state);
	    } while (!state.stop);

	    return base;
	  };

	  _proto.parseSubscript = function parseSubscript(base, startPos, startLoc, noCalls, state) {
	    if (!noCalls && this.eat(types.doubleColon)) {
	      var _node7 = this.startNodeAt(startPos, startLoc);

	      _node7.object = base;
	      _node7.callee = this.parseNoCallExpr();
	      state.stop = true;
	      return this.parseSubscripts(this.finishNode(_node7, "BindExpression"), startPos, startLoc, noCalls);
	    } else if (this.match(types.questionDot)) {
	      this.expectPlugin("optionalChaining");
	      state.optionalChainMember = true;

	      if (noCalls && this.lookahead().type == types.parenL) {
	        state.stop = true;
	        return base;
	      }

	      this.next();

	      var _node8 = this.startNodeAt(startPos, startLoc);

	      if (this.eat(types.bracketL)) {
	        _node8.object = base;
	        _node8.property = this.parseExpression();
	        _node8.computed = true;
	        _node8.optional = true;
	        this.expect(types.bracketR);
	        return this.finishNode(_node8, "OptionalMemberExpression");
	      } else if (this.eat(types.parenL)) {
	        var possibleAsync = this.atPossibleAsync(base);
	        _node8.callee = base;
	        _node8.arguments = this.parseCallExpressionArguments(types.parenR, possibleAsync);
	        _node8.optional = true;
	        return this.finishNode(_node8, "OptionalCallExpression");
	      } else {
	        _node8.object = base;
	        _node8.property = this.parseIdentifier(true);
	        _node8.computed = false;
	        _node8.optional = true;
	        return this.finishNode(_node8, "OptionalMemberExpression");
	      }
	    } else if (this.eat(types.dot)) {
	      var _node9 = this.startNodeAt(startPos, startLoc);

	      _node9.object = base;
	      _node9.property = this.parseMaybePrivateName();
	      _node9.computed = false;

	      if (state.optionalChainMember) {
	        _node9.optional = false;
	        return this.finishNode(_node9, "OptionalMemberExpression");
	      }

	      return this.finishNode(_node9, "MemberExpression");
	    } else if (this.eat(types.bracketL)) {
	      var _node10 = this.startNodeAt(startPos, startLoc);

	      _node10.object = base;
	      _node10.property = this.parseExpression();
	      _node10.computed = true;
	      this.expect(types.bracketR);

	      if (state.optionalChainMember) {
	        _node10.optional = false;
	        return this.finishNode(_node10, "OptionalMemberExpression");
	      }

	      return this.finishNode(_node10, "MemberExpression");
	    } else if (!noCalls && this.match(types.parenL)) {
	      var _possibleAsync = this.atPossibleAsync(base);

	      this.next();

	      var _node11 = this.startNodeAt(startPos, startLoc);

	      _node11.callee = base;
	      var refTrailingCommaPos = {
	        start: -1
	      };
	      _node11.arguments = this.parseCallExpressionArguments(types.parenR, _possibleAsync, refTrailingCommaPos);

	      if (!state.optionalChainMember) {
	        this.finishCallExpression(_node11);
	      } else {
	        this.finishOptionalCallExpression(_node11);
	      }

	      if (_possibleAsync && this.shouldParseAsyncArrow()) {
	        state.stop = true;

	        if (refTrailingCommaPos.start > -1) {
	          this.raise(refTrailingCommaPos.start, "A trailing comma is not permitted after the rest element");
	        }

	        return this.parseAsyncArrowFromCallExpression(this.startNodeAt(startPos, startLoc), _node11);
	      } else {
	        this.toReferencedList(_node11.arguments);
	      }

	      return _node11;
	    } else if (this.match(types.backQuote)) {
	      return this.parseTaggedTemplateExpression(startPos, startLoc, base, state);
	    } else {
	      state.stop = true;
	      return base;
	    }
	  };

	  _proto.parseTaggedTemplateExpression = function parseTaggedTemplateExpression(startPos, startLoc, base, state, typeArguments) {
	    var node = this.startNodeAt(startPos, startLoc);
	    node.tag = base;
	    node.quasi = this.parseTemplate(true);
	    if (typeArguments) node.typeParameters = typeArguments;

	    if (state.optionalChainMember) {
	      this.raise(startPos, "Tagged Template Literals are not allowed in optionalChain");
	    }

	    return this.finishNode(node, "TaggedTemplateExpression");
	  };

	  _proto.atPossibleAsync = function atPossibleAsync(base) {
	    return !this.state.containsEsc && this.state.potentialArrowAt === base.start && base.type === "Identifier" && base.name === "async" && !this.canInsertSemicolon();
	  };

	  _proto.finishCallExpression = function finishCallExpression(node) {
	    if (node.callee.type === "Import") {
	      if (node.arguments.length !== 1) {
	        this.raise(node.start, "import() requires exactly one argument");
	      }

	      var importArg = node.arguments[0];

	      if (importArg && importArg.type === "SpreadElement") {
	        this.raise(importArg.start, "... is not allowed in import()");
	      }
	    }

	    return this.finishNode(node, "CallExpression");
	  };

	  _proto.finishOptionalCallExpression = function finishOptionalCallExpression(node) {
	    if (node.callee.type === "Import") {
	      if (node.arguments.length !== 1) {
	        this.raise(node.start, "import() requires exactly one argument");
	      }

	      var importArg = node.arguments[0];

	      if (importArg && importArg.type === "SpreadElement") {
	        this.raise(importArg.start, "... is not allowed in import()");
	      }
	    }

	    return this.finishNode(node, "OptionalCallExpression");
	  };

	  _proto.parseCallExpressionArguments = function parseCallExpressionArguments(close, possibleAsyncArrow, refTrailingCommaPos) {
	    var elts = [];
	    var innerParenStart;
	    var first = true;

	    while (!this.eat(close)) {
	      if (first) {
	        first = false;
	      } else {
	        this.expect(types.comma);
	        if (this.eat(close)) break;
	      }

	      if (this.match(types.parenL) && !innerParenStart) {
	        innerParenStart = this.state.start;
	      }

	      elts.push(this.parseExprListItem(false, possibleAsyncArrow ? {
	        start: 0
	      } : undefined, possibleAsyncArrow ? {
	        start: 0
	      } : undefined, possibleAsyncArrow ? refTrailingCommaPos : undefined));
	    }

	    if (possibleAsyncArrow && innerParenStart && this.shouldParseAsyncArrow()) {
	      this.unexpected();
	    }

	    return elts;
	  };

	  _proto.shouldParseAsyncArrow = function shouldParseAsyncArrow() {
	    return this.match(types.arrow);
	  };

	  _proto.parseAsyncArrowFromCallExpression = function parseAsyncArrowFromCallExpression(node, call) {
	    var oldYield = this.state.yieldInPossibleArrowParameters;
	    this.state.yieldInPossibleArrowParameters = null;
	    this.expect(types.arrow);
	    this.parseArrowExpression(node, call.arguments, true);
	    this.state.yieldInPossibleArrowParameters = oldYield;
	    return node;
	  };

	  _proto.parseNoCallExpr = function parseNoCallExpr() {
	    var startPos = this.state.start;
	    var startLoc = this.state.startLoc;
	    return this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);
	  };

	  _proto.parseExprAtom = function parseExprAtom(refShorthandDefaultPos) {
	    var canBeArrow = this.state.potentialArrowAt === this.state.start;
	    var node;

	    switch (this.state.type) {
	      case types._super:
	        if (!this.state.inMethod && !this.state.inClassProperty && !this.options.allowSuperOutsideMethod) {
	          this.raise(this.state.start, "super is only allowed in object methods and classes");
	        }

	        node = this.startNode();
	        this.next();

	        if (!this.match(types.parenL) && !this.match(types.bracketL) && !this.match(types.dot)) {
	          this.unexpected();
	        }

	        if (this.match(types.parenL) && this.state.inMethod !== "constructor" && !this.options.allowSuperOutsideMethod) {
	          this.raise(node.start, "super() is only valid inside a class constructor. " + "Make sure the method name is spelled exactly as 'constructor'.");
	        }

	        return this.finishNode(node, "Super");

	      case types._import:
	        if (this.lookahead().type === types.dot) {
	          return this.parseImportMetaProperty();
	        }

	        this.expectPlugin("dynamicImport");
	        node = this.startNode();
	        this.next();

	        if (!this.match(types.parenL)) {
	          this.unexpected(null, types.parenL);
	        }

	        return this.finishNode(node, "Import");

	      case types._this:
	        node = this.startNode();
	        this.next();
	        return this.finishNode(node, "ThisExpression");

	      case types._yield:
	        if (this.state.inGenerator) this.unexpected();

	      case types.name:
	        {
	          node = this.startNode();
	          var allowAwait = this.state.value === "await" && (this.state.inAsync || !this.state.inFunction && this.options.allowAwaitOutsideFunction);
	          var containsEsc = this.state.containsEsc;
	          var allowYield = this.shouldAllowYieldIdentifier();
	          var id = this.parseIdentifier(allowAwait || allowYield);

	          if (id.name === "await") {
	            if (this.state.inAsync || this.inModule || !this.state.inFunction && this.options.allowAwaitOutsideFunction) {
	              return this.parseAwait(node);
	            }
	          } else if (!containsEsc && id.name === "async" && this.match(types._function) && !this.canInsertSemicolon()) {
	            this.next();
	            return this.parseFunction(node, false, false, true);
	          } else if (canBeArrow && id.name === "async" && this.match(types.name)) {
	            var oldYield = this.state.yieldInPossibleArrowParameters;
	            this.state.yieldInPossibleArrowParameters = null;
	            var params = [this.parseIdentifier()];
	            this.expect(types.arrow);
	            this.parseArrowExpression(node, params, true);
	            this.state.yieldInPossibleArrowParameters = oldYield;
	            return node;
	          }

	          if (canBeArrow && !this.canInsertSemicolon() && this.eat(types.arrow)) {
	            var _oldYield = this.state.yieldInPossibleArrowParameters;
	            this.state.yieldInPossibleArrowParameters = null;
	            this.parseArrowExpression(node, [id]);
	            this.state.yieldInPossibleArrowParameters = _oldYield;
	            return node;
	          }

	          return id;
	        }

	      case types._do:
	        {
	          this.expectPlugin("doExpressions");

	          var _node12 = this.startNode();

	          this.next();
	          var oldInFunction = this.state.inFunction;
	          var oldLabels = this.state.labels;
	          this.state.labels = [];
	          this.state.inFunction = false;
	          _node12.body = this.parseBlock(false);
	          this.state.inFunction = oldInFunction;
	          this.state.labels = oldLabels;
	          return this.finishNode(_node12, "DoExpression");
	        }

	      case types.regexp:
	        {
	          var value = this.state.value;
	          node = this.parseLiteral(value.value, "RegExpLiteral");
	          node.pattern = value.pattern;
	          node.flags = value.flags;
	          return node;
	        }

	      case types.num:
	        return this.parseLiteral(this.state.value, "NumericLiteral");

	      case types.bigint:
	        return this.parseLiteral(this.state.value, "BigIntLiteral");

	      case types.string:
	        return this.parseLiteral(this.state.value, "StringLiteral");

	      case types._null:
	        node = this.startNode();
	        this.next();
	        return this.finishNode(node, "NullLiteral");

	      case types._true:
	      case types._false:
	        return this.parseBooleanLiteral();

	      case types.parenL:
	        return this.parseParenAndDistinguishExpression(canBeArrow);

	      case types.bracketL:
	        node = this.startNode();
	        this.next();
	        node.elements = this.parseExprList(types.bracketR, true, refShorthandDefaultPos);
	        this.toReferencedList(node.elements);
	        return this.finishNode(node, "ArrayExpression");

	      case types.braceL:
	        return this.parseObj(false, refShorthandDefaultPos);

	      case types._function:
	        return this.parseFunctionExpression();

	      case types.at:
	        this.parseDecorators();

	      case types._class:
	        node = this.startNode();
	        this.takeDecorators(node);
	        return this.parseClass(node, false);

	      case types._new:
	        return this.parseNew();

	      case types.backQuote:
	        return this.parseTemplate(false);

	      case types.doubleColon:
	        {
	          node = this.startNode();
	          this.next();
	          node.object = null;
	          var callee = node.callee = this.parseNoCallExpr();

	          if (callee.type === "MemberExpression") {
	            return this.finishNode(node, "BindExpression");
	          } else {
	            throw this.raise(callee.start, "Binding should be performed on object property.");
	          }
	        }

	      default:
	        throw this.unexpected();
	    }
	  };

	  _proto.parseBooleanLiteral = function parseBooleanLiteral() {
	    var node = this.startNode();
	    node.value = this.match(types._true);
	    this.next();
	    return this.finishNode(node, "BooleanLiteral");
	  };

	  _proto.parseMaybePrivateName = function parseMaybePrivateName() {
	    var isPrivate = this.match(types.hash);

	    if (isPrivate) {
	      this.expectOnePlugin(["classPrivateProperties", "classPrivateMethods"]);

	      var _node13 = this.startNode();

	      this.next();
	      _node13.id = this.parseIdentifier(true);
	      return this.finishNode(_node13, "PrivateName");
	    } else {
	      return this.parseIdentifier(true);
	    }
	  };

	  _proto.parseFunctionExpression = function parseFunctionExpression() {
	    var node = this.startNode();
	    var meta = this.parseIdentifier(true);

	    if (this.state.inGenerator && this.eat(types.dot)) {
	      return this.parseMetaProperty(node, meta, "sent");
	    }

	    return this.parseFunction(node, false);
	  };

	  _proto.parseMetaProperty = function parseMetaProperty(node, meta, propertyName) {
	    node.meta = meta;

	    if (meta.name === "function" && propertyName === "sent") {
	      if (this.isContextual(propertyName)) {
	        this.expectPlugin("functionSent");
	      } else if (!this.hasPlugin("functionSent")) {
	        this.unexpected();
	      }
	    }

	    var containsEsc = this.state.containsEsc;
	    node.property = this.parseIdentifier(true);

	    if (node.property.name !== propertyName || containsEsc) {
	      this.raise(node.property.start, "The only valid meta property for " + meta.name + " is " + meta.name + "." + propertyName);
	    }

	    return this.finishNode(node, "MetaProperty");
	  };

	  _proto.parseImportMetaProperty = function parseImportMetaProperty() {
	    var node = this.startNode();
	    var id = this.parseIdentifier(true);
	    this.expect(types.dot);

	    if (id.name === "import") {
	      if (this.isContextual("meta")) {
	        this.expectPlugin("importMeta");
	      } else if (!this.hasPlugin("importMeta")) {
	        this.raise(id.start, "Dynamic imports require a parameter: import('a.js')");
	      }
	    }

	    if (!this.inModule) {
	      this.raise(id.start, "import.meta may appear only with 'sourceType: \"module\"'", {
	        code: "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED"
	      });
	    }

	    this.sawUnambiguousESM = true;
	    return this.parseMetaProperty(node, id, "meta");
	  };

	  _proto.parseLiteral = function parseLiteral(value, type, startPos, startLoc) {
	    startPos = startPos || this.state.start;
	    startLoc = startLoc || this.state.startLoc;
	    var node = this.startNodeAt(startPos, startLoc);
	    this.addExtra(node, "rawValue", value);
	    this.addExtra(node, "raw", this.input.slice(startPos, this.state.end));
	    node.value = value;
	    this.next();
	    return this.finishNode(node, type);
	  };

	  _proto.parseParenExpression = function parseParenExpression() {
	    this.expect(types.parenL);
	    var val = this.parseExpression();
	    this.expect(types.parenR);
	    return val;
	  };

	  _proto.parseParenAndDistinguishExpression = function parseParenAndDistinguishExpression(canBeArrow) {
	    var startPos = this.state.start;
	    var startLoc = this.state.startLoc;
	    var val;
	    this.expect(types.parenL);
	    var oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
	    var oldYield = this.state.yieldInPossibleArrowParameters;
	    this.state.maybeInArrowParameters = true;
	    this.state.yieldInPossibleArrowParameters = null;
	    var innerStartPos = this.state.start;
	    var innerStartLoc = this.state.startLoc;
	    var exprList = [];
	    var refShorthandDefaultPos = {
	      start: 0
	    };
	    var refNeedsArrowPos = {
	      start: 0
	    };
	    var first = true;
	    var spreadStart;
	    var optionalCommaStart;

	    while (!this.match(types.parenR)) {
	      if (first) {
	        first = false;
	      } else {
	        this.expect(types.comma, refNeedsArrowPos.start || null);

	        if (this.match(types.parenR)) {
	          optionalCommaStart = this.state.start;
	          break;
	        }
	      }

	      if (this.match(types.ellipsis)) {
	        var spreadNodeStartPos = this.state.start;
	        var spreadNodeStartLoc = this.state.startLoc;
	        spreadStart = this.state.start;
	        exprList.push(this.parseParenItem(this.parseRest(), spreadNodeStartPos, spreadNodeStartLoc));

	        if (this.match(types.comma) && this.lookahead().type === types.parenR) {
	          this.raise(this.state.start, "A trailing comma is not permitted after the rest element");
	        }

	        break;
	      } else {
	        exprList.push(this.parseMaybeAssign(false, refShorthandDefaultPos, this.parseParenItem, refNeedsArrowPos));
	      }
	    }

	    var innerEndPos = this.state.start;
	    var innerEndLoc = this.state.startLoc;
	    this.expect(types.parenR);
	    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
	    var arrowNode = this.startNodeAt(startPos, startLoc);

	    if (canBeArrow && this.shouldParseArrow() && (arrowNode = this.parseArrow(arrowNode))) {
	      for (var _i2 = 0; _i2 < exprList.length; _i2++) {
	        var param = exprList[_i2];

	        if (param.extra && param.extra.parenthesized) {
	          this.unexpected(param.extra.parenStart);
	        }
	      }

	      this.parseArrowExpression(arrowNode, exprList);
	      this.state.yieldInPossibleArrowParameters = oldYield;
	      return arrowNode;
	    }

	    this.state.yieldInPossibleArrowParameters = oldYield;

	    if (!exprList.length) {
	      this.unexpected(this.state.lastTokStart);
	    }

	    if (optionalCommaStart) this.unexpected(optionalCommaStart);
	    if (spreadStart) this.unexpected(spreadStart);

	    if (refShorthandDefaultPos.start) {
	      this.unexpected(refShorthandDefaultPos.start);
	    }

	    if (refNeedsArrowPos.start) this.unexpected(refNeedsArrowPos.start);

	    if (exprList.length > 1) {
	      val = this.startNodeAt(innerStartPos, innerStartLoc);
	      val.expressions = exprList;
	      this.toReferencedList(val.expressions);
	      this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
	    } else {
	      val = exprList[0];
	    }

	    this.addExtra(val, "parenthesized", true);
	    this.addExtra(val, "parenStart", startPos);
	    return val;
	  };

	  _proto.shouldParseArrow = function shouldParseArrow() {
	    return !this.canInsertSemicolon();
	  };

	  _proto.parseArrow = function parseArrow(node) {
	    if (this.eat(types.arrow)) {
	      return node;
	    }
	  };

	  _proto.parseParenItem = function parseParenItem(node, startPos, startLoc) {
	    return node;
	  };

	  _proto.parseNew = function parseNew() {
	    var node = this.startNode();
	    var meta = this.parseIdentifier(true);

	    if (this.eat(types.dot)) {
	      var metaProp = this.parseMetaProperty(node, meta, "target");

	      if (!this.state.inFunction && !this.state.inClassProperty) {
	        var error = "new.target can only be used in functions";

	        if (this.hasPlugin("classProperties")) {
	          error += " or class properties";
	        }

	        this.raise(metaProp.start, error);
	      }

	      return metaProp;
	    }

	    node.callee = this.parseNoCallExpr();

	    if (node.callee.type === "OptionalMemberExpression" || node.callee.type === "OptionalCallExpression") {
	      this.raise(this.state.lastTokEnd, "constructors in/after an Optional Chain are not allowed");
	    }

	    if (this.eat(types.questionDot)) {
	      this.raise(this.state.start, "constructors in/after an Optional Chain are not allowed");
	    }

	    this.parseNewArguments(node);
	    return this.finishNode(node, "NewExpression");
	  };

	  _proto.parseNewArguments = function parseNewArguments(node) {
	    if (this.eat(types.parenL)) {
	      var args = this.parseExprList(types.parenR);
	      this.toReferencedList(args);
	      node.arguments = args;
	    } else {
	      node.arguments = [];
	    }
	  };

	  _proto.parseTemplateElement = function parseTemplateElement(isTagged) {
	    var elem = this.startNode();

	    if (this.state.value === null) {
	      if (!isTagged) {
	        this.raise(this.state.invalidTemplateEscapePosition || 0, "Invalid escape sequence in template");
	      } else {
	        this.state.invalidTemplateEscapePosition = null;
	      }
	    }

	    elem.value = {
	      raw: this.input.slice(this.state.start, this.state.end).replace(/\r\n?/g, "\n"),
	      cooked: this.state.value
	    };
	    this.next();
	    elem.tail = this.match(types.backQuote);
	    return this.finishNode(elem, "TemplateElement");
	  };

	  _proto.parseTemplate = function parseTemplate(isTagged) {
	    var node = this.startNode();
	    this.next();
	    node.expressions = [];
	    var curElt = this.parseTemplateElement(isTagged);
	    node.quasis = [curElt];

	    while (!curElt.tail) {
	      this.expect(types.dollarBraceL);
	      node.expressions.push(this.parseExpression());
	      this.expect(types.braceR);
	      node.quasis.push(curElt = this.parseTemplateElement(isTagged));
	    }

	    this.next();
	    return this.finishNode(node, "TemplateLiteral");
	  };

	  _proto.parseObj = function parseObj(isPattern, refShorthandDefaultPos) {
	    var decorators = [];
	    var propHash = Object.create(null);
	    var first = true;
	    var node = this.startNode();
	    node.properties = [];
	    this.next();
	    var firstRestLocation = null;

	    while (!this.eat(types.braceR)) {
	      if (first) {
	        first = false;
	      } else {
	        this.expect(types.comma);
	        if (this.eat(types.braceR)) break;
	      }

	      if (this.match(types.at)) {
	        if (this.hasPlugin("decorators")) {
	          this.raise(this.state.start, "Stage 2 decorators disallow object literal property decorators");
	        } else {
	          while (this.match(types.at)) {
	            decorators.push(this.parseDecorator());
	          }
	        }
	      }

	      var prop = this.startNode(),
	          isGenerator = false,
	          _isAsync = false,
	          startPos = void 0,
	          startLoc = void 0;

	      if (decorators.length) {
	        prop.decorators = decorators;
	        decorators = [];
	      }

	      if (this.match(types.ellipsis)) {
	        this.expectPlugin("objectRestSpread");
	        prop = this.parseSpread(isPattern ? {
	          start: 0
	        } : undefined);

	        if (isPattern) {
	          this.toAssignable(prop, true, "object pattern");
	        }

	        node.properties.push(prop);

	        if (isPattern) {
	          var position = this.state.start;

	          if (firstRestLocation !== null) {
	            this.unexpected(firstRestLocation, "Cannot have multiple rest elements when destructuring");
	          } else if (this.eat(types.braceR)) {
	            break;
	          } else if (this.match(types.comma) && this.lookahead().type === types.braceR) {
	            this.unexpected(position, "A trailing comma is not permitted after the rest element");
	          } else {
	            firstRestLocation = position;
	            continue;
	          }
	        } else {
	          continue;
	        }
	      }

	      prop.method = false;

	      if (isPattern || refShorthandDefaultPos) {
	        startPos = this.state.start;
	        startLoc = this.state.startLoc;
	      }

	      if (!isPattern) {
	        isGenerator = this.eat(types.star);
	      }

	      var containsEsc = this.state.containsEsc;

	      if (!isPattern && this.isContextual("async")) {
	        if (isGenerator) this.unexpected();
	        var asyncId = this.parseIdentifier();

	        if (this.match(types.colon) || this.match(types.parenL) || this.match(types.braceR) || this.match(types.eq) || this.match(types.comma)) {
	          prop.key = asyncId;
	          prop.computed = false;
	        } else {
	          _isAsync = true;

	          if (this.match(types.star)) {
	            this.expectPlugin("asyncGenerators");
	            this.next();
	            isGenerator = true;
	          }

	          this.parsePropertyName(prop);
	        }
	      } else {
	        this.parsePropertyName(prop);
	      }

	      this.parseObjPropValue(prop, startPos, startLoc, isGenerator, _isAsync, isPattern, refShorthandDefaultPos, containsEsc);
	      this.checkPropClash(prop, propHash);

	      if (prop.shorthand) {
	        this.addExtra(prop, "shorthand", true);
	      }

	      node.properties.push(prop);
	    }

	    if (firstRestLocation !== null) {
	      this.unexpected(firstRestLocation, "The rest element has to be the last element when destructuring");
	    }

	    if (decorators.length) {
	      this.raise(this.state.start, "You have trailing decorators with no property");
	    }

	    return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression");
	  };

	  _proto.isGetterOrSetterMethod = function isGetterOrSetterMethod(prop, isPattern) {
	    return !isPattern && !prop.computed && prop.key.type === "Identifier" && (prop.key.name === "get" || prop.key.name === "set") && (this.match(types.string) || this.match(types.num) || this.match(types.bracketL) || this.match(types.name) || !!this.state.type.keyword);
	  };

	  _proto.checkGetterSetterParams = function checkGetterSetterParams(method) {
	    var paramCount = method.kind === "get" ? 0 : 1;
	    var start = method.start;

	    if (method.params.length !== paramCount) {
	      if (method.kind === "get") {
	        this.raise(start, "getter must not have any formal parameters");
	      } else {
	        this.raise(start, "setter must have exactly one formal parameter");
	      }
	    }

	    if (method.kind === "set" && method.params[0].type === "RestElement") {
	      this.raise(start, "setter function argument must not be a rest parameter");
	    }
	  };

	  _proto.parseObjectMethod = function parseObjectMethod(prop, isGenerator, isAsync, isPattern, containsEsc) {
	    if (isAsync || isGenerator || this.match(types.parenL)) {
	      if (isPattern) this.unexpected();
	      prop.kind = "method";
	      prop.method = true;
	      return this.parseMethod(prop, isGenerator, isAsync, false, "ObjectMethod");
	    }

	    if (!containsEsc && this.isGetterOrSetterMethod(prop, isPattern)) {
	      if (isGenerator || isAsync) this.unexpected();
	      prop.kind = prop.key.name;
	      this.parsePropertyName(prop);
	      this.parseMethod(prop, false, false, false, "ObjectMethod");
	      this.checkGetterSetterParams(prop);
	      return prop;
	    }
	  };

	  _proto.parseObjectProperty = function parseObjectProperty(prop, startPos, startLoc, isPattern, refShorthandDefaultPos) {
	    prop.shorthand = false;

	    if (this.eat(types.colon)) {
	      prop.value = isPattern ? this.parseMaybeDefault(this.state.start, this.state.startLoc) : this.parseMaybeAssign(false, refShorthandDefaultPos);
	      return this.finishNode(prop, "ObjectProperty");
	    }

	    if (!prop.computed && prop.key.type === "Identifier") {
	      this.checkReservedWord(prop.key.name, prop.key.start, true, true);

	      if (isPattern) {
	        prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key.__clone());
	      } else if (this.match(types.eq) && refShorthandDefaultPos) {
	        if (!refShorthandDefaultPos.start) {
	          refShorthandDefaultPos.start = this.state.start;
	        }

	        prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key.__clone());
	      } else {
	        prop.value = prop.key.__clone();
	      }

	      prop.shorthand = true;
	      return this.finishNode(prop, "ObjectProperty");
	    }
	  };

	  _proto.parseObjPropValue = function parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, refShorthandDefaultPos, containsEsc) {
	    var node = this.parseObjectMethod(prop, isGenerator, isAsync, isPattern, containsEsc) || this.parseObjectProperty(prop, startPos, startLoc, isPattern, refShorthandDefaultPos);
	    if (!node) this.unexpected();
	    return node;
	  };

	  _proto.parsePropertyName = function parsePropertyName(prop) {
	    if (this.eat(types.bracketL)) {
	      prop.computed = true;
	      prop.key = this.parseMaybeAssign();
	      this.expect(types.bracketR);
	    } else {
	      var oldInPropertyName = this.state.inPropertyName;
	      this.state.inPropertyName = true;
	      prop.key = this.match(types.num) || this.match(types.string) ? this.parseExprAtom() : this.parseMaybePrivateName();

	      if (prop.key.type !== "PrivateName") {
	        prop.computed = false;
	      }

	      this.state.inPropertyName = oldInPropertyName;
	    }

	    return prop.key;
	  };

	  _proto.initFunction = function initFunction(node, isAsync) {
	    node.id = null;
	    node.generator = false;
	    node.async = !!isAsync;
	  };

	  _proto.parseMethod = function parseMethod(node, isGenerator, isAsync, isConstructor, type) {
	    var oldInFunc = this.state.inFunction;
	    var oldInMethod = this.state.inMethod;
	    var oldInGenerator = this.state.inGenerator;
	    this.state.inFunction = true;
	    this.state.inMethod = node.kind || true;
	    this.state.inGenerator = isGenerator;
	    this.initFunction(node, isAsync);
	    node.generator = !!isGenerator;
	    var allowModifiers = isConstructor;
	    this.parseFunctionParams(node, allowModifiers);
	    this.parseFunctionBodyAndFinish(node, type);
	    this.state.inFunction = oldInFunc;
	    this.state.inMethod = oldInMethod;
	    this.state.inGenerator = oldInGenerator;
	    return node;
	  };

	  _proto.parseArrowExpression = function parseArrowExpression(node, params, isAsync) {
	    if (this.state.yieldInPossibleArrowParameters) {
	      this.raise(this.state.yieldInPossibleArrowParameters.start, "yield is not allowed in the parameters of an arrow function" + " inside a generator");
	    }

	    var oldInFunc = this.state.inFunction;
	    this.state.inFunction = true;
	    this.initFunction(node, isAsync);
	    if (params) this.setArrowFunctionParameters(node, params);
	    var oldInGenerator = this.state.inGenerator;
	    var oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
	    this.state.inGenerator = false;
	    this.state.maybeInArrowParameters = false;
	    this.parseFunctionBody(node, true);
	    this.state.inGenerator = oldInGenerator;
	    this.state.inFunction = oldInFunc;
	    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
	    return this.finishNode(node, "ArrowFunctionExpression");
	  };

	  _proto.setArrowFunctionParameters = function setArrowFunctionParameters(node, params) {
	    node.params = this.toAssignableList(params, true, "arrow function parameters");
	  };

	  _proto.isStrictBody = function isStrictBody(node) {
	    var isBlockStatement = node.body.type === "BlockStatement";

	    if (isBlockStatement && node.body.directives.length) {
	      for (var _i4 = 0, _node$body$directives2 = node.body.directives; _i4 < _node$body$directives2.length; _i4++) {
	        var directive = _node$body$directives2[_i4];

	        if (directive.value.value === "use strict") {
	          return true;
	        }
	      }
	    }

	    return false;
	  };

	  _proto.parseFunctionBodyAndFinish = function parseFunctionBodyAndFinish(node, type, allowExpressionBody) {
	    this.parseFunctionBody(node, allowExpressionBody);
	    this.finishNode(node, type);
	  };

	  _proto.parseFunctionBody = function parseFunctionBody(node, allowExpression) {
	    var isExpression = allowExpression && !this.match(types.braceL);
	    var oldInParameters = this.state.inParameters;
	    var oldInAsync = this.state.inAsync;
	    this.state.inParameters = false;
	    this.state.inAsync = node.async;

	    if (isExpression) {
	      node.body = this.parseMaybeAssign();
	    } else {
	      var oldInGen = this.state.inGenerator;
	      var oldInFunc = this.state.inFunction;
	      var oldLabels = this.state.labels;
	      this.state.inGenerator = node.generator;
	      this.state.inFunction = true;
	      this.state.labels = [];
	      node.body = this.parseBlock(true);
	      this.state.inFunction = oldInFunc;
	      this.state.inGenerator = oldInGen;
	      this.state.labels = oldLabels;
	    }

	    this.state.inAsync = oldInAsync;
	    this.checkFunctionNameAndParams(node, allowExpression);
	    this.state.inParameters = oldInParameters;
	  };

	  _proto.checkFunctionNameAndParams = function checkFunctionNameAndParams(node, isArrowFunction) {
	    var isStrict = this.isStrictBody(node);
	    var checkLVal = this.state.strict || isStrict || isArrowFunction;
	    var oldStrict = this.state.strict;
	    if (isStrict) this.state.strict = isStrict;

	    if (checkLVal) {
	      var nameHash = Object.create(null);

	      if (node.id) {
	        this.checkLVal(node.id, true, undefined, "function name");
	      }

	      for (var _i6 = 0, _node$params2 = node.params; _i6 < _node$params2.length; _i6++) {
	        var param = _node$params2[_i6];

	        if (isStrict && param.type !== "Identifier") {
	          this.raise(param.start, "Non-simple parameter in strict mode");
	        }

	        this.checkLVal(param, true, nameHash, "function parameter list");
	      }
	    }

	    this.state.strict = oldStrict;
	  };

	  _proto.parseExprList = function parseExprList(close, allowEmpty, refShorthandDefaultPos) {
	    var elts = [];
	    var first = true;

	    while (!this.eat(close)) {
	      if (first) {
	        first = false;
	      } else {
	        this.expect(types.comma);
	        if (this.eat(close)) break;
	      }

	      elts.push(this.parseExprListItem(allowEmpty, refShorthandDefaultPos));
	    }

	    return elts;
	  };

	  _proto.parseExprListItem = function parseExprListItem(allowEmpty, refShorthandDefaultPos, refNeedsArrowPos, refTrailingCommaPos) {
	    var elt;

	    if (allowEmpty && this.match(types.comma)) {
	      elt = null;
	    } else if (this.match(types.ellipsis)) {
	      var spreadNodeStartPos = this.state.start;
	      var spreadNodeStartLoc = this.state.startLoc;
	      elt = this.parseParenItem(this.parseSpread(refShorthandDefaultPos, refNeedsArrowPos), spreadNodeStartPos, spreadNodeStartLoc);

	      if (refTrailingCommaPos && this.match(types.comma)) {
	        refTrailingCommaPos.start = this.state.start;
	      }
	    } else {
	      elt = this.parseMaybeAssign(false, refShorthandDefaultPos, this.parseParenItem, refNeedsArrowPos);
	    }

	    return elt;
	  };

	  _proto.parseIdentifier = function parseIdentifier(liberal) {
	    var node = this.startNode();
	    var name = this.parseIdentifierName(node.start, liberal);
	    node.name = name;
	    node.loc.identifierName = name;
	    return this.finishNode(node, "Identifier");
	  };

	  _proto.parseIdentifierName = function parseIdentifierName(pos, liberal) {
	    if (!liberal) {
	      this.checkReservedWord(this.state.value, this.state.start, !!this.state.type.keyword, false);
	    }

	    var name;

	    if (this.match(types.name)) {
	      name = this.state.value;
	    } else if (this.state.type.keyword) {
	      name = this.state.type.keyword;
	    } else {
	      throw this.unexpected();
	    }

	    if (!liberal && name === "await" && this.state.inAsync) {
	      this.raise(pos, "invalid use of await inside of an async function");
	    }

	    this.next();
	    return name;
	  };

	  _proto.checkReservedWord = function checkReservedWord(word, startLoc, checkKeywords, isBinding) {
	    if (this.state.strict && (reservedWords.strict(word) || isBinding && reservedWords.strictBind(word))) {
	      this.raise(startLoc, word + " is a reserved word in strict mode");
	    }

	    if (this.state.inGenerator && word === "yield") {
	      this.raise(startLoc, "yield is a reserved word inside generator functions");
	    }

	    if (this.state.inClassProperty && word === "arguments") {
	      this.raise(startLoc, "'arguments' is not allowed in class field initializer");
	    }

	    if (this.isReservedWord(word) || checkKeywords && this.isKeyword(word)) {
	      this.raise(startLoc, word + " is a reserved word");
	    }
	  };

	  _proto.parseAwait = function parseAwait(node) {
	    if (!this.state.inAsync && (this.state.inFunction || !this.options.allowAwaitOutsideFunction)) {
	      this.unexpected();
	    }

	    if (this.match(types.star)) {
	      this.raise(node.start, "await* has been removed from the async functions proposal. Use Promise.all() instead.");
	    }

	    node.argument = this.parseMaybeUnary();
	    return this.finishNode(node, "AwaitExpression");
	  };

	  _proto.parseYield = function parseYield() {
	    var node = this.startNode();

	    if (this.state.inParameters) {
	      this.raise(node.start, "yield is not allowed in generator parameters");
	    }

	    if (this.state.maybeInArrowParameters && !this.state.yieldInPossibleArrowParameters) {
	      this.state.yieldInPossibleArrowParameters = node;
	    }

	    this.next();

	    if (this.match(types.semi) || this.canInsertSemicolon() || !this.match(types.star) && !this.state.type.startsExpr) {
	      node.delegate = false;
	      node.argument = null;
	    } else {
	      node.delegate = this.eat(types.star);
	      node.argument = this.parseMaybeAssign();
	    }

	    return this.finishNode(node, "YieldExpression");
	  };

	  return ExpressionParser;
	}(LValParser);

	var empty = [];
	var loopLabel = {
	  kind: "loop"
	};
	var switchLabel = {
	  kind: "switch"
	};

	var StatementParser = function (_ExpressionParser) {
	  _inheritsLoose(StatementParser, _ExpressionParser);

	  function StatementParser() {
	    return _ExpressionParser.apply(this, arguments) || this;
	  }

	  var _proto = StatementParser.prototype;

	  _proto.parseTopLevel = function parseTopLevel(file, program) {
	    program.sourceType = this.options.sourceType;
	    program.interpreter = this.parseInterpreterDirective();
	    this.parseBlockBody(program, true, true, types.eof);
	    file.program = this.finishNode(program, "Program");
	    file.comments = this.state.comments;
	    if (this.options.tokens) file.tokens = this.state.tokens;
	    return this.finishNode(file, "File");
	  };

	  _proto.stmtToDirective = function stmtToDirective(stmt) {
	    var expr = stmt.expression;
	    var directiveLiteral = this.startNodeAt(expr.start, expr.loc.start);
	    var directive = this.startNodeAt(stmt.start, stmt.loc.start);
	    var raw = this.input.slice(expr.start, expr.end);
	    var val = directiveLiteral.value = raw.slice(1, -1);
	    this.addExtra(directiveLiteral, "raw", raw);
	    this.addExtra(directiveLiteral, "rawValue", val);
	    directive.value = this.finishNodeAt(directiveLiteral, "DirectiveLiteral", expr.end, expr.loc.end);
	    return this.finishNodeAt(directive, "Directive", stmt.end, stmt.loc.end);
	  };

	  _proto.parseInterpreterDirective = function parseInterpreterDirective() {
	    if (!this.match(types.interpreterDirective)) {
	      return null;
	    }

	    var node = this.startNode();
	    node.value = this.state.value;
	    this.next();
	    return this.finishNode(node, "InterpreterDirective");
	  };

	  _proto.parseStatement = function parseStatement(declaration, topLevel) {
	    if (this.match(types.at)) {
	      this.parseDecorators(true);
	    }

	    return this.parseStatementContent(declaration, topLevel);
	  };

	  _proto.parseStatementContent = function parseStatementContent(declaration, topLevel) {
	    var starttype = this.state.type;
	    var node = this.startNode();

	    switch (starttype) {
	      case types._break:
	      case types._continue:
	        return this.parseBreakContinueStatement(node, starttype.keyword);

	      case types._debugger:
	        return this.parseDebuggerStatement(node);

	      case types._do:
	        return this.parseDoStatement(node);

	      case types._for:
	        return this.parseForStatement(node);

	      case types._function:
	        if (this.lookahead().type === types.dot) break;
	        if (!declaration) this.unexpected();
	        return this.parseFunctionStatement(node);

	      case types._class:
	        if (!declaration) this.unexpected();
	        return this.parseClass(node, true);

	      case types._if:
	        return this.parseIfStatement(node);

	      case types._return:
	        return this.parseReturnStatement(node);

	      case types._switch:
	        return this.parseSwitchStatement(node);

	      case types._throw:
	        return this.parseThrowStatement(node);

	      case types._try:
	        return this.parseTryStatement(node);

	      case types._let:
	      case types._const:
	        if (!declaration) this.unexpected();

	      case types._var:
	        return this.parseVarStatement(node, starttype);

	      case types._while:
	        return this.parseWhileStatement(node);

	      case types._with:
	        return this.parseWithStatement(node);

	      case types.braceL:
	        return this.parseBlock();

	      case types.semi:
	        return this.parseEmptyStatement(node);

	      case types._export:
	      case types._import:
	        {
	          var nextToken = this.lookahead();

	          if (nextToken.type === types.parenL || nextToken.type === types.dot) {
	            break;
	          }

	          if (!this.options.allowImportExportEverywhere && !topLevel) {
	            this.raise(this.state.start, "'import' and 'export' may only appear at the top level");
	          }

	          this.next();
	          var result;

	          if (starttype == types._import) {
	            result = this.parseImport(node);

	            if (result.type === "ImportDeclaration" && (!result.importKind || result.importKind === "value")) {
	              this.sawUnambiguousESM = true;
	            }
	          } else {
	            result = this.parseExport(node);

	            if (result.type === "ExportNamedDeclaration" && (!result.exportKind || result.exportKind === "value") || result.type === "ExportAllDeclaration" && (!result.exportKind || result.exportKind === "value") || result.type === "ExportDefaultDeclaration") {
	              this.sawUnambiguousESM = true;
	            }
	          }

	          this.assertModuleNodeAllowed(node);
	          return result;
	        }

	      case types.name:
	        if (this.isContextual("async")) {
	          var state = this.state.clone();
	          this.next();

	          if (this.match(types._function) && !this.canInsertSemicolon()) {
	            this.expect(types._function);
	            return this.parseFunction(node, true, false, true);
	          } else {
	            this.state = state;
	          }
	        }

	    }

	    var maybeName = this.state.value;
	    var expr = this.parseExpression();

	    if (starttype === types.name && expr.type === "Identifier" && this.eat(types.colon)) {
	      return this.parseLabeledStatement(node, maybeName, expr);
	    } else {
	      return this.parseExpressionStatement(node, expr);
	    }
	  };

	  _proto.assertModuleNodeAllowed = function assertModuleNodeAllowed(node) {
	    if (!this.options.allowImportExportEverywhere && !this.inModule) {
	      this.raise(node.start, "'import' and 'export' may appear only with 'sourceType: \"module\"'", {
	        code: "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED"
	      });
	    }
	  };

	  _proto.takeDecorators = function takeDecorators(node) {
	    var decorators = this.state.decoratorStack[this.state.decoratorStack.length - 1];

	    if (decorators.length) {
	      node.decorators = decorators;
	      this.resetStartLocationFromNode(node, decorators[0]);
	      this.state.decoratorStack[this.state.decoratorStack.length - 1] = [];
	    }
	  };

	  _proto.canHaveLeadingDecorator = function canHaveLeadingDecorator() {
	    return this.match(types._class);
	  };

	  _proto.parseDecorators = function parseDecorators(allowExport) {
	    var currentContextDecorators = this.state.decoratorStack[this.state.decoratorStack.length - 1];

	    while (this.match(types.at)) {
	      var decorator = this.parseDecorator();
	      currentContextDecorators.push(decorator);
	    }

	    if (this.match(types._export)) {
	      if (!allowExport) {
	        this.unexpected();
	      }

	      if (this.hasPlugin("decorators") && !this.getPluginOption("decorators", "decoratorsBeforeExport")) {
	        this.raise(this.state.start, "Using the export keyword between a decorator and a class is not allowed. " + "Please use `export @dec class` instead.");
	      }
	    } else if (!this.canHaveLeadingDecorator()) {
	      this.raise(this.state.start, "Leading decorators must be attached to a class declaration");
	    }
	  };

	  _proto.parseDecorator = function parseDecorator() {
	    this.expectOnePlugin(["decorators-legacy", "decorators"]);
	    var node = this.startNode();
	    this.next();

	    if (this.hasPlugin("decorators")) {
	      this.state.decoratorStack.push([]);
	      var startPos = this.state.start;
	      var startLoc = this.state.startLoc;
	      var expr;

	      if (this.eat(types.parenL)) {
	        expr = this.parseExpression();
	        this.expect(types.parenR);
	      } else {
	        expr = this.parseIdentifier(false);

	        while (this.eat(types.dot)) {
	          var _node = this.startNodeAt(startPos, startLoc);

	          _node.object = expr;
	          _node.property = this.parseIdentifier(true);
	          _node.computed = false;
	          expr = this.finishNode(_node, "MemberExpression");
	        }
	      }

	      if (this.eat(types.parenL)) {
	        var _node2 = this.startNodeAt(startPos, startLoc);

	        _node2.callee = expr;
	        _node2.arguments = this.parseCallExpressionArguments(types.parenR, false);
	        this.toReferencedList(_node2.arguments);
	        expr = this.finishNode(_node2, "CallExpression");
	      }

	      node.expression = expr;
	      this.state.decoratorStack.pop();
	    } else {
	      node.expression = this.parseMaybeAssign();
	    }

	    return this.finishNode(node, "Decorator");
	  };

	  _proto.parseBreakContinueStatement = function parseBreakContinueStatement(node, keyword) {
	    var isBreak = keyword === "break";
	    this.next();

	    if (this.isLineTerminator()) {
	      node.label = null;
	    } else if (!this.match(types.name)) {
	      this.unexpected();
	    } else {
	      node.label = this.parseIdentifier();
	      this.semicolon();
	    }

	    var i;

	    for (i = 0; i < this.state.labels.length; ++i) {
	      var lab = this.state.labels[i];

	      if (node.label == null || lab.name === node.label.name) {
	        if (lab.kind != null && (isBreak || lab.kind === "loop")) break;
	        if (node.label && isBreak) break;
	      }
	    }

	    if (i === this.state.labels.length) {
	      this.raise(node.start, "Unsyntactic " + keyword);
	    }

	    return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
	  };

	  _proto.parseDebuggerStatement = function parseDebuggerStatement(node) {
	    this.next();
	    this.semicolon();
	    return this.finishNode(node, "DebuggerStatement");
	  };

	  _proto.parseDoStatement = function parseDoStatement(node) {
	    this.next();
	    this.state.labels.push(loopLabel);
	    node.body = this.parseStatement(false);
	    this.state.labels.pop();
	    this.expect(types._while);
	    node.test = this.parseParenExpression();
	    this.eat(types.semi);
	    return this.finishNode(node, "DoWhileStatement");
	  };

	  _proto.parseForStatement = function parseForStatement(node) {
	    this.next();
	    this.state.labels.push(loopLabel);
	    var forAwait = false;

	    if (this.state.inAsync && this.isContextual("await")) {
	      this.expectPlugin("asyncGenerators");
	      forAwait = true;
	      this.next();
	    }

	    this.expect(types.parenL);

	    if (this.match(types.semi)) {
	      if (forAwait) {
	        this.unexpected();
	      }

	      return this.parseFor(node, null);
	    }

	    if (this.match(types._var) || this.match(types._let) || this.match(types._const)) {
	      var _init = this.startNode();

	      var varKind = this.state.type;
	      this.next();
	      this.parseVar(_init, true, varKind);
	      this.finishNode(_init, "VariableDeclaration");

	      if (this.match(types._in) || this.isContextual("of")) {
	        if (_init.declarations.length === 1) {
	          var declaration = _init.declarations[0];
	          var isForInInitializer = varKind === types._var && declaration.init && declaration.id.type != "ObjectPattern" && declaration.id.type != "ArrayPattern" && !this.isContextual("of");

	          if (this.state.strict && isForInInitializer) {
	            this.raise(this.state.start, "for-in initializer in strict mode");
	          } else if (isForInInitializer || !declaration.init) {
	            return this.parseForIn(node, _init, forAwait);
	          }
	        }
	      }

	      if (forAwait) {
	        this.unexpected();
	      }

	      return this.parseFor(node, _init);
	    }

	    var refShorthandDefaultPos = {
	      start: 0
	    };
	    var init = this.parseExpression(true, refShorthandDefaultPos);

	    if (this.match(types._in) || this.isContextual("of")) {
	      var description = this.isContextual("of") ? "for-of statement" : "for-in statement";
	      this.toAssignable(init, undefined, description);
	      this.checkLVal(init, undefined, undefined, description);
	      return this.parseForIn(node, init, forAwait);
	    } else if (refShorthandDefaultPos.start) {
	      this.unexpected(refShorthandDefaultPos.start);
	    }

	    if (forAwait) {
	      this.unexpected();
	    }

	    return this.parseFor(node, init);
	  };

	  _proto.parseFunctionStatement = function parseFunctionStatement(node) {
	    this.next();
	    return this.parseFunction(node, true);
	  };

	  _proto.parseIfStatement = function parseIfStatement(node) {
	    this.next();
	    node.test = this.parseParenExpression();
	    node.consequent = this.parseStatement(false);
	    node.alternate = this.eat(types._else) ? this.parseStatement(false) : null;
	    return this.finishNode(node, "IfStatement");
	  };

	  _proto.parseReturnStatement = function parseReturnStatement(node) {
	    if (!this.state.inFunction && !this.options.allowReturnOutsideFunction) {
	      this.raise(this.state.start, "'return' outside of function");
	    }

	    this.next();

	    if (this.isLineTerminator()) {
	      node.argument = null;
	    } else {
	      node.argument = this.parseExpression();
	      this.semicolon();
	    }

	    return this.finishNode(node, "ReturnStatement");
	  };

	  _proto.parseSwitchStatement = function parseSwitchStatement(node) {
	    this.next();
	    node.discriminant = this.parseParenExpression();
	    var cases = node.cases = [];
	    this.expect(types.braceL);
	    this.state.labels.push(switchLabel);
	    var cur;

	    for (var sawDefault; !this.match(types.braceR);) {
	      if (this.match(types._case) || this.match(types._default)) {
	        var isCase = this.match(types._case);
	        if (cur) this.finishNode(cur, "SwitchCase");
	        cases.push(cur = this.startNode());
	        cur.consequent = [];
	        this.next();

	        if (isCase) {
	          cur.test = this.parseExpression();
	        } else {
	          if (sawDefault) {
	            this.raise(this.state.lastTokStart, "Multiple default clauses");
	          }

	          sawDefault = true;
	          cur.test = null;
	        }

	        this.expect(types.colon);
	      } else {
	        if (cur) {
	          cur.consequent.push(this.parseStatement(true));
	        } else {
	          this.unexpected();
	        }
	      }
	    }

	    if (cur) this.finishNode(cur, "SwitchCase");
	    this.next();
	    this.state.labels.pop();
	    return this.finishNode(node, "SwitchStatement");
	  };

	  _proto.parseThrowStatement = function parseThrowStatement(node) {
	    this.next();

	    if (lineBreak.test(this.input.slice(this.state.lastTokEnd, this.state.start))) {
	      this.raise(this.state.lastTokEnd, "Illegal newline after throw");
	    }

	    node.argument = this.parseExpression();
	    this.semicolon();
	    return this.finishNode(node, "ThrowStatement");
	  };

	  _proto.parseTryStatement = function parseTryStatement(node) {
	    this.next();
	    node.block = this.parseBlock();
	    node.handler = null;

	    if (this.match(types._catch)) {
	      var clause = this.startNode();
	      this.next();

	      if (this.match(types.parenL)) {
	        this.expect(types.parenL);
	        clause.param = this.parseBindingAtom();
	        var clashes = Object.create(null);
	        this.checkLVal(clause.param, true, clashes, "catch clause");
	        this.expect(types.parenR);
	      } else {
	        this.expectPlugin("optionalCatchBinding");
	        clause.param = null;
	      }

	      clause.body = this.parseBlock();
	      node.handler = this.finishNode(clause, "CatchClause");
	    }

	    node.guardedHandlers = empty;
	    node.finalizer = this.eat(types._finally) ? this.parseBlock() : null;

	    if (!node.handler && !node.finalizer) {
	      this.raise(node.start, "Missing catch or finally clause");
	    }

	    return this.finishNode(node, "TryStatement");
	  };

	  _proto.parseVarStatement = function parseVarStatement(node, kind) {
	    this.next();
	    this.parseVar(node, false, kind);
	    this.semicolon();
	    return this.finishNode(node, "VariableDeclaration");
	  };

	  _proto.parseWhileStatement = function parseWhileStatement(node) {
	    this.next();
	    node.test = this.parseParenExpression();
	    this.state.labels.push(loopLabel);
	    node.body = this.parseStatement(false);
	    this.state.labels.pop();
	    return this.finishNode(node, "WhileStatement");
	  };

	  _proto.parseWithStatement = function parseWithStatement(node) {
	    if (this.state.strict) {
	      this.raise(this.state.start, "'with' in strict mode");
	    }

	    this.next();
	    node.object = this.parseParenExpression();
	    node.body = this.parseStatement(false);
	    return this.finishNode(node, "WithStatement");
	  };

	  _proto.parseEmptyStatement = function parseEmptyStatement(node) {
	    this.next();
	    return this.finishNode(node, "EmptyStatement");
	  };

	  _proto.parseLabeledStatement = function parseLabeledStatement(node, maybeName, expr) {
	    for (var _i2 = 0, _this$state$labels2 = this.state.labels; _i2 < _this$state$labels2.length; _i2++) {
	      var label = _this$state$labels2[_i2];

	      if (label.name === maybeName) {
	        this.raise(expr.start, "Label '" + maybeName + "' is already declared");
	      }
	    }

	    var kind = this.state.type.isLoop ? "loop" : this.match(types._switch) ? "switch" : null;

	    for (var i = this.state.labels.length - 1; i >= 0; i--) {
	      var _label = this.state.labels[i];

	      if (_label.statementStart === node.start) {
	        _label.statementStart = this.state.start;
	        _label.kind = kind;
	      } else {
	        break;
	      }
	    }

	    this.state.labels.push({
	      name: maybeName,
	      kind: kind,
	      statementStart: this.state.start
	    });
	    node.body = this.parseStatement(true);

	    if (node.body.type == "ClassDeclaration" || node.body.type == "VariableDeclaration" && node.body.kind !== "var" || node.body.type == "FunctionDeclaration" && (this.state.strict || node.body.generator || node.body.async)) {
	      this.raise(node.body.start, "Invalid labeled declaration");
	    }

	    this.state.labels.pop();
	    node.label = expr;
	    return this.finishNode(node, "LabeledStatement");
	  };

	  _proto.parseExpressionStatement = function parseExpressionStatement(node, expr) {
	    node.expression = expr;
	    this.semicolon();
	    return this.finishNode(node, "ExpressionStatement");
	  };

	  _proto.parseBlock = function parseBlock(allowDirectives) {
	    var node = this.startNode();
	    this.expect(types.braceL);
	    this.parseBlockBody(node, allowDirectives, false, types.braceR);
	    return this.finishNode(node, "BlockStatement");
	  };

	  _proto.isValidDirective = function isValidDirective(stmt) {
	    return stmt.type === "ExpressionStatement" && stmt.expression.type === "StringLiteral" && !stmt.expression.extra.parenthesized;
	  };

	  _proto.parseBlockBody = function parseBlockBody(node, allowDirectives, topLevel, end) {
	    var body = node.body = [];
	    var directives = node.directives = [];
	    this.parseBlockOrModuleBlockBody(body, allowDirectives ? directives : undefined, topLevel, end);
	  };

	  _proto.parseBlockOrModuleBlockBody = function parseBlockOrModuleBlockBody(body, directives, topLevel, end) {
	    var parsedNonDirective = false;
	    var oldStrict;
	    var octalPosition;

	    while (!this.eat(end)) {
	      if (!parsedNonDirective && this.state.containsOctal && !octalPosition) {
	        octalPosition = this.state.octalPosition;
	      }

	      var stmt = this.parseStatement(true, topLevel);

	      if (directives && !parsedNonDirective && this.isValidDirective(stmt)) {
	        var directive = this.stmtToDirective(stmt);
	        directives.push(directive);

	        if (oldStrict === undefined && directive.value.value === "use strict") {
	          oldStrict = this.state.strict;
	          this.setStrict(true);

	          if (octalPosition) {
	            this.raise(octalPosition, "Octal literal in strict mode");
	          }
	        }

	        continue;
	      }

	      parsedNonDirective = true;
	      body.push(stmt);
	    }

	    if (oldStrict === false) {
	      this.setStrict(false);
	    }
	  };

	  _proto.parseFor = function parseFor(node, init) {
	    node.init = init;
	    this.expect(types.semi);
	    node.test = this.match(types.semi) ? null : this.parseExpression();
	    this.expect(types.semi);
	    node.update = this.match(types.parenR) ? null : this.parseExpression();
	    this.expect(types.parenR);
	    node.body = this.parseStatement(false);
	    this.state.labels.pop();
	    return this.finishNode(node, "ForStatement");
	  };

	  _proto.parseForIn = function parseForIn(node, init, forAwait) {
	    var type = this.match(types._in) ? "ForInStatement" : "ForOfStatement";

	    if (forAwait) {
	      this.eatContextual("of");
	    } else {
	      this.next();
	    }

	    if (type === "ForOfStatement") {
	      node.await = !!forAwait;
	    }

	    node.left = init;
	    node.right = this.parseExpression();
	    this.expect(types.parenR);
	    node.body = this.parseStatement(false);
	    this.state.labels.pop();
	    return this.finishNode(node, type);
	  };

	  _proto.parseVar = function parseVar(node, isFor, kind) {
	    var declarations = node.declarations = [];
	    node.kind = kind.keyword;

	    for (;;) {
	      var decl = this.startNode();
	      this.parseVarHead(decl);

	      if (this.eat(types.eq)) {
	        decl.init = this.parseMaybeAssign(isFor);
	      } else {
	        if (kind === types._const && !(this.match(types._in) || this.isContextual("of"))) {
	          if (!this.hasPlugin("typescript")) {
	            this.unexpected();
	          }
	        } else if (decl.id.type !== "Identifier" && !(isFor && (this.match(types._in) || this.isContextual("of")))) {
	          this.raise(this.state.lastTokEnd, "Complex binding patterns require an initialization value");
	        }

	        decl.init = null;
	      }

	      declarations.push(this.finishNode(decl, "VariableDeclarator"));
	      if (!this.eat(types.comma)) break;
	    }

	    return node;
	  };

	  _proto.parseVarHead = function parseVarHead(decl) {
	    decl.id = this.parseBindingAtom();
	    this.checkLVal(decl.id, true, undefined, "variable declaration");
	  };

	  _proto.parseFunction = function parseFunction(node, isStatement, allowExpressionBody, isAsync, optionalId) {
	    var oldInFunc = this.state.inFunction;
	    var oldInMethod = this.state.inMethod;
	    var oldInGenerator = this.state.inGenerator;
	    var oldInClassProperty = this.state.inClassProperty;
	    this.state.inFunction = true;
	    this.state.inMethod = false;
	    this.state.inClassProperty = false;
	    this.initFunction(node, isAsync);

	    if (this.match(types.star)) {
	      if (node.async) {
	        this.expectPlugin("asyncGenerators");
	      }

	      node.generator = true;
	      this.next();
	    }

	    if (isStatement && !optionalId && !this.match(types.name) && !this.match(types._yield)) {
	      this.unexpected();
	    }

	    if (!isStatement) this.state.inGenerator = node.generator;

	    if (this.match(types.name) || this.match(types._yield)) {
	      node.id = this.parseBindingIdentifier();
	    }

	    if (isStatement) this.state.inGenerator = node.generator;
	    this.parseFunctionParams(node);
	    this.parseFunctionBodyAndFinish(node, isStatement ? "FunctionDeclaration" : "FunctionExpression", allowExpressionBody);
	    this.state.inFunction = oldInFunc;
	    this.state.inMethod = oldInMethod;
	    this.state.inGenerator = oldInGenerator;
	    this.state.inClassProperty = oldInClassProperty;
	    return node;
	  };

	  _proto.parseFunctionParams = function parseFunctionParams(node, allowModifiers) {
	    var oldInParameters = this.state.inParameters;
	    this.state.inParameters = true;
	    this.expect(types.parenL);
	    node.params = this.parseBindingList(types.parenR, false, allowModifiers);
	    this.state.inParameters = oldInParameters;
	  };

	  _proto.parseClass = function parseClass(node, isStatement, optionalId) {
	    this.next();
	    this.takeDecorators(node);
	    this.parseClassId(node, isStatement, optionalId);
	    this.parseClassSuper(node);
	    this.parseClassBody(node);
	    return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
	  };

	  _proto.isClassProperty = function isClassProperty() {
	    return this.match(types.eq) || this.match(types.semi) || this.match(types.braceR);
	  };

	  _proto.isClassMethod = function isClassMethod() {
	    return this.match(types.parenL);
	  };

	  _proto.isNonstaticConstructor = function isNonstaticConstructor(method) {
	    return !method.computed && !method.static && (method.key.name === "constructor" || method.key.value === "constructor");
	  };

	  _proto.parseClassBody = function parseClassBody(node) {
	    var oldStrict = this.state.strict;
	    this.state.strict = true;
	    this.state.classLevel++;
	    var state = {
	      hadConstructor: false
	    };
	    var decorators = [];
	    var classBody = this.startNode();
	    classBody.body = [];
	    this.expect(types.braceL);

	    while (!this.eat(types.braceR)) {
	      if (this.eat(types.semi)) {
	        if (decorators.length > 0) {
	          this.raise(this.state.lastTokEnd, "Decorators must not be followed by a semicolon");
	        }

	        continue;
	      }

	      if (this.match(types.at)) {
	        decorators.push(this.parseDecorator());
	        continue;
	      }

	      var member = this.startNode();

	      if (decorators.length) {
	        member.decorators = decorators;
	        this.resetStartLocationFromNode(member, decorators[0]);
	        decorators = [];
	      }

	      this.parseClassMember(classBody, member, state);

	      if (member.kind === "constructor" && member.decorators && member.decorators.length > 0) {
	        this.raise(member.start, "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?");
	      }
	    }

	    if (decorators.length) {
	      this.raise(this.state.start, "You have trailing decorators with no method");
	    }

	    node.body = this.finishNode(classBody, "ClassBody");
	    this.state.classLevel--;
	    this.state.strict = oldStrict;
	  };

	  _proto.parseClassMember = function parseClassMember(classBody, member, state) {
	    var isStatic = false;
	    var containsEsc = this.state.containsEsc;

	    if (this.match(types.name) && this.state.value === "static") {
	      var key = this.parseIdentifier(true);

	      if (this.isClassMethod()) {
	        var method = member;
	        method.kind = "method";
	        method.computed = false;
	        method.key = key;
	        method.static = false;
	        this.pushClassMethod(classBody, method, false, false, false);
	        return;
	      } else if (this.isClassProperty()) {
	        var prop = member;
	        prop.computed = false;
	        prop.key = key;
	        prop.static = false;
	        classBody.body.push(this.parseClassProperty(prop));
	        return;
	      } else if (containsEsc) {
	        throw this.unexpected();
	      }

	      isStatic = true;
	    }

	    this.parseClassMemberWithIsStatic(classBody, member, state, isStatic);
	  };

	  _proto.parseClassMemberWithIsStatic = function parseClassMemberWithIsStatic(classBody, member, state, isStatic) {
	    var publicMethod = member;
	    var privateMethod = member;
	    var publicProp = member;
	    var privateProp = member;
	    var method = publicMethod;
	    var publicMember = publicMethod;
	    member.static = isStatic;

	    if (this.eat(types.star)) {
	      method.kind = "method";
	      this.parseClassPropertyName(method);

	      if (method.key.type === "PrivateName") {
	        this.pushClassPrivateMethod(classBody, privateMethod, true, false);
	        return;
	      }

	      if (this.isNonstaticConstructor(publicMethod)) {
	        this.raise(publicMethod.key.start, "Constructor can't be a generator");
	      }

	      this.pushClassMethod(classBody, publicMethod, true, false, false);
	      return;
	    }

	    var key = this.parseClassPropertyName(member);
	    var isPrivate = key.type === "PrivateName";
	    var isSimple = key.type === "Identifier";
	    this.parsePostMemberNameModifiers(publicMember);

	    if (this.isClassMethod()) {
	      method.kind = "method";

	      if (isPrivate) {
	        this.pushClassPrivateMethod(classBody, privateMethod, false, false);
	        return;
	      }

	      var isConstructor = this.isNonstaticConstructor(publicMethod);

	      if (isConstructor) {
	        publicMethod.kind = "constructor";

	        if (publicMethod.decorators) {
	          this.raise(publicMethod.start, "You can't attach decorators to a class constructor");
	        }

	        if (state.hadConstructor && !this.hasPlugin("typescript")) {
	          this.raise(key.start, "Duplicate constructor in the same class");
	        }

	        state.hadConstructor = true;
	      }

	      this.pushClassMethod(classBody, publicMethod, false, false, isConstructor);
	    } else if (this.isClassProperty()) {
	      if (isPrivate) {
	        this.pushClassPrivateProperty(classBody, privateProp);
	      } else {
	        this.pushClassProperty(classBody, publicProp);
	      }
	    } else if (isSimple && key.name === "async" && !this.isLineTerminator()) {
	      var isGenerator = this.match(types.star);

	      if (isGenerator) {
	        this.expectPlugin("asyncGenerators");
	        this.next();
	      }

	      method.kind = "method";
	      this.parseClassPropertyName(method);

	      if (method.key.type === "PrivateName") {
	        this.pushClassPrivateMethod(classBody, privateMethod, isGenerator, true);
	      } else {
	        if (this.isNonstaticConstructor(publicMethod)) {
	          this.raise(publicMethod.key.start, "Constructor can't be an async function");
	        }

	        this.pushClassMethod(classBody, publicMethod, isGenerator, true, false);
	      }
	    } else if (isSimple && (key.name === "get" || key.name === "set") && !(this.isLineTerminator() && this.match(types.star))) {
	      method.kind = key.name;
	      this.parseClassPropertyName(publicMethod);

	      if (method.key.type === "PrivateName") {
	        this.pushClassPrivateMethod(classBody, privateMethod, false, false);
	      } else {
	        if (this.isNonstaticConstructor(publicMethod)) {
	          this.raise(publicMethod.key.start, "Constructor can't have get/set modifier");
	        }

	        this.pushClassMethod(classBody, publicMethod, false, false, false);
	      }

	      this.checkGetterSetterParams(publicMethod);
	    } else if (this.isLineTerminator()) {
	      if (isPrivate) {
	        this.pushClassPrivateProperty(classBody, privateProp);
	      } else {
	        this.pushClassProperty(classBody, publicProp);
	      }
	    } else {
	      this.unexpected();
	    }
	  };

	  _proto.parseClassPropertyName = function parseClassPropertyName(member) {
	    var key = this.parsePropertyName(member);

	    if (!member.computed && member.static && (key.name === "prototype" || key.value === "prototype")) {
	      this.raise(key.start, "Classes may not have static property named prototype");
	    }

	    if (key.type === "PrivateName" && key.id.name === "constructor") {
	      this.raise(key.start, "Classes may not have a private field named '#constructor'");
	    }

	    return key;
	  };

	  _proto.pushClassProperty = function pushClassProperty(classBody, prop) {
	    if (this.isNonstaticConstructor(prop)) {
	      this.raise(prop.key.start, "Classes may not have a non-static field named 'constructor'");
	    }

	    classBody.body.push(this.parseClassProperty(prop));
	  };

	  _proto.pushClassPrivateProperty = function pushClassPrivateProperty(classBody, prop) {
	    this.expectPlugin("classPrivateProperties", prop.key.start);
	    classBody.body.push(this.parseClassPrivateProperty(prop));
	  };

	  _proto.pushClassMethod = function pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor) {
	    classBody.body.push(this.parseMethod(method, isGenerator, isAsync, isConstructor, "ClassMethod"));
	  };

	  _proto.pushClassPrivateMethod = function pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
	    this.expectPlugin("classPrivateMethods", method.key.start);
	    classBody.body.push(this.parseMethod(method, isGenerator, isAsync, false, "ClassPrivateMethod"));
	  };

	  _proto.parsePostMemberNameModifiers = function parsePostMemberNameModifiers(methodOrProp) {};

	  _proto.parseAccessModifier = function parseAccessModifier() {
	    return undefined;
	  };

	  _proto.parseClassPrivateProperty = function parseClassPrivateProperty(node) {
	    var oldInMethod = this.state.inMethod;
	    this.state.inMethod = false;
	    this.state.inClassProperty = true;
	    node.value = this.eat(types.eq) ? this.parseMaybeAssign() : null;
	    this.semicolon();
	    this.state.inClassProperty = false;
	    this.state.inMethod = oldInMethod;
	    return this.finishNode(node, "ClassPrivateProperty");
	  };

	  _proto.parseClassProperty = function parseClassProperty(node) {
	    if (!node.typeAnnotation) {
	      this.expectPlugin("classProperties");
	    }

	    var oldInMethod = this.state.inMethod;
	    this.state.inMethod = false;
	    this.state.inClassProperty = true;

	    if (this.match(types.eq)) {
	      this.expectPlugin("classProperties");
	      this.next();
	      node.value = this.parseMaybeAssign();
	    } else {
	      node.value = null;
	    }

	    this.semicolon();
	    this.state.inClassProperty = false;
	    this.state.inMethod = oldInMethod;
	    return this.finishNode(node, "ClassProperty");
	  };

	  _proto.parseClassId = function parseClassId(node, isStatement, optionalId) {
	    if (this.match(types.name)) {
	      node.id = this.parseIdentifier();
	    } else {
	      if (optionalId || !isStatement) {
	        node.id = null;
	      } else {
	        this.unexpected(null, "A class name is required");
	      }
	    }
	  };

	  _proto.parseClassSuper = function parseClassSuper(node) {
	    node.superClass = this.eat(types._extends) ? this.parseExprSubscripts() : null;
	  };

	  _proto.parseExport = function parseExport(node) {
	    if (this.shouldParseExportStar()) {
	      this.parseExportStar(node);
	      if (node.type === "ExportAllDeclaration") return node;
	    } else if (this.isExportDefaultSpecifier()) {
	      this.expectPlugin("exportDefaultFrom");
	      var specifier = this.startNode();
	      specifier.exported = this.parseIdentifier(true);
	      var specifiers = [this.finishNode(specifier, "ExportDefaultSpecifier")];
	      node.specifiers = specifiers;

	      if (this.match(types.comma) && this.lookahead().type === types.star) {
	        this.expect(types.comma);

	        var _specifier = this.startNode();

	        this.expect(types.star);
	        this.expectContextual("as");
	        _specifier.exported = this.parseIdentifier();
	        specifiers.push(this.finishNode(_specifier, "ExportNamespaceSpecifier"));
	      } else {
	        this.parseExportSpecifiersMaybe(node);
	      }

	      this.parseExportFrom(node, true);
	    } else if (this.eat(types._default)) {
	      node.declaration = this.parseExportDefaultExpression();
	      this.checkExport(node, true, true);
	      return this.finishNode(node, "ExportDefaultDeclaration");
	    } else if (this.shouldParseExportDeclaration()) {
	      if (this.isContextual("async")) {
	        var next = this.lookahead();

	        if (next.type !== types._function) {
	          this.unexpected(next.start, "Unexpected token, expected \"function\"");
	        }
	      }

	      node.specifiers = [];
	      node.source = null;
	      node.declaration = this.parseExportDeclaration(node);
	    } else {
	      node.declaration = null;
	      node.specifiers = this.parseExportSpecifiers();
	      this.parseExportFrom(node);
	    }

	    this.checkExport(node, true);
	    return this.finishNode(node, "ExportNamedDeclaration");
	  };

	  _proto.parseExportDefaultExpression = function parseExportDefaultExpression() {
	    var expr = this.startNode();

	    if (this.eat(types._function)) {
	      return this.parseFunction(expr, true, false, false, true);
	    } else if (this.isContextual("async") && this.lookahead().type === types._function) {
	      this.eatContextual("async");
	      this.eat(types._function);
	      return this.parseFunction(expr, true, false, true, true);
	    } else if (this.match(types._class)) {
	      return this.parseClass(expr, true, true);
	    } else if (this.match(types.at)) {
	      if (this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport")) {
	        this.unexpected(this.state.start, "Decorators must be placed *before* the 'export' keyword." + " You can set the 'decoratorsBeforeExport' option to false to use" + " the 'export @decorator class {}' syntax");
	      }

	      this.parseDecorators(false);
	      return this.parseClass(expr, true, true);
	    } else if (this.match(types._let) || this.match(types._const) || this.match(types._var)) {
	      return this.raise(this.state.start, "Only expressions, functions or classes are allowed as the `default` export.");
	    } else {
	      var res = this.parseMaybeAssign();
	      this.semicolon();
	      return res;
	    }
	  };

	  _proto.parseExportDeclaration = function parseExportDeclaration(node) {
	    return this.parseStatement(true);
	  };

	  _proto.isExportDefaultSpecifier = function isExportDefaultSpecifier() {
	    if (this.match(types.name)) {
	      return this.state.value !== "async";
	    }

	    if (!this.match(types._default)) {
	      return false;
	    }

	    var lookahead = this.lookahead();
	    return lookahead.type === types.comma || lookahead.type === types.name && lookahead.value === "from";
	  };

	  _proto.parseExportSpecifiersMaybe = function parseExportSpecifiersMaybe(node) {
	    if (this.eat(types.comma)) {
	      node.specifiers = node.specifiers.concat(this.parseExportSpecifiers());
	    }
	  };

	  _proto.parseExportFrom = function parseExportFrom(node, expect) {
	    if (this.eatContextual("from")) {
	      node.source = this.match(types.string) ? this.parseExprAtom() : this.unexpected();
	      this.checkExport(node);
	    } else {
	      if (expect) {
	        this.unexpected();
	      } else {
	        node.source = null;
	      }
	    }

	    this.semicolon();
	  };

	  _proto.shouldParseExportStar = function shouldParseExportStar() {
	    return this.match(types.star);
	  };

	  _proto.parseExportStar = function parseExportStar(node) {
	    this.expect(types.star);

	    if (this.isContextual("as")) {
	      this.parseExportNamespace(node);
	    } else {
	      this.parseExportFrom(node, true);
	      this.finishNode(node, "ExportAllDeclaration");
	    }
	  };

	  _proto.parseExportNamespace = function parseExportNamespace(node) {
	    this.expectPlugin("exportNamespaceFrom");
	    var specifier = this.startNodeAt(this.state.lastTokStart, this.state.lastTokStartLoc);
	    this.next();
	    specifier.exported = this.parseIdentifier(true);
	    node.specifiers = [this.finishNode(specifier, "ExportNamespaceSpecifier")];
	    this.parseExportSpecifiersMaybe(node);
	    this.parseExportFrom(node, true);
	  };

	  _proto.shouldParseExportDeclaration = function shouldParseExportDeclaration() {
	    if (this.match(types.at)) {
	      this.expectOnePlugin(["decorators", "decorators-legacy"]);

	      if (this.hasPlugin("decorators")) {
	        if (this.getPluginOption("decorators", "decoratorsBeforeExport")) {
	          this.unexpected(this.state.start, "Decorators must be placed *before* the 'export' keyword." + " You can set the 'decoratorsBeforeExport' option to false to use" + " the 'export @decorator class {}' syntax");
	        } else {
	          return true;
	        }
	      }
	    }

	    return this.state.type.keyword === "var" || this.state.type.keyword === "const" || this.state.type.keyword === "let" || this.state.type.keyword === "function" || this.state.type.keyword === "class" || this.isContextual("async");
	  };

	  _proto.checkExport = function checkExport(node, checkNames, isDefault) {
	    if (checkNames) {
	      if (isDefault) {
	        this.checkDuplicateExports(node, "default");
	      } else if (node.specifiers && node.specifiers.length) {
	        for (var _i4 = 0, _node$specifiers2 = node.specifiers; _i4 < _node$specifiers2.length; _i4++) {
	          var specifier = _node$specifiers2[_i4];
	          this.checkDuplicateExports(specifier, specifier.exported.name);
	        }
	      } else if (node.declaration) {
	        if (node.declaration.type === "FunctionDeclaration" || node.declaration.type === "ClassDeclaration") {
	          var id = node.declaration.id;
	          if (!id) throw new Error("Assertion failure");
	          this.checkDuplicateExports(node, id.name);
	        } else if (node.declaration.type === "VariableDeclaration") {
	          for (var _i6 = 0, _node$declaration$dec2 = node.declaration.declarations; _i6 < _node$declaration$dec2.length; _i6++) {
	            var declaration = _node$declaration$dec2[_i6];
	            this.checkDeclaration(declaration.id);
	          }
	        }
	      }
	    }

	    var currentContextDecorators = this.state.decoratorStack[this.state.decoratorStack.length - 1];

	    if (currentContextDecorators.length) {
	      var isClass = node.declaration && (node.declaration.type === "ClassDeclaration" || node.declaration.type === "ClassExpression");

	      if (!node.declaration || !isClass) {
	        throw this.raise(node.start, "You can only use decorators on an export when exporting a class");
	      }

	      this.takeDecorators(node.declaration);
	    }
	  };

	  _proto.checkDeclaration = function checkDeclaration(node) {
	    if (node.type === "ObjectPattern") {
	      for (var _i8 = 0, _node$properties2 = node.properties; _i8 < _node$properties2.length; _i8++) {
	        var prop = _node$properties2[_i8];
	        this.checkDeclaration(prop);
	      }
	    } else if (node.type === "ArrayPattern") {
	      for (var _i10 = 0, _node$elements2 = node.elements; _i10 < _node$elements2.length; _i10++) {
	        var elem = _node$elements2[_i10];

	        if (elem) {
	          this.checkDeclaration(elem);
	        }
	      }
	    } else if (node.type === "ObjectProperty") {
	      this.checkDeclaration(node.value);
	    } else if (node.type === "RestElement") {
	      this.checkDeclaration(node.argument);
	    } else if (node.type === "Identifier") {
	      this.checkDuplicateExports(node, node.name);
	    }
	  };

	  _proto.checkDuplicateExports = function checkDuplicateExports(node, name) {
	    if (this.state.exportedIdentifiers.indexOf(name) > -1) {
	      this.raiseDuplicateExportError(node, name);
	    }

	    this.state.exportedIdentifiers.push(name);
	  };

	  _proto.raiseDuplicateExportError = function raiseDuplicateExportError(node, name) {
	    throw this.raise(node.start, name === "default" ? "Only one default export allowed per module." : "`" + name + "` has already been exported. Exported identifiers must be unique.");
	  };

	  _proto.parseExportSpecifiers = function parseExportSpecifiers() {
	    var nodes = [];
	    var first = true;
	    var needsFrom;
	    this.expect(types.braceL);

	    while (!this.eat(types.braceR)) {
	      if (first) {
	        first = false;
	      } else {
	        this.expect(types.comma);
	        if (this.eat(types.braceR)) break;
	      }

	      var isDefault = this.match(types._default);
	      if (isDefault && !needsFrom) needsFrom = true;
	      var node = this.startNode();
	      node.local = this.parseIdentifier(isDefault);
	      node.exported = this.eatContextual("as") ? this.parseIdentifier(true) : node.local.__clone();
	      nodes.push(this.finishNode(node, "ExportSpecifier"));
	    }

	    if (needsFrom && !this.isContextual("from")) {
	      this.unexpected();
	    }

	    return nodes;
	  };

	  _proto.parseImport = function parseImport(node) {
	    if (this.match(types.string)) {
	      node.specifiers = [];
	      node.source = this.parseExprAtom();
	    } else {
	      node.specifiers = [];
	      this.parseImportSpecifiers(node);
	      this.expectContextual("from");
	      node.source = this.match(types.string) ? this.parseExprAtom() : this.unexpected();
	    }

	    this.semicolon();
	    return this.finishNode(node, "ImportDeclaration");
	  };

	  _proto.shouldParseDefaultImport = function shouldParseDefaultImport(node) {
	    return this.match(types.name);
	  };

	  _proto.parseImportSpecifierLocal = function parseImportSpecifierLocal(node, specifier, type, contextDescription) {
	    specifier.local = this.parseIdentifier();
	    this.checkLVal(specifier.local, true, undefined, contextDescription);
	    node.specifiers.push(this.finishNode(specifier, type));
	  };

	  _proto.parseImportSpecifiers = function parseImportSpecifiers(node) {
	    var first = true;

	    if (this.shouldParseDefaultImport(node)) {
	      this.parseImportSpecifierLocal(node, this.startNode(), "ImportDefaultSpecifier", "default import specifier");
	      if (!this.eat(types.comma)) return;
	    }

	    if (this.match(types.star)) {
	      var specifier = this.startNode();
	      this.next();
	      this.expectContextual("as");
	      this.parseImportSpecifierLocal(node, specifier, "ImportNamespaceSpecifier", "import namespace specifier");
	      return;
	    }

	    this.expect(types.braceL);

	    while (!this.eat(types.braceR)) {
	      if (first) {
	        first = false;
	      } else {
	        if (this.eat(types.colon)) {
	          this.unexpected(null, "ES2015 named imports do not destructure. " + "Use another statement for destructuring after the import.");
	        }

	        this.expect(types.comma);
	        if (this.eat(types.braceR)) break;
	      }

	      this.parseImportSpecifier(node);
	    }
	  };

	  _proto.parseImportSpecifier = function parseImportSpecifier(node) {
	    var specifier = this.startNode();
	    specifier.imported = this.parseIdentifier(true);

	    if (this.eatContextual("as")) {
	      specifier.local = this.parseIdentifier();
	    } else {
	      this.checkReservedWord(specifier.imported.name, specifier.start, true, true);
	      specifier.local = specifier.imported.__clone();
	    }

	    this.checkLVal(specifier.local, true, undefined, "import specifier");
	    node.specifiers.push(this.finishNode(specifier, "ImportSpecifier"));
	  };

	  return StatementParser;
	}(ExpressionParser);

	var Parser = function (_StatementParser) {
	  _inheritsLoose(Parser, _StatementParser);

	  function Parser(options, input) {
	    var _this;

	    options = getOptions(options);
	    _this = _StatementParser.call(this, options, input) || this;
	    _this.options = options;
	    _this.inModule = _this.options.sourceType === "module";
	    _this.input = input;
	    _this.plugins = pluginsMap(_this.options.plugins);
	    _this.filename = options.sourceFilename;
	    return _this;
	  }

	  var _proto = Parser.prototype;

	  _proto.parse = function parse() {
	    var file = this.startNode();
	    var program = this.startNode();
	    this.nextToken();
	    return this.parseTopLevel(file, program);
	  };

	  return Parser;
	}(StatementParser);

	function pluginsMap(plugins) {
	  var pluginMap = Object.create(null);

	  for (var _i2 = 0; _i2 < plugins.length; _i2++) {
	    var plugin = plugins[_i2];

	    var _ref = Array.isArray(plugin) ? plugin : [plugin, {}],
	        name = _ref[0],
	        _ref$ = _ref[1],
	        options = _ref$ === void 0 ? {} : _ref$;

	    if (!pluginMap[name]) pluginMap[name] = options || {};
	  }

	  return pluginMap;
	}

	function nonNull(x) {
	  if (x == null) {
	    throw new Error("Unexpected " + x + " value.");
	  }

	  return x;
	}

	function assert(x) {
	  if (!x) {
	    throw new Error("Assert fail");
	  }
	}

	function keywordTypeFromName(value) {
	  switch (value) {
	    case "any":
	      return "TSAnyKeyword";

	    case "boolean":
	      return "TSBooleanKeyword";

	    case "never":
	      return "TSNeverKeyword";

	    case "number":
	      return "TSNumberKeyword";

	    case "object":
	      return "TSObjectKeyword";

	    case "string":
	      return "TSStringKeyword";

	    case "symbol":
	      return "TSSymbolKeyword";

	    case "undefined":
	      return "TSUndefinedKeyword";

	    default:
	      return undefined;
	  }
	}

	var typescript = (function (superClass) {
	  return function (_superClass) {
	    _inheritsLoose(_class, _superClass);

	    function _class() {
	      return _superClass.apply(this, arguments) || this;
	    }

	    var _proto = _class.prototype;

	    _proto.tsIsIdentifier = function tsIsIdentifier() {
	      return this.match(types.name);
	    };

	    _proto.tsNextTokenCanFollowModifier = function tsNextTokenCanFollowModifier() {
	      this.next();
	      return !this.hasPrecedingLineBreak() && !this.match(types.parenL) && !this.match(types.parenR) && !this.match(types.colon) && !this.match(types.eq) && !this.match(types.question);
	    };

	    _proto.tsParseModifier = function tsParseModifier(allowedModifiers) {
	      if (!this.match(types.name)) {
	        return undefined;
	      }

	      var modifier = this.state.value;

	      if (allowedModifiers.indexOf(modifier) !== -1 && this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this))) {
	        return modifier;
	      }

	      return undefined;
	    };

	    _proto.tsIsListTerminator = function tsIsListTerminator(kind) {
	      switch (kind) {
	        case "EnumMembers":
	        case "TypeMembers":
	          return this.match(types.braceR);

	        case "HeritageClauseElement":
	          return this.match(types.braceL);

	        case "TupleElementTypes":
	          return this.match(types.bracketR);

	        case "TypeParametersOrArguments":
	          return this.isRelational(">");
	      }

	      throw new Error("Unreachable");
	    };

	    _proto.tsParseList = function tsParseList(kind, parseElement) {
	      var result = [];

	      while (!this.tsIsListTerminator(kind)) {
	        result.push(parseElement());
	      }

	      return result;
	    };

	    _proto.tsParseDelimitedList = function tsParseDelimitedList(kind, parseElement) {
	      return nonNull(this.tsParseDelimitedListWorker(kind, parseElement, true));
	    };

	    _proto.tsTryParseDelimitedList = function tsTryParseDelimitedList(kind, parseElement) {
	      return this.tsParseDelimitedListWorker(kind, parseElement, false);
	    };

	    _proto.tsParseDelimitedListWorker = function tsParseDelimitedListWorker(kind, parseElement, expectSuccess) {
	      var result = [];

	      while (true) {
	        if (this.tsIsListTerminator(kind)) {
	          break;
	        }

	        var element = parseElement();

	        if (element == null) {
	          return undefined;
	        }

	        result.push(element);

	        if (this.eat(types.comma)) {
	          continue;
	        }

	        if (this.tsIsListTerminator(kind)) {
	          break;
	        }

	        if (expectSuccess) {
	          this.expect(types.comma);
	        }

	        return undefined;
	      }

	      return result;
	    };

	    _proto.tsParseBracketedList = function tsParseBracketedList(kind, parseElement, bracket, skipFirstToken) {
	      if (!skipFirstToken) {
	        if (bracket) {
	          this.expect(types.bracketL);
	        } else {
	          this.expectRelational("<");
	        }
	      }

	      var result = this.tsParseDelimitedList(kind, parseElement);

	      if (bracket) {
	        this.expect(types.bracketR);
	      } else {
	        this.expectRelational(">");
	      }

	      return result;
	    };

	    _proto.tsParseEntityName = function tsParseEntityName(allowReservedWords) {
	      var entity = this.parseIdentifier();

	      while (this.eat(types.dot)) {
	        var node = this.startNodeAtNode(entity);
	        node.left = entity;
	        node.right = this.parseIdentifier(allowReservedWords);
	        entity = this.finishNode(node, "TSQualifiedName");
	      }

	      return entity;
	    };

	    _proto.tsParseTypeReference = function tsParseTypeReference() {
	      var node = this.startNode();
	      node.typeName = this.tsParseEntityName(false);

	      if (!this.hasPrecedingLineBreak() && this.isRelational("<")) {
	        node.typeParameters = this.tsParseTypeArguments();
	      }

	      return this.finishNode(node, "TSTypeReference");
	    };

	    _proto.tsParseThisTypePredicate = function tsParseThisTypePredicate(lhs) {
	      this.next();
	      var node = this.startNode();
	      node.parameterName = lhs;
	      node.typeAnnotation = this.tsParseTypeAnnotation(false);
	      return this.finishNode(node, "TSTypePredicate");
	    };

	    _proto.tsParseThisTypeNode = function tsParseThisTypeNode() {
	      var node = this.startNode();
	      this.next();
	      return this.finishNode(node, "TSThisType");
	    };

	    _proto.tsParseTypeQuery = function tsParseTypeQuery() {
	      var node = this.startNode();
	      this.expect(types._typeof);
	      node.exprName = this.tsParseEntityName(true);
	      return this.finishNode(node, "TSTypeQuery");
	    };

	    _proto.tsParseTypeParameter = function tsParseTypeParameter() {
	      var node = this.startNode();
	      node.name = this.parseIdentifierName(node.start);
	      node.constraint = this.tsEatThenParseType(types._extends);
	      node.default = this.tsEatThenParseType(types.eq);
	      return this.finishNode(node, "TSTypeParameter");
	    };

	    _proto.tsTryParseTypeParameters = function tsTryParseTypeParameters() {
	      if (this.isRelational("<")) {
	        return this.tsParseTypeParameters();
	      }
	    };

	    _proto.tsParseTypeParameters = function tsParseTypeParameters() {
	      var node = this.startNode();

	      if (this.isRelational("<") || this.match(types.jsxTagStart)) {
	        this.next();
	      } else {
	        this.unexpected();
	      }

	      node.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this), false, true);
	      return this.finishNode(node, "TSTypeParameterDeclaration");
	    };

	    _proto.tsFillSignature = function tsFillSignature(returnToken, signature) {
	      var returnTokenRequired = returnToken === types.arrow;
	      signature.typeParameters = this.tsTryParseTypeParameters();
	      this.expect(types.parenL);
	      signature.parameters = this.tsParseBindingListForSignature();

	      if (returnTokenRequired) {
	        signature.typeAnnotation = this.tsParseTypeOrTypePredicateAnnotation(returnToken);
	      } else if (this.match(returnToken)) {
	        signature.typeAnnotation = this.tsParseTypeOrTypePredicateAnnotation(returnToken);
	      }
	    };

	    _proto.tsParseBindingListForSignature = function tsParseBindingListForSignature() {
	      var _this = this;

	      return this.parseBindingList(types.parenR).map(function (pattern) {
	        if (pattern.type !== "Identifier" && pattern.type !== "RestElement") {
	          throw _this.unexpected(pattern.start, "Name in a signature must be an Identifier.");
	        }

	        return pattern;
	      });
	    };

	    _proto.tsParseTypeMemberSemicolon = function tsParseTypeMemberSemicolon() {
	      if (!this.eat(types.comma)) {
	        this.semicolon();
	      }
	    };

	    _proto.tsParseSignatureMember = function tsParseSignatureMember(kind) {
	      var node = this.startNode();

	      if (kind === "TSConstructSignatureDeclaration") {
	        this.expect(types._new);
	      }

	      this.tsFillSignature(types.colon, node);
	      this.tsParseTypeMemberSemicolon();
	      return this.finishNode(node, kind);
	    };

	    _proto.tsIsUnambiguouslyIndexSignature = function tsIsUnambiguouslyIndexSignature() {
	      this.next();
	      return this.eat(types.name) && this.match(types.colon);
	    };

	    _proto.tsTryParseIndexSignature = function tsTryParseIndexSignature(node) {
	      if (!(this.match(types.bracketL) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this)))) {
	        return undefined;
	      }

	      this.expect(types.bracketL);
	      var id = this.parseIdentifier();
	      this.expect(types.colon);
	      id.typeAnnotation = this.tsParseTypeAnnotation(false);
	      this.expect(types.bracketR);
	      node.parameters = [id];
	      var type = this.tsTryParseTypeAnnotation();
	      if (type) node.typeAnnotation = type;
	      this.tsParseTypeMemberSemicolon();
	      return this.finishNode(node, "TSIndexSignature");
	    };

	    _proto.tsParsePropertyOrMethodSignature = function tsParsePropertyOrMethodSignature(node, readonly) {
	      this.parsePropertyName(node);
	      if (this.eat(types.question)) node.optional = true;
	      var nodeAny = node;

	      if (!readonly && (this.match(types.parenL) || this.isRelational("<"))) {
	        var method = nodeAny;
	        this.tsFillSignature(types.colon, method);
	        this.tsParseTypeMemberSemicolon();
	        return this.finishNode(method, "TSMethodSignature");
	      } else {
	        var property = nodeAny;
	        if (readonly) property.readonly = true;
	        var type = this.tsTryParseTypeAnnotation();
	        if (type) property.typeAnnotation = type;
	        this.tsParseTypeMemberSemicolon();
	        return this.finishNode(property, "TSPropertySignature");
	      }
	    };

	    _proto.tsParseTypeMember = function tsParseTypeMember() {
	      if (this.match(types.parenL) || this.isRelational("<")) {
	        return this.tsParseSignatureMember("TSCallSignatureDeclaration");
	      }

	      if (this.match(types._new) && this.tsLookAhead(this.tsIsStartOfConstructSignature.bind(this))) {
	        return this.tsParseSignatureMember("TSConstructSignatureDeclaration");
	      }

	      var node = this.startNode();
	      var readonly = !!this.tsParseModifier(["readonly"]);
	      var idx = this.tsTryParseIndexSignature(node);

	      if (idx) {
	        if (readonly) node.readonly = true;
	        return idx;
	      }

	      return this.tsParsePropertyOrMethodSignature(node, readonly);
	    };

	    _proto.tsIsStartOfConstructSignature = function tsIsStartOfConstructSignature() {
	      this.next();
	      return this.match(types.parenL) || this.isRelational("<");
	    };

	    _proto.tsParseTypeLiteral = function tsParseTypeLiteral() {
	      var node = this.startNode();
	      node.members = this.tsParseObjectTypeMembers();
	      return this.finishNode(node, "TSTypeLiteral");
	    };

	    _proto.tsParseObjectTypeMembers = function tsParseObjectTypeMembers() {
	      this.expect(types.braceL);
	      var members = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
	      this.expect(types.braceR);
	      return members;
	    };

	    _proto.tsIsStartOfMappedType = function tsIsStartOfMappedType() {
	      this.next();

	      if (this.eat(types.plusMin)) {
	        return this.isContextual("readonly");
	      }

	      if (this.isContextual("readonly")) {
	        this.next();
	      }

	      if (!this.match(types.bracketL)) {
	        return false;
	      }

	      this.next();

	      if (!this.tsIsIdentifier()) {
	        return false;
	      }

	      this.next();
	      return this.match(types._in);
	    };

	    _proto.tsParseMappedTypeParameter = function tsParseMappedTypeParameter() {
	      var node = this.startNode();
	      node.name = this.parseIdentifierName(node.start);
	      node.constraint = this.tsExpectThenParseType(types._in);
	      return this.finishNode(node, "TSTypeParameter");
	    };

	    _proto.tsParseMappedType = function tsParseMappedType() {
	      var node = this.startNode();
	      this.expect(types.braceL);

	      if (this.match(types.plusMin)) {
	        node.readonly = this.state.value;
	        this.next();
	        this.expectContextual("readonly");
	      } else if (this.eatContextual("readonly")) {
	        node.readonly = true;
	      }

	      this.expect(types.bracketL);
	      node.typeParameter = this.tsParseMappedTypeParameter();
	      this.expect(types.bracketR);

	      if (this.match(types.plusMin)) {
	        node.optional = this.state.value;
	        this.next();
	        this.expect(types.question);
	      } else if (this.eat(types.question)) {
	        node.optional = true;
	      }

	      node.typeAnnotation = this.tsTryParseType();
	      this.semicolon();
	      this.expect(types.braceR);
	      return this.finishNode(node, "TSMappedType");
	    };

	    _proto.tsParseTupleType = function tsParseTupleType() {
	      var node = this.startNode();
	      node.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseType.bind(this), true, false);
	      return this.finishNode(node, "TSTupleType");
	    };

	    _proto.tsParseParenthesizedType = function tsParseParenthesizedType() {
	      var node = this.startNode();
	      this.expect(types.parenL);
	      node.typeAnnotation = this.tsParseType();
	      this.expect(types.parenR);
	      return this.finishNode(node, "TSParenthesizedType");
	    };

	    _proto.tsParseFunctionOrConstructorType = function tsParseFunctionOrConstructorType(type) {
	      var node = this.startNode();

	      if (type === "TSConstructorType") {
	        this.expect(types._new);
	      }

	      this.tsFillSignature(types.arrow, node);
	      return this.finishNode(node, type);
	    };

	    _proto.tsParseLiteralTypeNode = function tsParseLiteralTypeNode() {
	      var _this2 = this;

	      var node = this.startNode();

	      node.literal = function () {
	        switch (_this2.state.type) {
	          case types.num:
	            return _this2.parseLiteral(_this2.state.value, "NumericLiteral");

	          case types.string:
	            return _this2.parseLiteral(_this2.state.value, "StringLiteral");

	          case types._true:
	          case types._false:
	            return _this2.parseBooleanLiteral();

	          default:
	            throw _this2.unexpected();
	        }
	      }();

	      return this.finishNode(node, "TSLiteralType");
	    };

	    _proto.tsParseNonArrayType = function tsParseNonArrayType() {
	      switch (this.state.type) {
	        case types.name:
	        case types._void:
	        case types._null:
	          {
	            var type = this.match(types._void) ? "TSVoidKeyword" : this.match(types._null) ? "TSNullKeyword" : keywordTypeFromName(this.state.value);

	            if (type !== undefined && this.lookahead().type !== types.dot) {
	              var node = this.startNode();
	              this.next();
	              return this.finishNode(node, type);
	            }

	            return this.tsParseTypeReference();
	          }

	        case types.string:
	        case types.num:
	        case types._true:
	        case types._false:
	          return this.tsParseLiteralTypeNode();

	        case types.plusMin:
	          if (this.state.value === "-") {
	            var _node = this.startNode();

	            this.next();

	            if (!this.match(types.num)) {
	              throw this.unexpected();
	            }

	            _node.literal = this.parseLiteral(-this.state.value, "NumericLiteral", _node.start, _node.loc.start);
	            return this.finishNode(_node, "TSLiteralType");
	          }

	          break;

	        case types._this:
	          {
	            var thisKeyword = this.tsParseThisTypeNode();

	            if (this.isContextual("is") && !this.hasPrecedingLineBreak()) {
	              return this.tsParseThisTypePredicate(thisKeyword);
	            } else {
	              return thisKeyword;
	            }
	          }

	        case types._typeof:
	          return this.tsParseTypeQuery();

	        case types.braceL:
	          return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();

	        case types.bracketL:
	          return this.tsParseTupleType();

	        case types.parenL:
	          return this.tsParseParenthesizedType();
	      }

	      throw this.unexpected();
	    };

	    _proto.tsParseArrayTypeOrHigher = function tsParseArrayTypeOrHigher() {
	      var type = this.tsParseNonArrayType();

	      while (!this.hasPrecedingLineBreak() && this.eat(types.bracketL)) {
	        if (this.match(types.bracketR)) {
	          var node = this.startNodeAtNode(type);
	          node.elementType = type;
	          this.expect(types.bracketR);
	          type = this.finishNode(node, "TSArrayType");
	        } else {
	          var _node2 = this.startNodeAtNode(type);

	          _node2.objectType = type;
	          _node2.indexType = this.tsParseType();
	          this.expect(types.bracketR);
	          type = this.finishNode(_node2, "TSIndexedAccessType");
	        }
	      }

	      return type;
	    };

	    _proto.tsParseTypeOperator = function tsParseTypeOperator(operator) {
	      var node = this.startNode();
	      this.expectContextual(operator);
	      node.operator = operator;
	      node.typeAnnotation = this.tsParseTypeOperatorOrHigher();
	      return this.finishNode(node, "TSTypeOperator");
	    };

	    _proto.tsParseInferType = function tsParseInferType() {
	      var node = this.startNode();
	      this.expectContextual("infer");
	      var typeParameter = this.startNode();
	      typeParameter.name = this.parseIdentifierName(typeParameter.start);
	      node.typeParameter = this.finishNode(typeParameter, "TSTypeParameter");
	      return this.finishNode(node, "TSInferType");
	    };

	    _proto.tsParseTypeOperatorOrHigher = function tsParseTypeOperatorOrHigher() {
	      var _this3 = this;

	      var operator = ["keyof", "unique"].find(function (kw) {
	        return _this3.isContextual(kw);
	      });
	      return operator ? this.tsParseTypeOperator(operator) : this.isContextual("infer") ? this.tsParseInferType() : this.tsParseArrayTypeOrHigher();
	    };

	    _proto.tsParseUnionOrIntersectionType = function tsParseUnionOrIntersectionType(kind, parseConstituentType, operator) {
	      this.eat(operator);
	      var type = parseConstituentType();

	      if (this.match(operator)) {
	        var types$$1 = [type];

	        while (this.eat(operator)) {
	          types$$1.push(parseConstituentType());
	        }

	        var node = this.startNodeAtNode(type);
	        node.types = types$$1;
	        type = this.finishNode(node, kind);
	      }

	      return type;
	    };

	    _proto.tsParseIntersectionTypeOrHigher = function tsParseIntersectionTypeOrHigher() {
	      return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), types.bitwiseAND);
	    };

	    _proto.tsParseUnionTypeOrHigher = function tsParseUnionTypeOrHigher() {
	      return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), types.bitwiseOR);
	    };

	    _proto.tsIsStartOfFunctionType = function tsIsStartOfFunctionType() {
	      if (this.isRelational("<")) {
	        return true;
	      }

	      return this.match(types.parenL) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
	    };

	    _proto.tsSkipParameterStart = function tsSkipParameterStart() {
	      if (this.match(types.name) || this.match(types._this)) {
	        this.next();
	        return true;
	      }

	      return false;
	    };

	    _proto.tsIsUnambiguouslyStartOfFunctionType = function tsIsUnambiguouslyStartOfFunctionType() {
	      this.next();

	      if (this.match(types.parenR) || this.match(types.ellipsis)) {
	        return true;
	      }

	      if (this.tsSkipParameterStart()) {
	        if (this.match(types.colon) || this.match(types.comma) || this.match(types.question) || this.match(types.eq)) {
	          return true;
	        }

	        if (this.match(types.parenR)) {
	          this.next();

	          if (this.match(types.arrow)) {
	            return true;
	          }
	        }
	      }

	      return false;
	    };

	    _proto.tsParseTypeOrTypePredicateAnnotation = function tsParseTypeOrTypePredicateAnnotation(returnToken) {
	      var _this4 = this;

	      return this.tsInType(function () {
	        var t = _this4.startNode();

	        _this4.expect(returnToken);

	        var typePredicateVariable = _this4.tsIsIdentifier() && _this4.tsTryParse(_this4.tsParseTypePredicatePrefix.bind(_this4));

	        if (!typePredicateVariable) {
	          return _this4.tsParseTypeAnnotation(false, t);
	        }

	        var type = _this4.tsParseTypeAnnotation(false);

	        var node = _this4.startNodeAtNode(typePredicateVariable);

	        node.parameterName = typePredicateVariable;
	        node.typeAnnotation = type;
	        t.typeAnnotation = _this4.finishNode(node, "TSTypePredicate");
	        return _this4.finishNode(t, "TSTypeAnnotation");
	      });
	    };

	    _proto.tsTryParseTypeOrTypePredicateAnnotation = function tsTryParseTypeOrTypePredicateAnnotation() {
	      return this.match(types.colon) ? this.tsParseTypeOrTypePredicateAnnotation(types.colon) : undefined;
	    };

	    _proto.tsTryParseTypeAnnotation = function tsTryParseTypeAnnotation() {
	      return this.match(types.colon) ? this.tsParseTypeAnnotation() : undefined;
	    };

	    _proto.tsTryParseType = function tsTryParseType() {
	      return this.tsEatThenParseType(types.colon);
	    };

	    _proto.tsParseTypePredicatePrefix = function tsParseTypePredicatePrefix() {
	      var id = this.parseIdentifier();

	      if (this.isContextual("is") && !this.hasPrecedingLineBreak()) {
	        this.next();
	        return id;
	      }
	    };

	    _proto.tsParseTypeAnnotation = function tsParseTypeAnnotation(eatColon, t) {
	      var _this5 = this;

	      if (eatColon === void 0) {
	        eatColon = true;
	      }

	      if (t === void 0) {
	        t = this.startNode();
	      }

	      this.tsInType(function () {
	        if (eatColon) _this5.expect(types.colon);
	        t.typeAnnotation = _this5.tsParseType();
	      });
	      return this.finishNode(t, "TSTypeAnnotation");
	    };

	    _proto.tsParseType = function tsParseType() {
	      assert(this.state.inType);
	      var type = this.tsParseNonConditionalType();

	      if (this.hasPrecedingLineBreak() || !this.eat(types._extends)) {
	        return type;
	      }

	      var node = this.startNodeAtNode(type);
	      node.checkType = type;
	      node.extendsType = this.tsParseNonConditionalType();
	      this.expect(types.question);
	      node.trueType = this.tsParseType();
	      this.expect(types.colon);
	      node.falseType = this.tsParseType();
	      return this.finishNode(node, "TSConditionalType");
	    };

	    _proto.tsParseNonConditionalType = function tsParseNonConditionalType() {
	      if (this.tsIsStartOfFunctionType()) {
	        return this.tsParseFunctionOrConstructorType("TSFunctionType");
	      }

	      if (this.match(types._new)) {
	        return this.tsParseFunctionOrConstructorType("TSConstructorType");
	      }

	      return this.tsParseUnionTypeOrHigher();
	    };

	    _proto.tsParseTypeAssertion = function tsParseTypeAssertion() {
	      var _this6 = this;

	      var node = this.startNode();
	      node.typeAnnotation = this.tsInType(function () {
	        return _this6.tsParseType();
	      });
	      this.expectRelational(">");
	      node.expression = this.parseMaybeUnary();
	      return this.finishNode(node, "TSTypeAssertion");
	    };

	    _proto.tsParseHeritageClause = function tsParseHeritageClause() {
	      return this.tsParseDelimitedList("HeritageClauseElement", this.tsParseExpressionWithTypeArguments.bind(this));
	    };

	    _proto.tsParseExpressionWithTypeArguments = function tsParseExpressionWithTypeArguments() {
	      var node = this.startNode();
	      node.expression = this.tsParseEntityName(false);

	      if (this.isRelational("<")) {
	        node.typeParameters = this.tsParseTypeArguments();
	      }

	      return this.finishNode(node, "TSExpressionWithTypeArguments");
	    };

	    _proto.tsParseInterfaceDeclaration = function tsParseInterfaceDeclaration(node) {
	      node.id = this.parseIdentifier();
	      node.typeParameters = this.tsTryParseTypeParameters();

	      if (this.eat(types._extends)) {
	        node.extends = this.tsParseHeritageClause();
	      }

	      var body = this.startNode();
	      body.body = this.tsParseObjectTypeMembers();
	      node.body = this.finishNode(body, "TSInterfaceBody");
	      return this.finishNode(node, "TSInterfaceDeclaration");
	    };

	    _proto.tsParseTypeAliasDeclaration = function tsParseTypeAliasDeclaration(node) {
	      node.id = this.parseIdentifier();
	      node.typeParameters = this.tsTryParseTypeParameters();
	      node.typeAnnotation = this.tsExpectThenParseType(types.eq);
	      this.semicolon();
	      return this.finishNode(node, "TSTypeAliasDeclaration");
	    };

	    _proto.tsInNoContext = function tsInNoContext(cb) {
	      var oldContext = this.state.context;
	      this.state.context = [oldContext[0]];

	      try {
	        return cb();
	      } finally {
	        this.state.context = oldContext;
	      }
	    };

	    _proto.tsInType = function tsInType(cb) {
	      var oldInType = this.state.inType;
	      this.state.inType = true;

	      try {
	        return cb();
	      } finally {
	        this.state.inType = oldInType;
	      }
	    };

	    _proto.tsEatThenParseType = function tsEatThenParseType(token) {
	      return !this.match(token) ? undefined : this.tsNextThenParseType();
	    };

	    _proto.tsExpectThenParseType = function tsExpectThenParseType(token) {
	      var _this7 = this;

	      return this.tsDoThenParseType(function () {
	        return _this7.expect(token);
	      });
	    };

	    _proto.tsNextThenParseType = function tsNextThenParseType() {
	      var _this8 = this;

	      return this.tsDoThenParseType(function () {
	        return _this8.next();
	      });
	    };

	    _proto.tsDoThenParseType = function tsDoThenParseType(cb) {
	      var _this9 = this;

	      return this.tsInType(function () {
	        cb();
	        return _this9.tsParseType();
	      });
	    };

	    _proto.tsParseEnumMember = function tsParseEnumMember() {
	      var node = this.startNode();
	      node.id = this.match(types.string) ? this.parseLiteral(this.state.value, "StringLiteral") : this.parseIdentifier(true);

	      if (this.eat(types.eq)) {
	        node.initializer = this.parseMaybeAssign();
	      }

	      return this.finishNode(node, "TSEnumMember");
	    };

	    _proto.tsParseEnumDeclaration = function tsParseEnumDeclaration(node, isConst) {
	      if (isConst) node.const = true;
	      node.id = this.parseIdentifier();
	      this.expect(types.braceL);
	      node.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this));
	      this.expect(types.braceR);
	      return this.finishNode(node, "TSEnumDeclaration");
	    };

	    _proto.tsParseModuleBlock = function tsParseModuleBlock() {
	      var node = this.startNode();
	      this.expect(types.braceL);
	      this.parseBlockOrModuleBlockBody(node.body = [], undefined, true, types.braceR);
	      return this.finishNode(node, "TSModuleBlock");
	    };

	    _proto.tsParseModuleOrNamespaceDeclaration = function tsParseModuleOrNamespaceDeclaration(node) {
	      node.id = this.parseIdentifier();

	      if (this.eat(types.dot)) {
	        var inner = this.startNode();
	        this.tsParseModuleOrNamespaceDeclaration(inner);
	        node.body = inner;
	      } else {
	        node.body = this.tsParseModuleBlock();
	      }

	      return this.finishNode(node, "TSModuleDeclaration");
	    };

	    _proto.tsParseAmbientExternalModuleDeclaration = function tsParseAmbientExternalModuleDeclaration(node) {
	      if (this.isContextual("global")) {
	        node.global = true;
	        node.id = this.parseIdentifier();
	      } else if (this.match(types.string)) {
	        node.id = this.parseExprAtom();
	      } else {
	        this.unexpected();
	      }

	      if (this.match(types.braceL)) {
	        node.body = this.tsParseModuleBlock();
	      } else {
	        this.semicolon();
	      }

	      return this.finishNode(node, "TSModuleDeclaration");
	    };

	    _proto.tsParseImportEqualsDeclaration = function tsParseImportEqualsDeclaration(node, isExport) {
	      node.isExport = isExport || false;
	      node.id = this.parseIdentifier();
	      this.expect(types.eq);
	      node.moduleReference = this.tsParseModuleReference();
	      this.semicolon();
	      return this.finishNode(node, "TSImportEqualsDeclaration");
	    };

	    _proto.tsIsExternalModuleReference = function tsIsExternalModuleReference() {
	      return this.isContextual("require") && this.lookahead().type === types.parenL;
	    };

	    _proto.tsParseModuleReference = function tsParseModuleReference() {
	      return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(false);
	    };

	    _proto.tsParseExternalModuleReference = function tsParseExternalModuleReference() {
	      var node = this.startNode();
	      this.expectContextual("require");
	      this.expect(types.parenL);

	      if (!this.match(types.string)) {
	        throw this.unexpected();
	      }

	      node.expression = this.parseLiteral(this.state.value, "StringLiteral");
	      this.expect(types.parenR);
	      return this.finishNode(node, "TSExternalModuleReference");
	    };

	    _proto.tsLookAhead = function tsLookAhead(f) {
	      var state = this.state.clone();
	      var res = f();
	      this.state = state;
	      return res;
	    };

	    _proto.tsTryParseAndCatch = function tsTryParseAndCatch(f) {
	      var state = this.state.clone();

	      try {
	        return f();
	      } catch (e) {
	        if (e instanceof SyntaxError) {
	          this.state = state;
	          return undefined;
	        }

	        throw e;
	      }
	    };

	    _proto.tsTryParse = function tsTryParse(f) {
	      var state = this.state.clone();
	      var result = f();

	      if (result !== undefined && result !== false) {
	        return result;
	      } else {
	        this.state = state;
	        return undefined;
	      }
	    };

	    _proto.nodeWithSamePosition = function nodeWithSamePosition(original, type) {
	      var node = this.startNodeAtNode(original);
	      node.type = type;
	      node.end = original.end;
	      node.loc.end = original.loc.end;

	      if (original.leadingComments) {
	        node.leadingComments = original.leadingComments;
	      }

	      if (original.trailingComments) {
	        node.trailingComments = original.trailingComments;
	      }

	      if (original.innerComments) node.innerComments = original.innerComments;
	      return node;
	    };

	    _proto.tsTryParseDeclare = function tsTryParseDeclare(nany) {
	      switch (this.state.type) {
	        case types._function:
	          this.next();
	          return this.parseFunction(nany, true);

	        case types._class:
	          return this.parseClass(nany, true, false);

	        case types._const:
	          if (this.match(types._const) && this.isLookaheadContextual("enum")) {
	            this.expect(types._const);
	            this.expectContextual("enum");
	            return this.tsParseEnumDeclaration(nany, true);
	          }

	        case types._var:
	        case types._let:
	          return this.parseVarStatement(nany, this.state.type);

	        case types.name:
	          {
	            var value = this.state.value;

	            if (value === "global") {
	              return this.tsParseAmbientExternalModuleDeclaration(nany);
	            } else {
	              return this.tsParseDeclaration(nany, value, true);
	            }
	          }
	      }
	    };

	    _proto.tsTryParseExportDeclaration = function tsTryParseExportDeclaration() {
	      return this.tsParseDeclaration(this.startNode(), this.state.value, true);
	    };

	    _proto.tsParseExpressionStatement = function tsParseExpressionStatement(node, expr) {
	      switch (expr.name) {
	        case "declare":
	          {
	            var declaration = this.tsTryParseDeclare(node);

	            if (declaration) {
	              declaration.declare = true;
	              return declaration;
	            }

	            break;
	          }

	        case "global":
	          if (this.match(types.braceL)) {
	            var mod = node;
	            mod.global = true;
	            mod.id = expr;
	            mod.body = this.tsParseModuleBlock();
	            return this.finishNode(mod, "TSModuleDeclaration");
	          }

	          break;

	        default:
	          return this.tsParseDeclaration(node, expr.name, false);
	      }
	    };

	    _proto.tsParseDeclaration = function tsParseDeclaration(node, value, next) {
	      switch (value) {
	        case "abstract":
	          if (next || this.match(types._class)) {
	            var cls = node;
	            cls.abstract = true;
	            if (next) this.next();
	            return this.parseClass(cls, true, false);
	          }

	          break;

	        case "enum":
	          if (next || this.match(types.name)) {
	            if (next) this.next();
	            return this.tsParseEnumDeclaration(node, false);
	          }

	          break;

	        case "interface":
	          if (next || this.match(types.name)) {
	            if (next) this.next();
	            return this.tsParseInterfaceDeclaration(node);
	          }

	          break;

	        case "module":
	          if (next) this.next();

	          if (this.match(types.string)) {
	            return this.tsParseAmbientExternalModuleDeclaration(node);
	          } else if (next || this.match(types.name)) {
	            return this.tsParseModuleOrNamespaceDeclaration(node);
	          }

	          break;

	        case "namespace":
	          if (next || this.match(types.name)) {
	            if (next) this.next();
	            return this.tsParseModuleOrNamespaceDeclaration(node);
	          }

	          break;

	        case "type":
	          if (next || this.match(types.name)) {
	            if (next) this.next();
	            return this.tsParseTypeAliasDeclaration(node);
	          }

	          break;
	      }
	    };

	    _proto.tsTryParseGenericAsyncArrowFunction = function tsTryParseGenericAsyncArrowFunction(startPos, startLoc) {
	      var _this10 = this;

	      var res = this.tsTryParseAndCatch(function () {
	        var node = _this10.startNodeAt(startPos, startLoc);

	        node.typeParameters = _this10.tsParseTypeParameters();

	        _superClass.prototype.parseFunctionParams.call(_this10, node);

	        node.returnType = _this10.tsTryParseTypeOrTypePredicateAnnotation();

	        _this10.expect(types.arrow);

	        return node;
	      });

	      if (!res) {
	        return undefined;
	      }

	      res.id = null;
	      res.generator = false;
	      res.expression = true;
	      res.async = true;
	      this.parseFunctionBody(res, true);
	      return this.finishNode(res, "ArrowFunctionExpression");
	    };

	    _proto.tsParseTypeArguments = function tsParseTypeArguments() {
	      var _this11 = this;

	      var node = this.startNode();
	      node.params = this.tsInType(function () {
	        return _this11.tsInNoContext(function () {
	          _this11.expectRelational("<");

	          return _this11.tsParseDelimitedList("TypeParametersOrArguments", _this11.tsParseType.bind(_this11));
	        });
	      });
	      this.state.exprAllowed = false;
	      this.expectRelational(">");
	      return this.finishNode(node, "TSTypeParameterInstantiation");
	    };

	    _proto.tsIsDeclarationStart = function tsIsDeclarationStart() {
	      if (this.match(types.name)) {
	        switch (this.state.value) {
	          case "abstract":
	          case "declare":
	          case "enum":
	          case "interface":
	          case "module":
	          case "namespace":
	          case "type":
	            return true;
	        }
	      }

	      return false;
	    };

	    _proto.isExportDefaultSpecifier = function isExportDefaultSpecifier() {
	      if (this.tsIsDeclarationStart()) return false;
	      return _superClass.prototype.isExportDefaultSpecifier.call(this);
	    };

	    _proto.parseAssignableListItem = function parseAssignableListItem(allowModifiers, decorators) {
	      var accessibility;
	      var readonly = false;

	      if (allowModifiers) {
	        accessibility = this.parseAccessModifier();
	        readonly = !!this.tsParseModifier(["readonly"]);
	      }

	      var left = this.parseMaybeDefault();
	      this.parseAssignableListItemTypes(left);
	      var elt = this.parseMaybeDefault(left.start, left.loc.start, left);

	      if (accessibility || readonly) {
	        var pp = this.startNodeAtNode(elt);

	        if (decorators.length) {
	          pp.decorators = decorators;
	        }

	        if (accessibility) pp.accessibility = accessibility;
	        if (readonly) pp.readonly = readonly;

	        if (elt.type !== "Identifier" && elt.type !== "AssignmentPattern") {
	          throw this.raise(pp.start, "A parameter property may not be declared using a binding pattern.");
	        }

	        pp.parameter = elt;
	        return this.finishNode(pp, "TSParameterProperty");
	      } else {
	        if (decorators.length) {
	          left.decorators = decorators;
	        }

	        return elt;
	      }
	    };

	    _proto.parseFunctionBodyAndFinish = function parseFunctionBodyAndFinish(node, type, allowExpressionBody) {
	      if (!allowExpressionBody && this.match(types.colon)) {
	        node.returnType = this.tsParseTypeOrTypePredicateAnnotation(types.colon);
	      }

	      var bodilessType = type === "FunctionDeclaration" ? "TSDeclareFunction" : type === "ClassMethod" ? "TSDeclareMethod" : undefined;

	      if (bodilessType && !this.match(types.braceL) && this.isLineTerminator()) {
	        this.finishNode(node, bodilessType);
	        return;
	      }

	      _superClass.prototype.parseFunctionBodyAndFinish.call(this, node, type, allowExpressionBody);
	    };

	    _proto.parseSubscript = function parseSubscript(base, startPos, startLoc, noCalls, state) {
	      var _this12 = this;

	      if (!this.hasPrecedingLineBreak() && this.match(types.bang)) {
	        this.state.exprAllowed = false;
	        this.next();
	        var nonNullExpression = this.startNodeAt(startPos, startLoc);
	        nonNullExpression.expression = base;
	        return this.finishNode(nonNullExpression, "TSNonNullExpression");
	      }

	      var result = this.tsTryParseAndCatch(function () {
	        if (_this12.isRelational("<")) {
	          if (!noCalls && _this12.atPossibleAsync(base)) {
	            var asyncArrowFn = _this12.tsTryParseGenericAsyncArrowFunction(startPos, startLoc);

	            if (asyncArrowFn) {
	              return asyncArrowFn;
	            }
	          }

	          var node = _this12.startNodeAt(startPos, startLoc);

	          node.callee = base;

	          var typeArguments = _this12.tsParseTypeArguments();

	          if (typeArguments) {
	            if (!noCalls && _this12.eat(types.parenL)) {
	              node.arguments = _this12.parseCallExpressionArguments(types.parenR, false);
	              node.typeParameters = typeArguments;
	              return _this12.finishCallExpression(node);
	            } else if (_this12.match(types.backQuote)) {
	              return _this12.parseTaggedTemplateExpression(startPos, startLoc, base, state, typeArguments);
	            }
	          }
	        }

	        _this12.unexpected();
	      });
	      if (result) return result;
	      return _superClass.prototype.parseSubscript.call(this, base, startPos, startLoc, noCalls, state);
	    };

	    _proto.parseNewArguments = function parseNewArguments(node) {
	      var _this13 = this;

	      if (this.isRelational("<")) {
	        var typeParameters = this.tsTryParseAndCatch(function () {
	          var args = _this13.tsParseTypeArguments();

	          if (!_this13.match(types.parenL)) _this13.unexpected();
	          return args;
	        });

	        if (typeParameters) {
	          node.typeParameters = typeParameters;
	        }
	      }

	      _superClass.prototype.parseNewArguments.call(this, node);
	    };

	    _proto.parseExprOp = function parseExprOp(left, leftStartPos, leftStartLoc, minPrec, noIn) {
	      if (nonNull(types._in.binop) > minPrec && !this.hasPrecedingLineBreak() && this.isContextual("as")) {
	        var node = this.startNodeAt(leftStartPos, leftStartLoc);
	        node.expression = left;
	        node.typeAnnotation = this.tsNextThenParseType();
	        this.finishNode(node, "TSAsExpression");
	        return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn);
	      }

	      return _superClass.prototype.parseExprOp.call(this, left, leftStartPos, leftStartLoc, minPrec, noIn);
	    };

	    _proto.checkReservedWord = function checkReservedWord(word, startLoc, checkKeywords, isBinding) {};

	    _proto.checkDuplicateExports = function checkDuplicateExports() {};

	    _proto.parseImport = function parseImport(node) {
	      if (this.match(types.name) && this.lookahead().type === types.eq) {
	        return this.tsParseImportEqualsDeclaration(node);
	      }

	      return _superClass.prototype.parseImport.call(this, node);
	    };

	    _proto.parseExport = function parseExport(node) {
	      if (this.match(types._import)) {
	        this.expect(types._import);
	        return this.tsParseImportEqualsDeclaration(node, true);
	      } else if (this.eat(types.eq)) {
	        var assign = node;
	        assign.expression = this.parseExpression();
	        this.semicolon();
	        return this.finishNode(assign, "TSExportAssignment");
	      } else if (this.eatContextual("as")) {
	        var decl = node;
	        this.expectContextual("namespace");
	        decl.id = this.parseIdentifier();
	        this.semicolon();
	        return this.finishNode(decl, "TSNamespaceExportDeclaration");
	      } else {
	        return _superClass.prototype.parseExport.call(this, node);
	      }
	    };

	    _proto.isAbstractClass = function isAbstractClass() {
	      return this.isContextual("abstract") && this.lookahead().type === types._class;
	    };

	    _proto.parseExportDefaultExpression = function parseExportDefaultExpression() {
	      if (this.isAbstractClass()) {
	        var cls = this.startNode();
	        this.next();
	        this.parseClass(cls, true, true);
	        cls.abstract = true;
	        return cls;
	      }

	      if (this.state.value === "interface") {
	        return this.tsParseDeclaration(this.startNode(), this.state.value, true);
	      }

	      return _superClass.prototype.parseExportDefaultExpression.call(this);
	    };

	    _proto.parseStatementContent = function parseStatementContent(declaration, topLevel) {
	      if (this.state.type === types._const) {
	        var ahead = this.lookahead();

	        if (ahead.type === types.name && ahead.value === "enum") {
	          var node = this.startNode();
	          this.expect(types._const);
	          this.expectContextual("enum");
	          return this.tsParseEnumDeclaration(node, true);
	        }
	      }

	      return _superClass.prototype.parseStatementContent.call(this, declaration, topLevel);
	    };

	    _proto.parseAccessModifier = function parseAccessModifier() {
	      return this.tsParseModifier(["public", "protected", "private"]);
	    };

	    _proto.parseClassMember = function parseClassMember(classBody, member, state) {
	      var accessibility = this.parseAccessModifier();
	      if (accessibility) member.accessibility = accessibility;

	      _superClass.prototype.parseClassMember.call(this, classBody, member, state);
	    };

	    _proto.parseClassMemberWithIsStatic = function parseClassMemberWithIsStatic(classBody, member, state, isStatic) {
	      var methodOrProp = member;
	      var prop = member;
	      var propOrIdx = member;
	      var abstract = false,
	          readonly = false;
	      var mod = this.tsParseModifier(["abstract", "readonly"]);

	      switch (mod) {
	        case "readonly":
	          readonly = true;
	          abstract = !!this.tsParseModifier(["abstract"]);
	          break;

	        case "abstract":
	          abstract = true;
	          readonly = !!this.tsParseModifier(["readonly"]);
	          break;
	      }

	      if (abstract) methodOrProp.abstract = true;
	      if (readonly) propOrIdx.readonly = true;

	      if (!abstract && !isStatic && !methodOrProp.accessibility) {
	        var idx = this.tsTryParseIndexSignature(member);

	        if (idx) {
	          classBody.body.push(idx);
	          return;
	        }
	      }

	      if (readonly) {
	        methodOrProp.static = isStatic;
	        this.parseClassPropertyName(prop);
	        this.parsePostMemberNameModifiers(methodOrProp);
	        this.pushClassProperty(classBody, prop);
	        return;
	      }

	      _superClass.prototype.parseClassMemberWithIsStatic.call(this, classBody, member, state, isStatic);
	    };

	    _proto.parsePostMemberNameModifiers = function parsePostMemberNameModifiers(methodOrProp) {
	      var optional = this.eat(types.question);
	      if (optional) methodOrProp.optional = true;
	    };

	    _proto.parseExpressionStatement = function parseExpressionStatement(node, expr) {
	      var decl = expr.type === "Identifier" ? this.tsParseExpressionStatement(node, expr) : undefined;
	      return decl || _superClass.prototype.parseExpressionStatement.call(this, node, expr);
	    };

	    _proto.shouldParseExportDeclaration = function shouldParseExportDeclaration() {
	      if (this.tsIsDeclarationStart()) return true;
	      return _superClass.prototype.shouldParseExportDeclaration.call(this);
	    };

	    _proto.parseConditional = function parseConditional(expr, noIn, startPos, startLoc, refNeedsArrowPos) {
	      if (!refNeedsArrowPos || !this.match(types.question)) {
	        return _superClass.prototype.parseConditional.call(this, expr, noIn, startPos, startLoc, refNeedsArrowPos);
	      }

	      var state = this.state.clone();

	      try {
	        return _superClass.prototype.parseConditional.call(this, expr, noIn, startPos, startLoc);
	      } catch (err) {
	        if (!(err instanceof SyntaxError)) {
	          throw err;
	        }

	        this.state = state;
	        refNeedsArrowPos.start = err.pos || this.state.start;
	        return expr;
	      }
	    };

	    _proto.parseParenItem = function parseParenItem(node, startPos, startLoc) {
	      node = _superClass.prototype.parseParenItem.call(this, node, startPos, startLoc);

	      if (this.eat(types.question)) {
	        node.optional = true;
	      }

	      if (this.match(types.colon)) {
	        var typeCastNode = this.startNodeAt(startPos, startLoc);
	        typeCastNode.expression = node;
	        typeCastNode.typeAnnotation = this.tsParseTypeAnnotation();
	        return this.finishNode(typeCastNode, "TSTypeCastExpression");
	      }

	      return node;
	    };

	    _proto.parseExportDeclaration = function parseExportDeclaration(node) {
	      var isDeclare = this.eatContextual("declare");
	      var declaration;

	      if (this.match(types.name)) {
	        declaration = this.tsTryParseExportDeclaration();
	      }

	      if (!declaration) {
	        declaration = _superClass.prototype.parseExportDeclaration.call(this, node);
	      }

	      if (declaration && isDeclare) {
	        declaration.declare = true;
	      }

	      return declaration;
	    };

	    _proto.parseClassId = function parseClassId(node, isStatement, optionalId) {
	      if ((!isStatement || optionalId) && this.isContextual("implements")) {
	        return;
	      }

	      _superClass.prototype.parseClassId.apply(this, arguments);

	      var typeParameters = this.tsTryParseTypeParameters();
	      if (typeParameters) node.typeParameters = typeParameters;
	    };

	    _proto.parseClassProperty = function parseClassProperty(node) {
	      if (!node.optional && this.eat(types.bang)) {
	        node.definite = true;
	      }

	      var type = this.tsTryParseTypeAnnotation();
	      if (type) node.typeAnnotation = type;
	      return _superClass.prototype.parseClassProperty.call(this, node);
	    };

	    _proto.pushClassMethod = function pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor) {
	      var typeParameters = this.tsTryParseTypeParameters();
	      if (typeParameters) method.typeParameters = typeParameters;

	      _superClass.prototype.pushClassMethod.call(this, classBody, method, isGenerator, isAsync, isConstructor);
	    };

	    _proto.pushClassPrivateMethod = function pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
	      var typeParameters = this.tsTryParseTypeParameters();
	      if (typeParameters) method.typeParameters = typeParameters;

	      _superClass.prototype.pushClassPrivateMethod.call(this, classBody, method, isGenerator, isAsync);
	    };

	    _proto.parseClassSuper = function parseClassSuper(node) {
	      _superClass.prototype.parseClassSuper.call(this, node);

	      if (node.superClass && this.isRelational("<")) {
	        node.superTypeParameters = this.tsParseTypeArguments();
	      }

	      if (this.eatContextual("implements")) {
	        node.implements = this.tsParseHeritageClause();
	      }
	    };

	    _proto.parseObjPropValue = function parseObjPropValue(prop) {
	      var _superClass$prototype;

	      if (this.isRelational("<")) {
	        throw new Error("TODO");
	      }

	      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	        args[_key - 1] = arguments[_key];
	      }

	      (_superClass$prototype = _superClass.prototype.parseObjPropValue).call.apply(_superClass$prototype, [this, prop].concat(args));
	    };

	    _proto.parseFunctionParams = function parseFunctionParams(node, allowModifiers) {
	      var typeParameters = this.tsTryParseTypeParameters();
	      if (typeParameters) node.typeParameters = typeParameters;

	      _superClass.prototype.parseFunctionParams.call(this, node, allowModifiers);
	    };

	    _proto.parseVarHead = function parseVarHead(decl) {
	      _superClass.prototype.parseVarHead.call(this, decl);

	      if (decl.id.type === "Identifier" && this.eat(types.bang)) {
	        decl.definite = true;
	      }

	      var type = this.tsTryParseTypeAnnotation();

	      if (type) {
	        decl.id.typeAnnotation = type;
	        this.finishNode(decl.id, decl.id.type);
	      }
	    };

	    _proto.parseAsyncArrowFromCallExpression = function parseAsyncArrowFromCallExpression(node, call) {
	      if (this.match(types.colon)) {
	        node.returnType = this.tsParseTypeAnnotation();
	      }

	      return _superClass.prototype.parseAsyncArrowFromCallExpression.call(this, node, call);
	    };

	    _proto.parseMaybeAssign = function parseMaybeAssign() {
	      var jsxError;

	      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
	        args[_key2] = arguments[_key2];
	      }

	      if (this.match(types.jsxTagStart)) {
	        var context = this.curContext();
	        assert(context === types$1.j_oTag);
	        assert(this.state.context[this.state.context.length - 2] === types$1.j_expr);

	        var _state = this.state.clone();

	        try {
	          var _superClass$prototype2;

	          return (_superClass$prototype2 = _superClass.prototype.parseMaybeAssign).call.apply(_superClass$prototype2, [this].concat(args));
	        } catch (err) {
	          if (!(err instanceof SyntaxError)) {
	            throw err;
	          }

	          this.state = _state;
	          assert(this.curContext() === types$1.j_oTag);
	          this.state.context.pop();
	          assert(this.curContext() === types$1.j_expr);
	          this.state.context.pop();
	          jsxError = err;
	        }
	      }

	      if (jsxError === undefined && !this.isRelational("<")) {
	        var _superClass$prototype3;

	        return (_superClass$prototype3 = _superClass.prototype.parseMaybeAssign).call.apply(_superClass$prototype3, [this].concat(args));
	      }

	      var arrowExpression;
	      var typeParameters;
	      var state = this.state.clone();

	      try {
	        var _superClass$prototype4;

	        typeParameters = this.tsParseTypeParameters();
	        arrowExpression = (_superClass$prototype4 = _superClass.prototype.parseMaybeAssign).call.apply(_superClass$prototype4, [this].concat(args));

	        if (arrowExpression.type !== "ArrowFunctionExpression") {
	          this.unexpected();
	        }
	      } catch (err) {
	        var _superClass$prototype5;

	        if (!(err instanceof SyntaxError)) {
	          throw err;
	        }

	        if (jsxError) {
	          throw jsxError;
	        }

	        assert(!this.hasPlugin("jsx"));
	        this.state = state;
	        return (_superClass$prototype5 = _superClass.prototype.parseMaybeAssign).call.apply(_superClass$prototype5, [this].concat(args));
	      }

	      if (typeParameters && typeParameters.params.length !== 0) {
	        this.resetStartLocationFromNode(arrowExpression, typeParameters.params[0]);
	      }

	      arrowExpression.typeParameters = typeParameters;
	      return arrowExpression;
	    };

	    _proto.parseMaybeUnary = function parseMaybeUnary(refShorthandDefaultPos) {
	      if (!this.hasPlugin("jsx") && this.eatRelational("<")) {
	        return this.tsParseTypeAssertion();
	      } else {
	        return _superClass.prototype.parseMaybeUnary.call(this, refShorthandDefaultPos);
	      }
	    };

	    _proto.parseArrow = function parseArrow(node) {
	      if (this.match(types.colon)) {
	        var state = this.state.clone();

	        try {
	          var returnType = this.tsParseTypeOrTypePredicateAnnotation(types.colon);
	          if (this.canInsertSemicolon()) this.unexpected();
	          if (!this.match(types.arrow)) this.unexpected();
	          node.returnType = returnType;
	        } catch (err) {
	          if (err instanceof SyntaxError) {
	            this.state = state;
	          } else {
	            throw err;
	          }
	        }
	      }

	      return _superClass.prototype.parseArrow.call(this, node);
	    };

	    _proto.parseAssignableListItemTypes = function parseAssignableListItemTypes(param) {
	      if (this.eat(types.question)) {
	        if (param.type !== "Identifier") {
	          throw this.raise(param.start, "A binding pattern parameter cannot be optional in an implementation signature.");
	        }

	        param.optional = true;
	      }

	      var type = this.tsTryParseTypeAnnotation();
	      if (type) param.typeAnnotation = type;
	      return this.finishNode(param, param.type);
	    };

	    _proto.toAssignable = function toAssignable(node, isBinding, contextDescription) {
	      switch (node.type) {
	        case "TSTypeCastExpression":
	          return _superClass.prototype.toAssignable.call(this, this.typeCastToParameter(node), isBinding, contextDescription);

	        case "TSParameterProperty":
	          return _superClass.prototype.toAssignable.call(this, node, isBinding, contextDescription);

	        case "TSAsExpression":
	        case "TSNonNullExpression":
	        case "TSTypeAssertion":
	          node.expression = this.toAssignable(node.expression, isBinding, contextDescription);
	          return node;

	        default:
	          return _superClass.prototype.toAssignable.call(this, node, isBinding, contextDescription);
	      }
	    };

	    _proto.checkLVal = function checkLVal(expr, isBinding, checkClashes, contextDescription) {
	      switch (expr.type) {
	        case "TSTypeCastExpression":
	          return;

	        case "TSParameterProperty":
	          this.checkLVal(expr.parameter, isBinding, checkClashes, "parameter property");
	          return;

	        case "TSAsExpression":
	        case "TSNonNullExpression":
	        case "TSTypeAssertion":
	          this.checkLVal(expr.expression, isBinding, checkClashes, contextDescription);
	          return;

	        default:
	          _superClass.prototype.checkLVal.call(this, expr, isBinding, checkClashes, contextDescription);

	          return;
	      }
	    };

	    _proto.parseBindingAtom = function parseBindingAtom() {
	      switch (this.state.type) {
	        case types._this:
	          return this.parseIdentifier(true);

	        default:
	          return _superClass.prototype.parseBindingAtom.call(this);
	      }
	    };

	    _proto.isClassMethod = function isClassMethod() {
	      return this.isRelational("<") || _superClass.prototype.isClassMethod.call(this);
	    };

	    _proto.isClassProperty = function isClassProperty() {
	      return this.match(types.bang) || this.match(types.colon) || _superClass.prototype.isClassProperty.call(this);
	    };

	    _proto.parseMaybeDefault = function parseMaybeDefault() {
	      var _superClass$prototype6;

	      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
	        args[_key3] = arguments[_key3];
	      }

	      var node = (_superClass$prototype6 = _superClass.prototype.parseMaybeDefault).call.apply(_superClass$prototype6, [this].concat(args));

	      if (node.type === "AssignmentPattern" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {
	        this.raise(node.typeAnnotation.start, "Type annotations must come before default assignments, " + "e.g. instead of `age = 25: number` use `age: number = 25`");
	      }

	      return node;
	    };

	    _proto.readToken = function readToken(code) {
	      if (this.state.inType && (code === 62 || code === 60)) {
	        return this.finishOp(types.relational, 1);
	      } else {
	        return _superClass.prototype.readToken.call(this, code);
	      }
	    };

	    _proto.toAssignableList = function toAssignableList(exprList, isBinding, contextDescription) {
	      for (var i = 0; i < exprList.length; i++) {
	        var expr = exprList[i];

	        if (expr && expr.type === "TSTypeCastExpression") {
	          exprList[i] = this.typeCastToParameter(expr);
	        }
	      }

	      return _superClass.prototype.toAssignableList.call(this, exprList, isBinding, contextDescription);
	    };

	    _proto.typeCastToParameter = function typeCastToParameter(node) {
	      node.expression.typeAnnotation = node.typeAnnotation;
	      return this.finishNodeAt(node.expression, node.expression.type, node.typeAnnotation.end, node.typeAnnotation.loc.end);
	    };

	    _proto.toReferencedList = function toReferencedList(exprList) {
	      for (var i = 0; i < exprList.length; i++) {
	        var expr = exprList[i];

	        if (expr && expr._exprListItem && expr.type === "TsTypeCastExpression") {
	          this.raise(expr.start, "Did not expect a type annotation here.");
	        }
	      }

	      return exprList;
	    };

	    _proto.shouldParseArrow = function shouldParseArrow() {
	      return this.match(types.colon) || _superClass.prototype.shouldParseArrow.call(this);
	    };

	    _proto.shouldParseAsyncArrow = function shouldParseAsyncArrow() {
	      return this.match(types.colon) || _superClass.prototype.shouldParseAsyncArrow.call(this);
	    };

	    _proto.canHaveLeadingDecorator = function canHaveLeadingDecorator() {
	      return _superClass.prototype.canHaveLeadingDecorator.call(this) || this.isAbstractClass();
	    };

	    _proto.jsxParseOpeningElementAfterName = function jsxParseOpeningElementAfterName(node) {
	      var _this14 = this;

	      var typeArguments = this.tsTryParseAndCatch(function () {
	        return _this14.tsParseTypeArguments();
	      });
	      if (typeArguments) node.typeParameters = typeArguments;
	      return _superClass.prototype.jsxParseOpeningElementAfterName.call(this, node);
	    };

	    return _class;
	  }(superClass);
	});

	function hasPlugin(plugins, name) {
	  return plugins.some(function (plugin) {
	    if (Array.isArray(plugin)) {
	      return plugin[0] === name;
	    } else {
	      return plugin === name;
	    }
	  });
	}
	function getPluginOption(plugins, name, option) {
	  var plugin = plugins.find(function (plugin) {
	    if (Array.isArray(plugin)) {
	      return plugin[0] === name;
	    } else {
	      return plugin === name;
	    }
	  });

	  if (plugin && Array.isArray(plugin)) {
	    return plugin[1][option];
	  }

	  return null;
	}
	var PIPELINE_PROPOSALS = ["minimal"];
	function validatePlugins(plugins) {
	  if (hasPlugin(plugins, "decorators") && hasPlugin(plugins, "decorators-legacy")) {
	    throw new Error("Cannot use the decorators and decorators-legacy plugin together");
	  }

	  if (hasPlugin(plugins, "flow") && hasPlugin(plugins, "typescript")) {
	    throw new Error("Cannot combine flow and typescript plugins.");
	  }

	  if (hasPlugin(plugins, "pipelineOperator") && !PIPELINE_PROPOSALS.includes(getPluginOption(plugins, "pipelineOperator", "proposal"))) {
	    throw new Error("'pipelineOperator' requires 'proposal' option whose value should be one of: " + PIPELINE_PROPOSALS.join(", "));
	  }
	}
	var mixinPluginNames = ["estree", "jsx", "flow", "typescript"];
	var mixinPlugins = {
	  estree: estree,
	  jsx: jsx,
	  flow: flow,
	  typescript: typescript
	};

	function parse(input, options) {
	  if (options && options.sourceType === "unambiguous") {
	    options = Object.assign({}, options);

	    try {
	      options.sourceType = "module";
	      var parser = getParser(options, input);
	      var ast = parser.parse();
	      if (!parser.sawUnambiguousESM) ast.program.sourceType = "script";
	      return ast;
	    } catch (moduleError) {
	      try {
	        options.sourceType = "script";
	        return getParser(options, input).parse();
	      } catch (scriptError) {}

	      throw moduleError;
	    }
	  } else {
	    return getParser(options, input).parse();
	  }
	}
	function parseExpression(input, options) {
	  var parser = getParser(options, input);

	  if (parser.options.strictMode) {
	    parser.state.strict = true;
	  }

	  return parser.getExpression();
	}
	function getParser(options, input) {
	  var cls = Parser;

	  if (options && options.plugins) {
	    validatePlugins(options.plugins);
	    cls = getParserClass(options.plugins);
	  }

	  return new cls(options, input);
	}

	var parserClassCache = {};

	function getParserClass(pluginsFromOptions) {
	  var pluginList = mixinPluginNames.filter(function (name) {
	    return hasPlugin(pluginsFromOptions, name);
	  });
	  var key = pluginList.join("/");
	  var cls = parserClassCache[key];

	  if (!cls) {
	    cls = Parser;

	    for (var _i2 = 0; _i2 < pluginList.length; _i2++) {
	      var plugin = pluginList[_i2];
	      cls = mixinPlugins[plugin](cls);
	    }

	    parserClassCache[key] = cls;
	  }

	  return cls;
	}

	exports.parse = parse;
	exports.parseExpression = parseExpression;
	exports.tokTypes = types;


/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = assertNode;

	var _isNode = _interopRequireDefault(__webpack_require__(58));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function assertNode(node) {
	  if (!(0, _isNode.default)(node)) {
	    const type = node && node.type || JSON.stringify(node);
	    throw new TypeError(`Not a valid node of type "${type}"`);
	  }
	}

/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.assertArrayExpression = assertArrayExpression;
	exports.assertAssignmentExpression = assertAssignmentExpression;
	exports.assertBinaryExpression = assertBinaryExpression;
	exports.assertInterpreterDirective = assertInterpreterDirective;
	exports.assertDirective = assertDirective;
	exports.assertDirectiveLiteral = assertDirectiveLiteral;
	exports.assertBlockStatement = assertBlockStatement;
	exports.assertBreakStatement = assertBreakStatement;
	exports.assertCallExpression = assertCallExpression;
	exports.assertCatchClause = assertCatchClause;
	exports.assertConditionalExpression = assertConditionalExpression;
	exports.assertContinueStatement = assertContinueStatement;
	exports.assertDebuggerStatement = assertDebuggerStatement;
	exports.assertDoWhileStatement = assertDoWhileStatement;
	exports.assertEmptyStatement = assertEmptyStatement;
	exports.assertExpressionStatement = assertExpressionStatement;
	exports.assertFile = assertFile;
	exports.assertForInStatement = assertForInStatement;
	exports.assertForStatement = assertForStatement;
	exports.assertFunctionDeclaration = assertFunctionDeclaration;
	exports.assertFunctionExpression = assertFunctionExpression;
	exports.assertIdentifier = assertIdentifier;
	exports.assertIfStatement = assertIfStatement;
	exports.assertLabeledStatement = assertLabeledStatement;
	exports.assertStringLiteral = assertStringLiteral;
	exports.assertNumericLiteral = assertNumericLiteral;
	exports.assertNullLiteral = assertNullLiteral;
	exports.assertBooleanLiteral = assertBooleanLiteral;
	exports.assertRegExpLiteral = assertRegExpLiteral;
	exports.assertLogicalExpression = assertLogicalExpression;
	exports.assertMemberExpression = assertMemberExpression;
	exports.assertNewExpression = assertNewExpression;
	exports.assertProgram = assertProgram;
	exports.assertObjectExpression = assertObjectExpression;
	exports.assertObjectMethod = assertObjectMethod;
	exports.assertObjectProperty = assertObjectProperty;
	exports.assertRestElement = assertRestElement;
	exports.assertReturnStatement = assertReturnStatement;
	exports.assertSequenceExpression = assertSequenceExpression;
	exports.assertSwitchCase = assertSwitchCase;
	exports.assertSwitchStatement = assertSwitchStatement;
	exports.assertThisExpression = assertThisExpression;
	exports.assertThrowStatement = assertThrowStatement;
	exports.assertTryStatement = assertTryStatement;
	exports.assertUnaryExpression = assertUnaryExpression;
	exports.assertUpdateExpression = assertUpdateExpression;
	exports.assertVariableDeclaration = assertVariableDeclaration;
	exports.assertVariableDeclarator = assertVariableDeclarator;
	exports.assertWhileStatement = assertWhileStatement;
	exports.assertWithStatement = assertWithStatement;
	exports.assertAssignmentPattern = assertAssignmentPattern;
	exports.assertArrayPattern = assertArrayPattern;
	exports.assertArrowFunctionExpression = assertArrowFunctionExpression;
	exports.assertClassBody = assertClassBody;
	exports.assertClassDeclaration = assertClassDeclaration;
	exports.assertClassExpression = assertClassExpression;
	exports.assertExportAllDeclaration = assertExportAllDeclaration;
	exports.assertExportDefaultDeclaration = assertExportDefaultDeclaration;
	exports.assertExportNamedDeclaration = assertExportNamedDeclaration;
	exports.assertExportSpecifier = assertExportSpecifier;
	exports.assertForOfStatement = assertForOfStatement;
	exports.assertImportDeclaration = assertImportDeclaration;
	exports.assertImportDefaultSpecifier = assertImportDefaultSpecifier;
	exports.assertImportNamespaceSpecifier = assertImportNamespaceSpecifier;
	exports.assertImportSpecifier = assertImportSpecifier;
	exports.assertMetaProperty = assertMetaProperty;
	exports.assertClassMethod = assertClassMethod;
	exports.assertObjectPattern = assertObjectPattern;
	exports.assertSpreadElement = assertSpreadElement;
	exports.assertSuper = assertSuper;
	exports.assertTaggedTemplateExpression = assertTaggedTemplateExpression;
	exports.assertTemplateElement = assertTemplateElement;
	exports.assertTemplateLiteral = assertTemplateLiteral;
	exports.assertYieldExpression = assertYieldExpression;
	exports.assertAnyTypeAnnotation = assertAnyTypeAnnotation;
	exports.assertArrayTypeAnnotation = assertArrayTypeAnnotation;
	exports.assertBooleanTypeAnnotation = assertBooleanTypeAnnotation;
	exports.assertBooleanLiteralTypeAnnotation = assertBooleanLiteralTypeAnnotation;
	exports.assertNullLiteralTypeAnnotation = assertNullLiteralTypeAnnotation;
	exports.assertClassImplements = assertClassImplements;
	exports.assertDeclareClass = assertDeclareClass;
	exports.assertDeclareFunction = assertDeclareFunction;
	exports.assertDeclareInterface = assertDeclareInterface;
	exports.assertDeclareModule = assertDeclareModule;
	exports.assertDeclareModuleExports = assertDeclareModuleExports;
	exports.assertDeclareTypeAlias = assertDeclareTypeAlias;
	exports.assertDeclareOpaqueType = assertDeclareOpaqueType;
	exports.assertDeclareVariable = assertDeclareVariable;
	exports.assertDeclareExportDeclaration = assertDeclareExportDeclaration;
	exports.assertDeclareExportAllDeclaration = assertDeclareExportAllDeclaration;
	exports.assertDeclaredPredicate = assertDeclaredPredicate;
	exports.assertExistsTypeAnnotation = assertExistsTypeAnnotation;
	exports.assertFunctionTypeAnnotation = assertFunctionTypeAnnotation;
	exports.assertFunctionTypeParam = assertFunctionTypeParam;
	exports.assertGenericTypeAnnotation = assertGenericTypeAnnotation;
	exports.assertInferredPredicate = assertInferredPredicate;
	exports.assertInterfaceExtends = assertInterfaceExtends;
	exports.assertInterfaceDeclaration = assertInterfaceDeclaration;
	exports.assertInterfaceTypeAnnotation = assertInterfaceTypeAnnotation;
	exports.assertIntersectionTypeAnnotation = assertIntersectionTypeAnnotation;
	exports.assertMixedTypeAnnotation = assertMixedTypeAnnotation;
	exports.assertEmptyTypeAnnotation = assertEmptyTypeAnnotation;
	exports.assertNullableTypeAnnotation = assertNullableTypeAnnotation;
	exports.assertNumberLiteralTypeAnnotation = assertNumberLiteralTypeAnnotation;
	exports.assertNumberTypeAnnotation = assertNumberTypeAnnotation;
	exports.assertObjectTypeAnnotation = assertObjectTypeAnnotation;
	exports.assertObjectTypeInternalSlot = assertObjectTypeInternalSlot;
	exports.assertObjectTypeCallProperty = assertObjectTypeCallProperty;
	exports.assertObjectTypeIndexer = assertObjectTypeIndexer;
	exports.assertObjectTypeProperty = assertObjectTypeProperty;
	exports.assertObjectTypeSpreadProperty = assertObjectTypeSpreadProperty;
	exports.assertOpaqueType = assertOpaqueType;
	exports.assertQualifiedTypeIdentifier = assertQualifiedTypeIdentifier;
	exports.assertStringLiteralTypeAnnotation = assertStringLiteralTypeAnnotation;
	exports.assertStringTypeAnnotation = assertStringTypeAnnotation;
	exports.assertThisTypeAnnotation = assertThisTypeAnnotation;
	exports.assertTupleTypeAnnotation = assertTupleTypeAnnotation;
	exports.assertTypeofTypeAnnotation = assertTypeofTypeAnnotation;
	exports.assertTypeAlias = assertTypeAlias;
	exports.assertTypeAnnotation = assertTypeAnnotation;
	exports.assertTypeCastExpression = assertTypeCastExpression;
	exports.assertTypeParameter = assertTypeParameter;
	exports.assertTypeParameterDeclaration = assertTypeParameterDeclaration;
	exports.assertTypeParameterInstantiation = assertTypeParameterInstantiation;
	exports.assertUnionTypeAnnotation = assertUnionTypeAnnotation;
	exports.assertVariance = assertVariance;
	exports.assertVoidTypeAnnotation = assertVoidTypeAnnotation;
	exports.assertJSXAttribute = assertJSXAttribute;
	exports.assertJSXClosingElement = assertJSXClosingElement;
	exports.assertJSXElement = assertJSXElement;
	exports.assertJSXEmptyExpression = assertJSXEmptyExpression;
	exports.assertJSXExpressionContainer = assertJSXExpressionContainer;
	exports.assertJSXSpreadChild = assertJSXSpreadChild;
	exports.assertJSXIdentifier = assertJSXIdentifier;
	exports.assertJSXMemberExpression = assertJSXMemberExpression;
	exports.assertJSXNamespacedName = assertJSXNamespacedName;
	exports.assertJSXOpeningElement = assertJSXOpeningElement;
	exports.assertJSXSpreadAttribute = assertJSXSpreadAttribute;
	exports.assertJSXText = assertJSXText;
	exports.assertJSXFragment = assertJSXFragment;
	exports.assertJSXOpeningFragment = assertJSXOpeningFragment;
	exports.assertJSXClosingFragment = assertJSXClosingFragment;
	exports.assertNoop = assertNoop;
	exports.assertParenthesizedExpression = assertParenthesizedExpression;
	exports.assertAwaitExpression = assertAwaitExpression;
	exports.assertBindExpression = assertBindExpression;
	exports.assertClassProperty = assertClassProperty;
	exports.assertOptionalMemberExpression = assertOptionalMemberExpression;
	exports.assertOptionalCallExpression = assertOptionalCallExpression;
	exports.assertClassPrivateProperty = assertClassPrivateProperty;
	exports.assertImport = assertImport;
	exports.assertDecorator = assertDecorator;
	exports.assertDoExpression = assertDoExpression;
	exports.assertExportDefaultSpecifier = assertExportDefaultSpecifier;
	exports.assertExportNamespaceSpecifier = assertExportNamespaceSpecifier;
	exports.assertPrivateName = assertPrivateName;
	exports.assertBigIntLiteral = assertBigIntLiteral;
	exports.assertTSParameterProperty = assertTSParameterProperty;
	exports.assertTSDeclareFunction = assertTSDeclareFunction;
	exports.assertTSDeclareMethod = assertTSDeclareMethod;
	exports.assertTSQualifiedName = assertTSQualifiedName;
	exports.assertTSCallSignatureDeclaration = assertTSCallSignatureDeclaration;
	exports.assertTSConstructSignatureDeclaration = assertTSConstructSignatureDeclaration;
	exports.assertTSPropertySignature = assertTSPropertySignature;
	exports.assertTSMethodSignature = assertTSMethodSignature;
	exports.assertTSIndexSignature = assertTSIndexSignature;
	exports.assertTSAnyKeyword = assertTSAnyKeyword;
	exports.assertTSNumberKeyword = assertTSNumberKeyword;
	exports.assertTSObjectKeyword = assertTSObjectKeyword;
	exports.assertTSBooleanKeyword = assertTSBooleanKeyword;
	exports.assertTSStringKeyword = assertTSStringKeyword;
	exports.assertTSSymbolKeyword = assertTSSymbolKeyword;
	exports.assertTSVoidKeyword = assertTSVoidKeyword;
	exports.assertTSUndefinedKeyword = assertTSUndefinedKeyword;
	exports.assertTSNullKeyword = assertTSNullKeyword;
	exports.assertTSNeverKeyword = assertTSNeverKeyword;
	exports.assertTSThisType = assertTSThisType;
	exports.assertTSFunctionType = assertTSFunctionType;
	exports.assertTSConstructorType = assertTSConstructorType;
	exports.assertTSTypeReference = assertTSTypeReference;
	exports.assertTSTypePredicate = assertTSTypePredicate;
	exports.assertTSTypeQuery = assertTSTypeQuery;
	exports.assertTSTypeLiteral = assertTSTypeLiteral;
	exports.assertTSArrayType = assertTSArrayType;
	exports.assertTSTupleType = assertTSTupleType;
	exports.assertTSUnionType = assertTSUnionType;
	exports.assertTSIntersectionType = assertTSIntersectionType;
	exports.assertTSConditionalType = assertTSConditionalType;
	exports.assertTSInferType = assertTSInferType;
	exports.assertTSParenthesizedType = assertTSParenthesizedType;
	exports.assertTSTypeOperator = assertTSTypeOperator;
	exports.assertTSIndexedAccessType = assertTSIndexedAccessType;
	exports.assertTSMappedType = assertTSMappedType;
	exports.assertTSLiteralType = assertTSLiteralType;
	exports.assertTSExpressionWithTypeArguments = assertTSExpressionWithTypeArguments;
	exports.assertTSInterfaceDeclaration = assertTSInterfaceDeclaration;
	exports.assertTSInterfaceBody = assertTSInterfaceBody;
	exports.assertTSTypeAliasDeclaration = assertTSTypeAliasDeclaration;
	exports.assertTSAsExpression = assertTSAsExpression;
	exports.assertTSTypeAssertion = assertTSTypeAssertion;
	exports.assertTSEnumDeclaration = assertTSEnumDeclaration;
	exports.assertTSEnumMember = assertTSEnumMember;
	exports.assertTSModuleDeclaration = assertTSModuleDeclaration;
	exports.assertTSModuleBlock = assertTSModuleBlock;
	exports.assertTSImportEqualsDeclaration = assertTSImportEqualsDeclaration;
	exports.assertTSExternalModuleReference = assertTSExternalModuleReference;
	exports.assertTSNonNullExpression = assertTSNonNullExpression;
	exports.assertTSExportAssignment = assertTSExportAssignment;
	exports.assertTSNamespaceExportDeclaration = assertTSNamespaceExportDeclaration;
	exports.assertTSTypeAnnotation = assertTSTypeAnnotation;
	exports.assertTSTypeParameterInstantiation = assertTSTypeParameterInstantiation;
	exports.assertTSTypeParameterDeclaration = assertTSTypeParameterDeclaration;
	exports.assertTSTypeParameter = assertTSTypeParameter;
	exports.assertExpression = assertExpression;
	exports.assertBinary = assertBinary;
	exports.assertScopable = assertScopable;
	exports.assertBlockParent = assertBlockParent;
	exports.assertBlock = assertBlock;
	exports.assertStatement = assertStatement;
	exports.assertTerminatorless = assertTerminatorless;
	exports.assertCompletionStatement = assertCompletionStatement;
	exports.assertConditional = assertConditional;
	exports.assertLoop = assertLoop;
	exports.assertWhile = assertWhile;
	exports.assertExpressionWrapper = assertExpressionWrapper;
	exports.assertFor = assertFor;
	exports.assertForXStatement = assertForXStatement;
	exports.assertFunction = assertFunction;
	exports.assertFunctionParent = assertFunctionParent;
	exports.assertPureish = assertPureish;
	exports.assertDeclaration = assertDeclaration;
	exports.assertPatternLike = assertPatternLike;
	exports.assertLVal = assertLVal;
	exports.assertTSEntityName = assertTSEntityName;
	exports.assertLiteral = assertLiteral;
	exports.assertImmutable = assertImmutable;
	exports.assertUserWhitespacable = assertUserWhitespacable;
	exports.assertMethod = assertMethod;
	exports.assertObjectMember = assertObjectMember;
	exports.assertProperty = assertProperty;
	exports.assertUnaryLike = assertUnaryLike;
	exports.assertPattern = assertPattern;
	exports.assertClass = assertClass;
	exports.assertModuleDeclaration = assertModuleDeclaration;
	exports.assertExportDeclaration = assertExportDeclaration;
	exports.assertModuleSpecifier = assertModuleSpecifier;
	exports.assertFlow = assertFlow;
	exports.assertFlowType = assertFlowType;
	exports.assertFlowBaseAnnotation = assertFlowBaseAnnotation;
	exports.assertFlowDeclaration = assertFlowDeclaration;
	exports.assertFlowPredicate = assertFlowPredicate;
	exports.assertJSX = assertJSX;
	exports.assertPrivate = assertPrivate;
	exports.assertTSTypeElement = assertTSTypeElement;
	exports.assertTSType = assertTSType;
	exports.assertNumberLiteral = assertNumberLiteral;
	exports.assertRegexLiteral = assertRegexLiteral;
	exports.assertRestProperty = assertRestProperty;
	exports.assertSpreadProperty = assertSpreadProperty;

	var _is = _interopRequireDefault(__webpack_require__(31));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function assert(type, node, opts) {
	  if (!(0, _is.default)(type, node, opts)) {
	    throw new Error(`Expected type "${type}" with option ${JSON.stringify(opts)}, but instead got "${node.type}".`);
	  }
	}

	function assertArrayExpression(node, opts = {}) {
	  assert("ArrayExpression", node, opts);
	}

	function assertAssignmentExpression(node, opts = {}) {
	  assert("AssignmentExpression", node, opts);
	}

	function assertBinaryExpression(node, opts = {}) {
	  assert("BinaryExpression", node, opts);
	}

	function assertInterpreterDirective(node, opts = {}) {
	  assert("InterpreterDirective", node, opts);
	}

	function assertDirective(node, opts = {}) {
	  assert("Directive", node, opts);
	}

	function assertDirectiveLiteral(node, opts = {}) {
	  assert("DirectiveLiteral", node, opts);
	}

	function assertBlockStatement(node, opts = {}) {
	  assert("BlockStatement", node, opts);
	}

	function assertBreakStatement(node, opts = {}) {
	  assert("BreakStatement", node, opts);
	}

	function assertCallExpression(node, opts = {}) {
	  assert("CallExpression", node, opts);
	}

	function assertCatchClause(node, opts = {}) {
	  assert("CatchClause", node, opts);
	}

	function assertConditionalExpression(node, opts = {}) {
	  assert("ConditionalExpression", node, opts);
	}

	function assertContinueStatement(node, opts = {}) {
	  assert("ContinueStatement", node, opts);
	}

	function assertDebuggerStatement(node, opts = {}) {
	  assert("DebuggerStatement", node, opts);
	}

	function assertDoWhileStatement(node, opts = {}) {
	  assert("DoWhileStatement", node, opts);
	}

	function assertEmptyStatement(node, opts = {}) {
	  assert("EmptyStatement", node, opts);
	}

	function assertExpressionStatement(node, opts = {}) {
	  assert("ExpressionStatement", node, opts);
	}

	function assertFile(node, opts = {}) {
	  assert("File", node, opts);
	}

	function assertForInStatement(node, opts = {}) {
	  assert("ForInStatement", node, opts);
	}

	function assertForStatement(node, opts = {}) {
	  assert("ForStatement", node, opts);
	}

	function assertFunctionDeclaration(node, opts = {}) {
	  assert("FunctionDeclaration", node, opts);
	}

	function assertFunctionExpression(node, opts = {}) {
	  assert("FunctionExpression", node, opts);
	}

	function assertIdentifier(node, opts = {}) {
	  assert("Identifier", node, opts);
	}

	function assertIfStatement(node, opts = {}) {
	  assert("IfStatement", node, opts);
	}

	function assertLabeledStatement(node, opts = {}) {
	  assert("LabeledStatement", node, opts);
	}

	function assertStringLiteral(node, opts = {}) {
	  assert("StringLiteral", node, opts);
	}

	function assertNumericLiteral(node, opts = {}) {
	  assert("NumericLiteral", node, opts);
	}

	function assertNullLiteral(node, opts = {}) {
	  assert("NullLiteral", node, opts);
	}

	function assertBooleanLiteral(node, opts = {}) {
	  assert("BooleanLiteral", node, opts);
	}

	function assertRegExpLiteral(node, opts = {}) {
	  assert("RegExpLiteral", node, opts);
	}

	function assertLogicalExpression(node, opts = {}) {
	  assert("LogicalExpression", node, opts);
	}

	function assertMemberExpression(node, opts = {}) {
	  assert("MemberExpression", node, opts);
	}

	function assertNewExpression(node, opts = {}) {
	  assert("NewExpression", node, opts);
	}

	function assertProgram(node, opts = {}) {
	  assert("Program", node, opts);
	}

	function assertObjectExpression(node, opts = {}) {
	  assert("ObjectExpression", node, opts);
	}

	function assertObjectMethod(node, opts = {}) {
	  assert("ObjectMethod", node, opts);
	}

	function assertObjectProperty(node, opts = {}) {
	  assert("ObjectProperty", node, opts);
	}

	function assertRestElement(node, opts = {}) {
	  assert("RestElement", node, opts);
	}

	function assertReturnStatement(node, opts = {}) {
	  assert("ReturnStatement", node, opts);
	}

	function assertSequenceExpression(node, opts = {}) {
	  assert("SequenceExpression", node, opts);
	}

	function assertSwitchCase(node, opts = {}) {
	  assert("SwitchCase", node, opts);
	}

	function assertSwitchStatement(node, opts = {}) {
	  assert("SwitchStatement", node, opts);
	}

	function assertThisExpression(node, opts = {}) {
	  assert("ThisExpression", node, opts);
	}

	function assertThrowStatement(node, opts = {}) {
	  assert("ThrowStatement", node, opts);
	}

	function assertTryStatement(node, opts = {}) {
	  assert("TryStatement", node, opts);
	}

	function assertUnaryExpression(node, opts = {}) {
	  assert("UnaryExpression", node, opts);
	}

	function assertUpdateExpression(node, opts = {}) {
	  assert("UpdateExpression", node, opts);
	}

	function assertVariableDeclaration(node, opts = {}) {
	  assert("VariableDeclaration", node, opts);
	}

	function assertVariableDeclarator(node, opts = {}) {
	  assert("VariableDeclarator", node, opts);
	}

	function assertWhileStatement(node, opts = {}) {
	  assert("WhileStatement", node, opts);
	}

	function assertWithStatement(node, opts = {}) {
	  assert("WithStatement", node, opts);
	}

	function assertAssignmentPattern(node, opts = {}) {
	  assert("AssignmentPattern", node, opts);
	}

	function assertArrayPattern(node, opts = {}) {
	  assert("ArrayPattern", node, opts);
	}

	function assertArrowFunctionExpression(node, opts = {}) {
	  assert("ArrowFunctionExpression", node, opts);
	}

	function assertClassBody(node, opts = {}) {
	  assert("ClassBody", node, opts);
	}

	function assertClassDeclaration(node, opts = {}) {
	  assert("ClassDeclaration", node, opts);
	}

	function assertClassExpression(node, opts = {}) {
	  assert("ClassExpression", node, opts);
	}

	function assertExportAllDeclaration(node, opts = {}) {
	  assert("ExportAllDeclaration", node, opts);
	}

	function assertExportDefaultDeclaration(node, opts = {}) {
	  assert("ExportDefaultDeclaration", node, opts);
	}

	function assertExportNamedDeclaration(node, opts = {}) {
	  assert("ExportNamedDeclaration", node, opts);
	}

	function assertExportSpecifier(node, opts = {}) {
	  assert("ExportSpecifier", node, opts);
	}

	function assertForOfStatement(node, opts = {}) {
	  assert("ForOfStatement", node, opts);
	}

	function assertImportDeclaration(node, opts = {}) {
	  assert("ImportDeclaration", node, opts);
	}

	function assertImportDefaultSpecifier(node, opts = {}) {
	  assert("ImportDefaultSpecifier", node, opts);
	}

	function assertImportNamespaceSpecifier(node, opts = {}) {
	  assert("ImportNamespaceSpecifier", node, opts);
	}

	function assertImportSpecifier(node, opts = {}) {
	  assert("ImportSpecifier", node, opts);
	}

	function assertMetaProperty(node, opts = {}) {
	  assert("MetaProperty", node, opts);
	}

	function assertClassMethod(node, opts = {}) {
	  assert("ClassMethod", node, opts);
	}

	function assertObjectPattern(node, opts = {}) {
	  assert("ObjectPattern", node, opts);
	}

	function assertSpreadElement(node, opts = {}) {
	  assert("SpreadElement", node, opts);
	}

	function assertSuper(node, opts = {}) {
	  assert("Super", node, opts);
	}

	function assertTaggedTemplateExpression(node, opts = {}) {
	  assert("TaggedTemplateExpression", node, opts);
	}

	function assertTemplateElement(node, opts = {}) {
	  assert("TemplateElement", node, opts);
	}

	function assertTemplateLiteral(node, opts = {}) {
	  assert("TemplateLiteral", node, opts);
	}

	function assertYieldExpression(node, opts = {}) {
	  assert("YieldExpression", node, opts);
	}

	function assertAnyTypeAnnotation(node, opts = {}) {
	  assert("AnyTypeAnnotation", node, opts);
	}

	function assertArrayTypeAnnotation(node, opts = {}) {
	  assert("ArrayTypeAnnotation", node, opts);
	}

	function assertBooleanTypeAnnotation(node, opts = {}) {
	  assert("BooleanTypeAnnotation", node, opts);
	}

	function assertBooleanLiteralTypeAnnotation(node, opts = {}) {
	  assert("BooleanLiteralTypeAnnotation", node, opts);
	}

	function assertNullLiteralTypeAnnotation(node, opts = {}) {
	  assert("NullLiteralTypeAnnotation", node, opts);
	}

	function assertClassImplements(node, opts = {}) {
	  assert("ClassImplements", node, opts);
	}

	function assertDeclareClass(node, opts = {}) {
	  assert("DeclareClass", node, opts);
	}

	function assertDeclareFunction(node, opts = {}) {
	  assert("DeclareFunction", node, opts);
	}

	function assertDeclareInterface(node, opts = {}) {
	  assert("DeclareInterface", node, opts);
	}

	function assertDeclareModule(node, opts = {}) {
	  assert("DeclareModule", node, opts);
	}

	function assertDeclareModuleExports(node, opts = {}) {
	  assert("DeclareModuleExports", node, opts);
	}

	function assertDeclareTypeAlias(node, opts = {}) {
	  assert("DeclareTypeAlias", node, opts);
	}

	function assertDeclareOpaqueType(node, opts = {}) {
	  assert("DeclareOpaqueType", node, opts);
	}

	function assertDeclareVariable(node, opts = {}) {
	  assert("DeclareVariable", node, opts);
	}

	function assertDeclareExportDeclaration(node, opts = {}) {
	  assert("DeclareExportDeclaration", node, opts);
	}

	function assertDeclareExportAllDeclaration(node, opts = {}) {
	  assert("DeclareExportAllDeclaration", node, opts);
	}

	function assertDeclaredPredicate(node, opts = {}) {
	  assert("DeclaredPredicate", node, opts);
	}

	function assertExistsTypeAnnotation(node, opts = {}) {
	  assert("ExistsTypeAnnotation", node, opts);
	}

	function assertFunctionTypeAnnotation(node, opts = {}) {
	  assert("FunctionTypeAnnotation", node, opts);
	}

	function assertFunctionTypeParam(node, opts = {}) {
	  assert("FunctionTypeParam", node, opts);
	}

	function assertGenericTypeAnnotation(node, opts = {}) {
	  assert("GenericTypeAnnotation", node, opts);
	}

	function assertInferredPredicate(node, opts = {}) {
	  assert("InferredPredicate", node, opts);
	}

	function assertInterfaceExtends(node, opts = {}) {
	  assert("InterfaceExtends", node, opts);
	}

	function assertInterfaceDeclaration(node, opts = {}) {
	  assert("InterfaceDeclaration", node, opts);
	}

	function assertInterfaceTypeAnnotation(node, opts = {}) {
	  assert("InterfaceTypeAnnotation", node, opts);
	}

	function assertIntersectionTypeAnnotation(node, opts = {}) {
	  assert("IntersectionTypeAnnotation", node, opts);
	}

	function assertMixedTypeAnnotation(node, opts = {}) {
	  assert("MixedTypeAnnotation", node, opts);
	}

	function assertEmptyTypeAnnotation(node, opts = {}) {
	  assert("EmptyTypeAnnotation", node, opts);
	}

	function assertNullableTypeAnnotation(node, opts = {}) {
	  assert("NullableTypeAnnotation", node, opts);
	}

	function assertNumberLiteralTypeAnnotation(node, opts = {}) {
	  assert("NumberLiteralTypeAnnotation", node, opts);
	}

	function assertNumberTypeAnnotation(node, opts = {}) {
	  assert("NumberTypeAnnotation", node, opts);
	}

	function assertObjectTypeAnnotation(node, opts = {}) {
	  assert("ObjectTypeAnnotation", node, opts);
	}

	function assertObjectTypeInternalSlot(node, opts = {}) {
	  assert("ObjectTypeInternalSlot", node, opts);
	}

	function assertObjectTypeCallProperty(node, opts = {}) {
	  assert("ObjectTypeCallProperty", node, opts);
	}

	function assertObjectTypeIndexer(node, opts = {}) {
	  assert("ObjectTypeIndexer", node, opts);
	}

	function assertObjectTypeProperty(node, opts = {}) {
	  assert("ObjectTypeProperty", node, opts);
	}

	function assertObjectTypeSpreadProperty(node, opts = {}) {
	  assert("ObjectTypeSpreadProperty", node, opts);
	}

	function assertOpaqueType(node, opts = {}) {
	  assert("OpaqueType", node, opts);
	}

	function assertQualifiedTypeIdentifier(node, opts = {}) {
	  assert("QualifiedTypeIdentifier", node, opts);
	}

	function assertStringLiteralTypeAnnotation(node, opts = {}) {
	  assert("StringLiteralTypeAnnotation", node, opts);
	}

	function assertStringTypeAnnotation(node, opts = {}) {
	  assert("StringTypeAnnotation", node, opts);
	}

	function assertThisTypeAnnotation(node, opts = {}) {
	  assert("ThisTypeAnnotation", node, opts);
	}

	function assertTupleTypeAnnotation(node, opts = {}) {
	  assert("TupleTypeAnnotation", node, opts);
	}

	function assertTypeofTypeAnnotation(node, opts = {}) {
	  assert("TypeofTypeAnnotation", node, opts);
	}

	function assertTypeAlias(node, opts = {}) {
	  assert("TypeAlias", node, opts);
	}

	function assertTypeAnnotation(node, opts = {}) {
	  assert("TypeAnnotation", node, opts);
	}

	function assertTypeCastExpression(node, opts = {}) {
	  assert("TypeCastExpression", node, opts);
	}

	function assertTypeParameter(node, opts = {}) {
	  assert("TypeParameter", node, opts);
	}

	function assertTypeParameterDeclaration(node, opts = {}) {
	  assert("TypeParameterDeclaration", node, opts);
	}

	function assertTypeParameterInstantiation(node, opts = {}) {
	  assert("TypeParameterInstantiation", node, opts);
	}

	function assertUnionTypeAnnotation(node, opts = {}) {
	  assert("UnionTypeAnnotation", node, opts);
	}

	function assertVariance(node, opts = {}) {
	  assert("Variance", node, opts);
	}

	function assertVoidTypeAnnotation(node, opts = {}) {
	  assert("VoidTypeAnnotation", node, opts);
	}

	function assertJSXAttribute(node, opts = {}) {
	  assert("JSXAttribute", node, opts);
	}

	function assertJSXClosingElement(node, opts = {}) {
	  assert("JSXClosingElement", node, opts);
	}

	function assertJSXElement(node, opts = {}) {
	  assert("JSXElement", node, opts);
	}

	function assertJSXEmptyExpression(node, opts = {}) {
	  assert("JSXEmptyExpression", node, opts);
	}

	function assertJSXExpressionContainer(node, opts = {}) {
	  assert("JSXExpressionContainer", node, opts);
	}

	function assertJSXSpreadChild(node, opts = {}) {
	  assert("JSXSpreadChild", node, opts);
	}

	function assertJSXIdentifier(node, opts = {}) {
	  assert("JSXIdentifier", node, opts);
	}

	function assertJSXMemberExpression(node, opts = {}) {
	  assert("JSXMemberExpression", node, opts);
	}

	function assertJSXNamespacedName(node, opts = {}) {
	  assert("JSXNamespacedName", node, opts);
	}

	function assertJSXOpeningElement(node, opts = {}) {
	  assert("JSXOpeningElement", node, opts);
	}

	function assertJSXSpreadAttribute(node, opts = {}) {
	  assert("JSXSpreadAttribute", node, opts);
	}

	function assertJSXText(node, opts = {}) {
	  assert("JSXText", node, opts);
	}

	function assertJSXFragment(node, opts = {}) {
	  assert("JSXFragment", node, opts);
	}

	function assertJSXOpeningFragment(node, opts = {}) {
	  assert("JSXOpeningFragment", node, opts);
	}

	function assertJSXClosingFragment(node, opts = {}) {
	  assert("JSXClosingFragment", node, opts);
	}

	function assertNoop(node, opts = {}) {
	  assert("Noop", node, opts);
	}

	function assertParenthesizedExpression(node, opts = {}) {
	  assert("ParenthesizedExpression", node, opts);
	}

	function assertAwaitExpression(node, opts = {}) {
	  assert("AwaitExpression", node, opts);
	}

	function assertBindExpression(node, opts = {}) {
	  assert("BindExpression", node, opts);
	}

	function assertClassProperty(node, opts = {}) {
	  assert("ClassProperty", node, opts);
	}

	function assertOptionalMemberExpression(node, opts = {}) {
	  assert("OptionalMemberExpression", node, opts);
	}

	function assertOptionalCallExpression(node, opts = {}) {
	  assert("OptionalCallExpression", node, opts);
	}

	function assertClassPrivateProperty(node, opts = {}) {
	  assert("ClassPrivateProperty", node, opts);
	}

	function assertImport(node, opts = {}) {
	  assert("Import", node, opts);
	}

	function assertDecorator(node, opts = {}) {
	  assert("Decorator", node, opts);
	}

	function assertDoExpression(node, opts = {}) {
	  assert("DoExpression", node, opts);
	}

	function assertExportDefaultSpecifier(node, opts = {}) {
	  assert("ExportDefaultSpecifier", node, opts);
	}

	function assertExportNamespaceSpecifier(node, opts = {}) {
	  assert("ExportNamespaceSpecifier", node, opts);
	}

	function assertPrivateName(node, opts = {}) {
	  assert("PrivateName", node, opts);
	}

	function assertBigIntLiteral(node, opts = {}) {
	  assert("BigIntLiteral", node, opts);
	}

	function assertTSParameterProperty(node, opts = {}) {
	  assert("TSParameterProperty", node, opts);
	}

	function assertTSDeclareFunction(node, opts = {}) {
	  assert("TSDeclareFunction", node, opts);
	}

	function assertTSDeclareMethod(node, opts = {}) {
	  assert("TSDeclareMethod", node, opts);
	}

	function assertTSQualifiedName(node, opts = {}) {
	  assert("TSQualifiedName", node, opts);
	}

	function assertTSCallSignatureDeclaration(node, opts = {}) {
	  assert("TSCallSignatureDeclaration", node, opts);
	}

	function assertTSConstructSignatureDeclaration(node, opts = {}) {
	  assert("TSConstructSignatureDeclaration", node, opts);
	}

	function assertTSPropertySignature(node, opts = {}) {
	  assert("TSPropertySignature", node, opts);
	}

	function assertTSMethodSignature(node, opts = {}) {
	  assert("TSMethodSignature", node, opts);
	}

	function assertTSIndexSignature(node, opts = {}) {
	  assert("TSIndexSignature", node, opts);
	}

	function assertTSAnyKeyword(node, opts = {}) {
	  assert("TSAnyKeyword", node, opts);
	}

	function assertTSNumberKeyword(node, opts = {}) {
	  assert("TSNumberKeyword", node, opts);
	}

	function assertTSObjectKeyword(node, opts = {}) {
	  assert("TSObjectKeyword", node, opts);
	}

	function assertTSBooleanKeyword(node, opts = {}) {
	  assert("TSBooleanKeyword", node, opts);
	}

	function assertTSStringKeyword(node, opts = {}) {
	  assert("TSStringKeyword", node, opts);
	}

	function assertTSSymbolKeyword(node, opts = {}) {
	  assert("TSSymbolKeyword", node, opts);
	}

	function assertTSVoidKeyword(node, opts = {}) {
	  assert("TSVoidKeyword", node, opts);
	}

	function assertTSUndefinedKeyword(node, opts = {}) {
	  assert("TSUndefinedKeyword", node, opts);
	}

	function assertTSNullKeyword(node, opts = {}) {
	  assert("TSNullKeyword", node, opts);
	}

	function assertTSNeverKeyword(node, opts = {}) {
	  assert("TSNeverKeyword", node, opts);
	}

	function assertTSThisType(node, opts = {}) {
	  assert("TSThisType", node, opts);
	}

	function assertTSFunctionType(node, opts = {}) {
	  assert("TSFunctionType", node, opts);
	}

	function assertTSConstructorType(node, opts = {}) {
	  assert("TSConstructorType", node, opts);
	}

	function assertTSTypeReference(node, opts = {}) {
	  assert("TSTypeReference", node, opts);
	}

	function assertTSTypePredicate(node, opts = {}) {
	  assert("TSTypePredicate", node, opts);
	}

	function assertTSTypeQuery(node, opts = {}) {
	  assert("TSTypeQuery", node, opts);
	}

	function assertTSTypeLiteral(node, opts = {}) {
	  assert("TSTypeLiteral", node, opts);
	}

	function assertTSArrayType(node, opts = {}) {
	  assert("TSArrayType", node, opts);
	}

	function assertTSTupleType(node, opts = {}) {
	  assert("TSTupleType", node, opts);
	}

	function assertTSUnionType(node, opts = {}) {
	  assert("TSUnionType", node, opts);
	}

	function assertTSIntersectionType(node, opts = {}) {
	  assert("TSIntersectionType", node, opts);
	}

	function assertTSConditionalType(node, opts = {}) {
	  assert("TSConditionalType", node, opts);
	}

	function assertTSInferType(node, opts = {}) {
	  assert("TSInferType", node, opts);
	}

	function assertTSParenthesizedType(node, opts = {}) {
	  assert("TSParenthesizedType", node, opts);
	}

	function assertTSTypeOperator(node, opts = {}) {
	  assert("TSTypeOperator", node, opts);
	}

	function assertTSIndexedAccessType(node, opts = {}) {
	  assert("TSIndexedAccessType", node, opts);
	}

	function assertTSMappedType(node, opts = {}) {
	  assert("TSMappedType", node, opts);
	}

	function assertTSLiteralType(node, opts = {}) {
	  assert("TSLiteralType", node, opts);
	}

	function assertTSExpressionWithTypeArguments(node, opts = {}) {
	  assert("TSExpressionWithTypeArguments", node, opts);
	}

	function assertTSInterfaceDeclaration(node, opts = {}) {
	  assert("TSInterfaceDeclaration", node, opts);
	}

	function assertTSInterfaceBody(node, opts = {}) {
	  assert("TSInterfaceBody", node, opts);
	}

	function assertTSTypeAliasDeclaration(node, opts = {}) {
	  assert("TSTypeAliasDeclaration", node, opts);
	}

	function assertTSAsExpression(node, opts = {}) {
	  assert("TSAsExpression", node, opts);
	}

	function assertTSTypeAssertion(node, opts = {}) {
	  assert("TSTypeAssertion", node, opts);
	}

	function assertTSEnumDeclaration(node, opts = {}) {
	  assert("TSEnumDeclaration", node, opts);
	}

	function assertTSEnumMember(node, opts = {}) {
	  assert("TSEnumMember", node, opts);
	}

	function assertTSModuleDeclaration(node, opts = {}) {
	  assert("TSModuleDeclaration", node, opts);
	}

	function assertTSModuleBlock(node, opts = {}) {
	  assert("TSModuleBlock", node, opts);
	}

	function assertTSImportEqualsDeclaration(node, opts = {}) {
	  assert("TSImportEqualsDeclaration", node, opts);
	}

	function assertTSExternalModuleReference(node, opts = {}) {
	  assert("TSExternalModuleReference", node, opts);
	}

	function assertTSNonNullExpression(node, opts = {}) {
	  assert("TSNonNullExpression", node, opts);
	}

	function assertTSExportAssignment(node, opts = {}) {
	  assert("TSExportAssignment", node, opts);
	}

	function assertTSNamespaceExportDeclaration(node, opts = {}) {
	  assert("TSNamespaceExportDeclaration", node, opts);
	}

	function assertTSTypeAnnotation(node, opts = {}) {
	  assert("TSTypeAnnotation", node, opts);
	}

	function assertTSTypeParameterInstantiation(node, opts = {}) {
	  assert("TSTypeParameterInstantiation", node, opts);
	}

	function assertTSTypeParameterDeclaration(node, opts = {}) {
	  assert("TSTypeParameterDeclaration", node, opts);
	}

	function assertTSTypeParameter(node, opts = {}) {
	  assert("TSTypeParameter", node, opts);
	}

	function assertExpression(node, opts = {}) {
	  assert("Expression", node, opts);
	}

	function assertBinary(node, opts = {}) {
	  assert("Binary", node, opts);
	}

	function assertScopable(node, opts = {}) {
	  assert("Scopable", node, opts);
	}

	function assertBlockParent(node, opts = {}) {
	  assert("BlockParent", node, opts);
	}

	function assertBlock(node, opts = {}) {
	  assert("Block", node, opts);
	}

	function assertStatement(node, opts = {}) {
	  assert("Statement", node, opts);
	}

	function assertTerminatorless(node, opts = {}) {
	  assert("Terminatorless", node, opts);
	}

	function assertCompletionStatement(node, opts = {}) {
	  assert("CompletionStatement", node, opts);
	}

	function assertConditional(node, opts = {}) {
	  assert("Conditional", node, opts);
	}

	function assertLoop(node, opts = {}) {
	  assert("Loop", node, opts);
	}

	function assertWhile(node, opts = {}) {
	  assert("While", node, opts);
	}

	function assertExpressionWrapper(node, opts = {}) {
	  assert("ExpressionWrapper", node, opts);
	}

	function assertFor(node, opts = {}) {
	  assert("For", node, opts);
	}

	function assertForXStatement(node, opts = {}) {
	  assert("ForXStatement", node, opts);
	}

	function assertFunction(node, opts = {}) {
	  assert("Function", node, opts);
	}

	function assertFunctionParent(node, opts = {}) {
	  assert("FunctionParent", node, opts);
	}

	function assertPureish(node, opts = {}) {
	  assert("Pureish", node, opts);
	}

	function assertDeclaration(node, opts = {}) {
	  assert("Declaration", node, opts);
	}

	function assertPatternLike(node, opts = {}) {
	  assert("PatternLike", node, opts);
	}

	function assertLVal(node, opts = {}) {
	  assert("LVal", node, opts);
	}

	function assertTSEntityName(node, opts = {}) {
	  assert("TSEntityName", node, opts);
	}

	function assertLiteral(node, opts = {}) {
	  assert("Literal", node, opts);
	}

	function assertImmutable(node, opts = {}) {
	  assert("Immutable", node, opts);
	}

	function assertUserWhitespacable(node, opts = {}) {
	  assert("UserWhitespacable", node, opts);
	}

	function assertMethod(node, opts = {}) {
	  assert("Method", node, opts);
	}

	function assertObjectMember(node, opts = {}) {
	  assert("ObjectMember", node, opts);
	}

	function assertProperty(node, opts = {}) {
	  assert("Property", node, opts);
	}

	function assertUnaryLike(node, opts = {}) {
	  assert("UnaryLike", node, opts);
	}

	function assertPattern(node, opts = {}) {
	  assert("Pattern", node, opts);
	}

	function assertClass(node, opts = {}) {
	  assert("Class", node, opts);
	}

	function assertModuleDeclaration(node, opts = {}) {
	  assert("ModuleDeclaration", node, opts);
	}

	function assertExportDeclaration(node, opts = {}) {
	  assert("ExportDeclaration", node, opts);
	}

	function assertModuleSpecifier(node, opts = {}) {
	  assert("ModuleSpecifier", node, opts);
	}

	function assertFlow(node, opts = {}) {
	  assert("Flow", node, opts);
	}

	function assertFlowType(node, opts = {}) {
	  assert("FlowType", node, opts);
	}

	function assertFlowBaseAnnotation(node, opts = {}) {
	  assert("FlowBaseAnnotation", node, opts);
	}

	function assertFlowDeclaration(node, opts = {}) {
	  assert("FlowDeclaration", node, opts);
	}

	function assertFlowPredicate(node, opts = {}) {
	  assert("FlowPredicate", node, opts);
	}

	function assertJSX(node, opts = {}) {
	  assert("JSX", node, opts);
	}

	function assertPrivate(node, opts = {}) {
	  assert("Private", node, opts);
	}

	function assertTSTypeElement(node, opts = {}) {
	  assert("TSTypeElement", node, opts);
	}

	function assertTSType(node, opts = {}) {
	  assert("TSType", node, opts);
	}

	function assertNumberLiteral(node, opts) {
	  console.trace("The node type NumberLiteral has been renamed to NumericLiteral");
	  assert("NumberLiteral", node, opts);
	}

	function assertRegexLiteral(node, opts) {
	  console.trace("The node type RegexLiteral has been renamed to RegExpLiteral");
	  assert("RegexLiteral", node, opts);
	}

	function assertRestProperty(node, opts) {
	  console.trace("The node type RestProperty has been renamed to RestElement");
	  assert("RestProperty", node, opts);
	}

	function assertSpreadProperty(node, opts) {
	  console.trace("The node type SpreadProperty has been renamed to SpreadElement");
	  assert("SpreadProperty", node, opts);
	}

/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = builder;

	function _clone() {
	  const data = _interopRequireDefault(__webpack_require__(151));

	  _clone = function () {
	    return data;
	  };

	  return data;
	}

	var _definitions = __webpack_require__(14);

	var _validate = _interopRequireDefault(__webpack_require__(60));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function builder(type, ...args) {
	  const keys = _definitions.BUILDER_KEYS[type];
	  const countArgs = args.length;

	  if (countArgs > keys.length) {
	    throw new Error(`${type}: Too many arguments passed. Received ${countArgs} but can receive no more than ${keys.length}`);
	  }

	  const node = {
	    type
	  };
	  let i = 0;
	  keys.forEach(key => {
	    const field = _definitions.NODE_FIELDS[type][key];
	    let arg;
	    if (i < countArgs) arg = args[i];
	    if (arg === undefined) arg = (0, _clone().default)(field.default);
	    node[key] = arg;
	    i++;
	  });

	  for (const key in node) {
	    (0, _validate.default)(node, key, node[key]);
	  }

	  return node;
	}

/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = createTypeAnnotationBasedOnTypeof;

	var _generated = __webpack_require__(12);

	function createTypeAnnotationBasedOnTypeof(type) {
	  if (type === "string") {
	    return (0, _generated.stringTypeAnnotation)();
	  } else if (type === "number") {
	    return (0, _generated.numberTypeAnnotation)();
	  } else if (type === "undefined") {
	    return (0, _generated.voidTypeAnnotation)();
	  } else if (type === "boolean") {
	    return (0, _generated.booleanTypeAnnotation)();
	  } else if (type === "function") {
	    return (0, _generated.genericTypeAnnotation)((0, _generated.identifier)("Function"));
	  } else if (type === "object") {
	    return (0, _generated.genericTypeAnnotation)((0, _generated.identifier)("Object"));
	  } else if (type === "symbol") {
	    return (0, _generated.genericTypeAnnotation)((0, _generated.identifier)("Symbol"));
	  } else {
	    throw new Error("Invalid typeof value");
	  }
	}

/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = createUnionTypeAnnotation;

	var _generated = __webpack_require__(12);

	var _removeTypeDuplicates = _interopRequireDefault(__webpack_require__(52));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function createUnionTypeAnnotation(types) {
	  const flattened = (0, _removeTypeDuplicates.default)(types);

	  if (flattened.length === 1) {
	    return flattened[0];
	  } else {
	    return (0, _generated.unionTypeAnnotation)(flattened);
	  }
	}

/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = buildChildren;

	var _generated = __webpack_require__(8);

	var _cleanJSXElementLiteralChild = _interopRequireDefault(__webpack_require__(131));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function buildChildren(node) {
	  const elements = [];

	  for (let i = 0; i < node.children.length; i++) {
	    let child = node.children[i];

	    if ((0, _generated.isJSXText)(child)) {
	      (0, _cleanJSXElementLiteralChild.default)(child, elements);
	      continue;
	    }

	    if ((0, _generated.isJSXExpressionContainer)(child)) child = child.expression;
	    if ((0, _generated.isJSXEmptyExpression)(child)) continue;
	    elements.push(child);
	  }

	  return elements;
	}

/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = cloneDeep;

	var _cloneNode = _interopRequireDefault(__webpack_require__(19));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function cloneDeep(node) {
	  return (0, _cloneNode.default)(node);
	}

/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = cloneWithoutLoc;

	var _clone = _interopRequireDefault(__webpack_require__(44));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function cloneWithoutLoc(node) {
	  const newNode = (0, _clone.default)(node);
	  newNode.loc = null;
	  return newNode;
	}

/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = addComment;

	var _addComments = _interopRequireDefault(__webpack_require__(45));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function addComment(node, type, content, line) {
	  return (0, _addComments.default)(node, type, [{
	    type: line ? "CommentLine" : "CommentBlock",
	    value: content
	  }]);
	}

/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = removeComments;

	var _constants = __webpack_require__(16);

	function removeComments(node) {
	  _constants.COMMENT_KEYS.forEach(key => {
	    node[key] = null;
	  });

	  return node;
	}

/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.TSTYPE_TYPES = exports.TSTYPEELEMENT_TYPES = exports.PRIVATE_TYPES = exports.JSX_TYPES = exports.FLOWPREDICATE_TYPES = exports.FLOWDECLARATION_TYPES = exports.FLOWBASEANNOTATION_TYPES = exports.FLOWTYPE_TYPES = exports.FLOW_TYPES = exports.MODULESPECIFIER_TYPES = exports.EXPORTDECLARATION_TYPES = exports.MODULEDECLARATION_TYPES = exports.CLASS_TYPES = exports.PATTERN_TYPES = exports.UNARYLIKE_TYPES = exports.PROPERTY_TYPES = exports.OBJECTMEMBER_TYPES = exports.METHOD_TYPES = exports.USERWHITESPACABLE_TYPES = exports.IMMUTABLE_TYPES = exports.LITERAL_TYPES = exports.TSENTITYNAME_TYPES = exports.LVAL_TYPES = exports.PATTERNLIKE_TYPES = exports.DECLARATION_TYPES = exports.PUREISH_TYPES = exports.FUNCTIONPARENT_TYPES = exports.FUNCTION_TYPES = exports.FORXSTATEMENT_TYPES = exports.FOR_TYPES = exports.EXPRESSIONWRAPPER_TYPES = exports.WHILE_TYPES = exports.LOOP_TYPES = exports.CONDITIONAL_TYPES = exports.COMPLETIONSTATEMENT_TYPES = exports.TERMINATORLESS_TYPES = exports.STATEMENT_TYPES = exports.BLOCK_TYPES = exports.BLOCKPARENT_TYPES = exports.SCOPABLE_TYPES = exports.BINARY_TYPES = exports.EXPRESSION_TYPES = void 0;

	var _definitions = __webpack_require__(14);

	const EXPRESSION_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Expression"];
	exports.EXPRESSION_TYPES = EXPRESSION_TYPES;
	const BINARY_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Binary"];
	exports.BINARY_TYPES = BINARY_TYPES;
	const SCOPABLE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Scopable"];
	exports.SCOPABLE_TYPES = SCOPABLE_TYPES;
	const BLOCKPARENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS["BlockParent"];
	exports.BLOCKPARENT_TYPES = BLOCKPARENT_TYPES;
	const BLOCK_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Block"];
	exports.BLOCK_TYPES = BLOCK_TYPES;
	const STATEMENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Statement"];
	exports.STATEMENT_TYPES = STATEMENT_TYPES;
	const TERMINATORLESS_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Terminatorless"];
	exports.TERMINATORLESS_TYPES = TERMINATORLESS_TYPES;
	const COMPLETIONSTATEMENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS["CompletionStatement"];
	exports.COMPLETIONSTATEMENT_TYPES = COMPLETIONSTATEMENT_TYPES;
	const CONDITIONAL_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Conditional"];
	exports.CONDITIONAL_TYPES = CONDITIONAL_TYPES;
	const LOOP_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Loop"];
	exports.LOOP_TYPES = LOOP_TYPES;
	const WHILE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["While"];
	exports.WHILE_TYPES = WHILE_TYPES;
	const EXPRESSIONWRAPPER_TYPES = _definitions.FLIPPED_ALIAS_KEYS["ExpressionWrapper"];
	exports.EXPRESSIONWRAPPER_TYPES = EXPRESSIONWRAPPER_TYPES;
	const FOR_TYPES = _definitions.FLIPPED_ALIAS_KEYS["For"];
	exports.FOR_TYPES = FOR_TYPES;
	const FORXSTATEMENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS["ForXStatement"];
	exports.FORXSTATEMENT_TYPES = FORXSTATEMENT_TYPES;
	const FUNCTION_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Function"];
	exports.FUNCTION_TYPES = FUNCTION_TYPES;
	const FUNCTIONPARENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS["FunctionParent"];
	exports.FUNCTIONPARENT_TYPES = FUNCTIONPARENT_TYPES;
	const PUREISH_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Pureish"];
	exports.PUREISH_TYPES = PUREISH_TYPES;
	const DECLARATION_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Declaration"];
	exports.DECLARATION_TYPES = DECLARATION_TYPES;
	const PATTERNLIKE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["PatternLike"];
	exports.PATTERNLIKE_TYPES = PATTERNLIKE_TYPES;
	const LVAL_TYPES = _definitions.FLIPPED_ALIAS_KEYS["LVal"];
	exports.LVAL_TYPES = LVAL_TYPES;
	const TSENTITYNAME_TYPES = _definitions.FLIPPED_ALIAS_KEYS["TSEntityName"];
	exports.TSENTITYNAME_TYPES = TSENTITYNAME_TYPES;
	const LITERAL_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Literal"];
	exports.LITERAL_TYPES = LITERAL_TYPES;
	const IMMUTABLE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Immutable"];
	exports.IMMUTABLE_TYPES = IMMUTABLE_TYPES;
	const USERWHITESPACABLE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["UserWhitespacable"];
	exports.USERWHITESPACABLE_TYPES = USERWHITESPACABLE_TYPES;
	const METHOD_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Method"];
	exports.METHOD_TYPES = METHOD_TYPES;
	const OBJECTMEMBER_TYPES = _definitions.FLIPPED_ALIAS_KEYS["ObjectMember"];
	exports.OBJECTMEMBER_TYPES = OBJECTMEMBER_TYPES;
	const PROPERTY_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Property"];
	exports.PROPERTY_TYPES = PROPERTY_TYPES;
	const UNARYLIKE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["UnaryLike"];
	exports.UNARYLIKE_TYPES = UNARYLIKE_TYPES;
	const PATTERN_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Pattern"];
	exports.PATTERN_TYPES = PATTERN_TYPES;
	const CLASS_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Class"];
	exports.CLASS_TYPES = CLASS_TYPES;
	const MODULEDECLARATION_TYPES = _definitions.FLIPPED_ALIAS_KEYS["ModuleDeclaration"];
	exports.MODULEDECLARATION_TYPES = MODULEDECLARATION_TYPES;
	const EXPORTDECLARATION_TYPES = _definitions.FLIPPED_ALIAS_KEYS["ExportDeclaration"];
	exports.EXPORTDECLARATION_TYPES = EXPORTDECLARATION_TYPES;
	const MODULESPECIFIER_TYPES = _definitions.FLIPPED_ALIAS_KEYS["ModuleSpecifier"];
	exports.MODULESPECIFIER_TYPES = MODULESPECIFIER_TYPES;
	const FLOW_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Flow"];
	exports.FLOW_TYPES = FLOW_TYPES;
	const FLOWTYPE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["FlowType"];
	exports.FLOWTYPE_TYPES = FLOWTYPE_TYPES;
	const FLOWBASEANNOTATION_TYPES = _definitions.FLIPPED_ALIAS_KEYS["FlowBaseAnnotation"];
	exports.FLOWBASEANNOTATION_TYPES = FLOWBASEANNOTATION_TYPES;
	const FLOWDECLARATION_TYPES = _definitions.FLIPPED_ALIAS_KEYS["FlowDeclaration"];
	exports.FLOWDECLARATION_TYPES = FLOWDECLARATION_TYPES;
	const FLOWPREDICATE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["FlowPredicate"];
	exports.FLOWPREDICATE_TYPES = FLOWPREDICATE_TYPES;
	const JSX_TYPES = _definitions.FLIPPED_ALIAS_KEYS["JSX"];
	exports.JSX_TYPES = JSX_TYPES;
	const PRIVATE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Private"];
	exports.PRIVATE_TYPES = PRIVATE_TYPES;
	const TSTYPEELEMENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS["TSTypeElement"];
	exports.TSTYPEELEMENT_TYPES = TSTYPEELEMENT_TYPES;
	const TSTYPE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["TSType"];
	exports.TSTYPE_TYPES = TSTYPE_TYPES;

/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = ensureBlock;

	var _toBlock = _interopRequireDefault(__webpack_require__(50));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function ensureBlock(node, key = "body") {
	  return node[key] = (0, _toBlock.default)(node[key], node);
	}

/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = gatherSequenceExpressions;

	var _getBindingIdentifiers = _interopRequireDefault(__webpack_require__(21));

	var _generated = __webpack_require__(8);

	var _generated2 = __webpack_require__(12);

	var _cloneNode = _interopRequireDefault(__webpack_require__(19));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function gatherSequenceExpressions(nodes, scope, declars) {
	  const exprs = [];
	  let ensureLastUndefined = true;

	  for (const node of nodes) {
	    ensureLastUndefined = false;

	    if ((0, _generated.isExpression)(node)) {
	      exprs.push(node);
	    } else if ((0, _generated.isExpressionStatement)(node)) {
	      exprs.push(node.expression);
	    } else if ((0, _generated.isVariableDeclaration)(node)) {
	      if (node.kind !== "var") return;

	      for (const declar of node.declarations) {
	        const bindings = (0, _getBindingIdentifiers.default)(declar);

	        for (const key in bindings) {
	          declars.push({
	            kind: node.kind,
	            id: (0, _cloneNode.default)(bindings[key])
	          });
	        }

	        if (declar.init) {
	          exprs.push((0, _generated2.assignmentExpression)("=", declar.id, declar.init));
	        }
	      }

	      ensureLastUndefined = true;
	    } else if ((0, _generated.isIfStatement)(node)) {
	      const consequent = node.consequent ? gatherSequenceExpressions([node.consequent], scope, declars) : scope.buildUndefinedNode();
	      const alternate = node.alternate ? gatherSequenceExpressions([node.alternate], scope, declars) : scope.buildUndefinedNode();
	      if (!consequent || !alternate) return;
	      exprs.push((0, _generated2.conditionalExpression)(node.test, consequent, alternate));
	    } else if ((0, _generated.isBlockStatement)(node)) {
	      const body = gatherSequenceExpressions(node.body, scope, declars);
	      if (!body) return;
	      exprs.push(body);
	    } else if ((0, _generated.isEmptyStatement)(node)) {
	      ensureLastUndefined = true;
	    } else {
	      return;
	    }
	  }

	  if (ensureLastUndefined) {
	    exprs.push(scope.buildUndefinedNode());
	  }

	  if (exprs.length === 1) {
	    return exprs[0];
	  } else {
	    return (0, _generated2.sequenceExpression)(exprs);
	  }
	}

/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = toBindingIdentifierName;

	var _toIdentifier = _interopRequireDefault(__webpack_require__(51));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function toBindingIdentifierName(name) {
	  name = (0, _toIdentifier.default)(name);
	  if (name === "eval" || name === "arguments") name = "_" + name;
	  return name;
	}

/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = toComputedKey;

	var _generated = __webpack_require__(8);

	var _generated2 = __webpack_require__(12);

	function toComputedKey(node, key = node.key || node.property) {
	  if (!node.computed && (0, _generated.isIdentifier)(key)) key = (0, _generated2.stringLiteral)(key.name);
	  return key;
	}

/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = toExpression;

	var _generated = __webpack_require__(8);

	function toExpression(node) {
	  if ((0, _generated.isExpressionStatement)(node)) {
	    node = node.expression;
	  }

	  if ((0, _generated.isExpression)(node)) {
	    return node;
	  }

	  if ((0, _generated.isClass)(node)) {
	    node.type = "ClassExpression";
	  } else if ((0, _generated.isFunction)(node)) {
	    node.type = "FunctionExpression";
	  }

	  if (!(0, _generated.isExpression)(node)) {
	    throw new Error(`cannot turn ${node.type} to an expression`);
	  }

	  return node;
	}

/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = toKeyAlias;

	var _generated = __webpack_require__(8);

	var _cloneNode = _interopRequireDefault(__webpack_require__(19));

	var _removePropertiesDeep = _interopRequireDefault(__webpack_require__(54));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function toKeyAlias(node, key = node.key) {
	  let alias;

	  if (node.kind === "method") {
	    return toKeyAlias.increment() + "";
	  } else if ((0, _generated.isIdentifier)(key)) {
	    alias = key.name;
	  } else if ((0, _generated.isStringLiteral)(key)) {
	    alias = JSON.stringify(key.value);
	  } else {
	    alias = JSON.stringify((0, _removePropertiesDeep.default)((0, _cloneNode.default)(key)));
	  }

	  if (node.computed) {
	    alias = `[${alias}]`;
	  }

	  if (node.static) {
	    alias = `static:${alias}`;
	  }

	  return alias;
	}

	toKeyAlias.uid = 0;

	toKeyAlias.increment = function () {
	  if (toKeyAlias.uid >= Number.MAX_SAFE_INTEGER) {
	    return toKeyAlias.uid = 0;
	  } else {
	    return toKeyAlias.uid++;
	  }
	};

/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = toSequenceExpression;

	var _gatherSequenceExpressions = _interopRequireDefault(__webpack_require__(113));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function toSequenceExpression(nodes, scope) {
	  if (!nodes || !nodes.length) return;
	  const declars = [];
	  const result = (0, _gatherSequenceExpressions.default)(nodes, scope, declars);
	  if (!result) return;

	  for (const declar of declars) {
	    scope.push(declar);
	  }

	  return result;
	}

/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = toStatement;

	var _generated = __webpack_require__(8);

	var _generated2 = __webpack_require__(12);

	function toStatement(node, ignore) {
	  if ((0, _generated.isStatement)(node)) {
	    return node;
	  }

	  let mustHaveId = false;
	  let newType;

	  if ((0, _generated.isClass)(node)) {
	    mustHaveId = true;
	    newType = "ClassDeclaration";
	  } else if ((0, _generated.isFunction)(node)) {
	    mustHaveId = true;
	    newType = "FunctionDeclaration";
	  } else if ((0, _generated.isAssignmentExpression)(node)) {
	    return (0, _generated2.expressionStatement)(node);
	  }

	  if (mustHaveId && !node.id) {
	    newType = false;
	  }

	  if (!newType) {
	    if (ignore) {
	      return false;
	    } else {
	      throw new Error(`cannot turn ${node.type} to a statement`);
	    }
	  }

	  node.type = newType;
	  return node;
	}

/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = valueToNode;

	function _isPlainObject() {
	  const data = _interopRequireDefault(__webpack_require__(153));

	  _isPlainObject = function () {
	    return data;
	  };

	  return data;
	}

	function _isRegExp() {
	  const data = _interopRequireDefault(__webpack_require__(154));

	  _isRegExp = function () {
	    return data;
	  };

	  return data;
	}

	var _isValidIdentifier = _interopRequireDefault(__webpack_require__(20));

	var _generated = __webpack_require__(12);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function valueToNode(value) {
	  if (value === undefined) {
	    return (0, _generated.identifier)("undefined");
	  }

	  if (value === true || value === false) {
	    return (0, _generated.booleanLiteral)(value);
	  }

	  if (value === null) {
	    return (0, _generated.nullLiteral)();
	  }

	  if (typeof value === "string") {
	    return (0, _generated.stringLiteral)(value);
	  }

	  if (typeof value === "number") {
	    let result;

	    if (Number.isFinite(value)) {
	      result = (0, _generated.numericLiteral)(Math.abs(value));
	    } else {
	      let numerator;

	      if (Number.isNaN(value)) {
	        numerator = (0, _generated.numericLiteral)(0);
	      } else {
	        numerator = (0, _generated.numericLiteral)(1);
	      }

	      result = (0, _generated.binaryExpression)("/", numerator, (0, _generated.numericLiteral)(0));
	    }

	    if (value < 0 || Object.is(value, -0)) {
	      result = (0, _generated.unaryExpression)("-", result);
	    }

	    return result;
	  }

	  if ((0, _isRegExp().default)(value)) {
	    const pattern = value.source;
	    const flags = value.toString().match(/\/([a-z]+|)$/)[1];
	    return (0, _generated.regExpLiteral)(pattern, flags);
	  }

	  if (Array.isArray(value)) {
	    return (0, _generated.arrayExpression)(value.map(valueToNode));
	  }

	  if ((0, _isPlainObject().default)(value)) {
	    const props = [];

	    for (const key in value) {
	      let nodeKey;

	      if ((0, _isValidIdentifier.default)(key)) {
	        nodeKey = (0, _generated.identifier)(key);
	      } else {
	        nodeKey = (0, _generated.stringLiteral)(key);
	      }

	      props.push((0, _generated.objectProperty)(nodeKey, valueToNode(value[key])));
	    }

	    return (0, _generated.objectExpression)(props);
	  }

	  throw new Error("don't know how to turn this value into a node");
	}

/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var _utils = _interopRequireWildcard(__webpack_require__(15));

	var _es = __webpack_require__(28);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

	(0, _utils.default)("AwaitExpression", {
	  builder: ["argument"],
	  visitor: ["argument"],
	  aliases: ["Expression", "Terminatorless"],
	  fields: {
	    argument: {
	      validate: (0, _utils.assertNodeType)("Expression")
	    }
	  }
	});
	(0, _utils.default)("BindExpression", {
	  visitor: ["object", "callee"],
	  aliases: ["Expression"],
	  fields: {}
	});
	(0, _utils.default)("ClassProperty", {
	  visitor: ["key", "value", "typeAnnotation", "decorators"],
	  builder: ["key", "value", "typeAnnotation", "decorators", "computed"],
	  aliases: ["Property"],
	  fields: Object.assign({}, _es.classMethodOrPropertyCommon, {
	    value: {
	      validate: (0, _utils.assertNodeType)("Expression"),
	      optional: true
	    },
	    definite: {
	      validate: (0, _utils.assertValueType)("boolean"),
	      optional: true
	    },
	    typeAnnotation: {
	      validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
	      optional: true
	    },
	    decorators: {
	      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
	      optional: true
	    },
	    readonly: {
	      validate: (0, _utils.assertValueType)("boolean"),
	      optional: true
	    }
	  })
	});
	(0, _utils.default)("OptionalMemberExpression", {
	  builder: ["object", "property", "computed", "optional"],
	  visitor: ["object", "property"],
	  aliases: ["Expression"],
	  fields: {
	    object: {
	      validate: (0, _utils.assertNodeType)("Expression")
	    },
	    property: {
	      validate: function () {
	        const normal = (0, _utils.assertNodeType)("Identifier");
	        const computed = (0, _utils.assertNodeType)("Expression");
	        return function (node, key, val) {
	          const validator = node.computed ? computed : normal;
	          validator(node, key, val);
	        };
	      }()
	    },
	    computed: {
	      default: false
	    },
	    optional: {
	      validate: (0, _utils.assertValueType)("boolean")
	    }
	  }
	});
	(0, _utils.default)("OptionalCallExpression", {
	  visitor: ["callee", "arguments", "typeParameters", "typeArguments"],
	  builder: ["callee", "arguments", "optional"],
	  aliases: ["Expression"],
	  fields: {
	    callee: {
	      validate: (0, _utils.assertNodeType)("Expression")
	    },
	    arguments: {
	      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression", "SpreadElement", "JSXNamespacedName")))
	    },
	    optional: {
	      validate: (0, _utils.assertValueType)("boolean")
	    },
	    typeArguments: {
	      validate: (0, _utils.assertNodeType)("TypeParameterInstantiation"),
	      optional: true
	    },
	    typeParameters: {
	      validate: (0, _utils.assertNodeType)("TSTypeParameterInstantiation"),
	      optional: true
	    }
	  }
	});
	(0, _utils.default)("ClassPrivateProperty", {
	  visitor: ["key", "value"],
	  builder: ["key", "value"],
	  aliases: ["Property", "Private"],
	  fields: {
	    key: {
	      validate: (0, _utils.assertNodeType)("PrivateName")
	    },
	    value: {
	      validate: (0, _utils.assertNodeType)("Expression"),
	      optional: true
	    }
	  }
	});
	(0, _utils.default)("Import", {
	  aliases: ["Expression"]
	});
	(0, _utils.default)("Decorator", {
	  visitor: ["expression"],
	  fields: {
	    expression: {
	      validate: (0, _utils.assertNodeType)("Expression")
	    }
	  }
	});
	(0, _utils.default)("DoExpression", {
	  visitor: ["body"],
	  aliases: ["Expression"],
	  fields: {
	    body: {
	      validate: (0, _utils.assertNodeType)("BlockStatement")
	    }
	  }
	});
	(0, _utils.default)("ExportDefaultSpecifier", {
	  visitor: ["exported"],
	  aliases: ["ModuleSpecifier"],
	  fields: {
	    exported: {
	      validate: (0, _utils.assertNodeType)("Identifier")
	    }
	  }
	});
	(0, _utils.default)("ExportNamespaceSpecifier", {
	  visitor: ["exported"],
	  aliases: ["ModuleSpecifier"],
	  fields: {
	    exported: {
	      validate: (0, _utils.assertNodeType)("Identifier")
	    }
	  }
	});
	(0, _utils.default)("PrivateName", {
	  visitor: ["id"],
	  aliases: ["Private"],
	  fields: {
	    id: {
	      validate: (0, _utils.assertNodeType)("Identifier")
	    }
	  }
	});
	(0, _utils.default)("BigIntLiteral", {
	  builder: ["value"],
	  fields: {
	    value: {
	      validate: (0, _utils.assertValueType)("string")
	    }
	  },
	  aliases: ["Expression", "Pureish", "Literal", "Immutable"]
	});

/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var _utils = _interopRequireWildcard(__webpack_require__(15));

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

	const defineInterfaceishType = (name, typeParameterType = "TypeParameterDeclaration") => {
	  (0, _utils.default)(name, {
	    builder: ["id", "typeParameters", "extends", "body"],
	    visitor: ["id", "typeParameters", "extends", "mixins", "implements", "body"],
	    aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
	    fields: {
	      id: (0, _utils.validateType)("Identifier"),
	      typeParameters: (0, _utils.validateOptionalType)(typeParameterType),
	      extends: (0, _utils.validateOptional)((0, _utils.arrayOfType)("InterfaceExtends")),
	      mixins: (0, _utils.validateOptional)((0, _utils.arrayOfType)("InterfaceExtends")),
	      implements: (0, _utils.validateOptional)((0, _utils.arrayOfType)("ClassImplements")),
	      body: (0, _utils.validateType)("ObjectTypeAnnotation")
	    }
	  });
	};

	(0, _utils.default)("AnyTypeAnnotation", {
	  aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
	});
	(0, _utils.default)("ArrayTypeAnnotation", {
	  visitor: ["elementType"],
	  aliases: ["Flow", "FlowType"],
	  fields: {
	    elementType: (0, _utils.validateType)("FlowType")
	  }
	});
	(0, _utils.default)("BooleanTypeAnnotation", {
	  aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
	});
	(0, _utils.default)("BooleanLiteralTypeAnnotation", {
	  builder: ["value"],
	  aliases: ["Flow", "FlowType"],
	  fields: {
	    value: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
	  }
	});
	(0, _utils.default)("NullLiteralTypeAnnotation", {
	  aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
	});
	(0, _utils.default)("ClassImplements", {
	  visitor: ["id", "typeParameters"],
	  aliases: ["Flow"],
	  fields: {
	    id: (0, _utils.validateType)("Identifier"),
	    typeParameters: (0, _utils.validateOptionalType)("TypeParameterInstantiation")
	  }
	});
	defineInterfaceishType("DeclareClass", "TypeParameterInstantiation");
	(0, _utils.default)("DeclareFunction", {
	  visitor: ["id"],
	  aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
	  fields: {
	    id: (0, _utils.validateType)("Identifier"),
	    predicate: (0, _utils.validateOptionalType)("DeclaredPredicate")
	  }
	});
	defineInterfaceishType("DeclareInterface");
	(0, _utils.default)("DeclareModule", {
	  builder: ["id", "body", "kind"],
	  visitor: ["id", "body"],
	  aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
	  fields: {
	    id: (0, _utils.validateType)(["Identifier", "StringLiteral"]),
	    body: (0, _utils.validateType)("BlockStatement"),
	    kind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("CommonJS", "ES"))
	  }
	});
	(0, _utils.default)("DeclareModuleExports", {
	  visitor: ["typeAnnotation"],
	  aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
	  fields: {
	    typeAnnotation: (0, _utils.validateType)("TypeAnnotation")
	  }
	});
	(0, _utils.default)("DeclareTypeAlias", {
	  visitor: ["id", "typeParameters", "right"],
	  aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
	  fields: {
	    id: (0, _utils.validateType)("Identifier"),
	    typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
	    right: (0, _utils.validateType)("FlowType")
	  }
	});
	(0, _utils.default)("DeclareOpaqueType", {
	  visitor: ["id", "typeParameters", "supertype"],
	  aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
	  fields: {
	    id: (0, _utils.validateType)("Identifier"),
	    typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
	    supertype: (0, _utils.validateOptionalType)("FlowType")
	  }
	});
	(0, _utils.default)("DeclareVariable", {
	  visitor: ["id"],
	  aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
	  fields: {
	    id: (0, _utils.validateType)("Identifier")
	  }
	});
	(0, _utils.default)("DeclareExportDeclaration", {
	  visitor: ["declaration", "specifiers", "source"],
	  aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
	  fields: {
	    declaration: (0, _utils.validateOptionalType)("Flow"),
	    specifiers: (0, _utils.validateOptional)((0, _utils.arrayOfType)(["ExportSpecifier", "ExportNamespaceSpecifier"])),
	    source: (0, _utils.validateOptionalType)("StringLiteral"),
	    default: (0, _utils.validateOptional)((0, _utils.assertValueType)("boolean"))
	  }
	});
	(0, _utils.default)("DeclareExportAllDeclaration", {
	  visitor: ["source"],
	  aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
	  fields: {
	    source: (0, _utils.validateType)("StringLiteral"),
	    exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)(["type", "value"]))
	  }
	});
	(0, _utils.default)("DeclaredPredicate", {
	  visitor: ["value"],
	  aliases: ["Flow", "FlowPredicate"],
	  fields: {
	    value: (0, _utils.validateType)("Flow")
	  }
	});
	(0, _utils.default)("ExistsTypeAnnotation", {
	  aliases: ["Flow", "FlowType"]
	});
	(0, _utils.default)("FunctionTypeAnnotation", {
	  visitor: ["typeParameters", "params", "rest", "returnType"],
	  aliases: ["Flow", "FlowType"],
	  fields: {
	    typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
	    params: (0, _utils.validate)((0, _utils.arrayOfType)("FunctionTypeParam")),
	    rest: (0, _utils.validateOptionalType)("FunctionTypeParam"),
	    returnType: (0, _utils.validateType)("FlowType")
	  }
	});
	(0, _utils.default)("FunctionTypeParam", {
	  visitor: ["name", "typeAnnotation"],
	  aliases: ["Flow"],
	  fields: {
	    name: (0, _utils.validateOptionalType)("Identifier"),
	    typeAnnotation: (0, _utils.validateType)("FlowType"),
	    optional: (0, _utils.validateOptional)((0, _utils.assertValueType)("boolean"))
	  }
	});
	(0, _utils.default)("GenericTypeAnnotation", {
	  visitor: ["id", "typeParameters"],
	  aliases: ["Flow", "FlowType"],
	  fields: {
	    id: (0, _utils.validateType)("Identifier"),
	    typeParameters: (0, _utils.validateOptionalType)("TypeParameterInstantiation")
	  }
	});
	(0, _utils.default)("InferredPredicate", {
	  aliases: ["Flow", "FlowPredicate"]
	});
	(0, _utils.default)("InterfaceExtends", {
	  visitor: ["id", "typeParameters"],
	  aliases: ["Flow"],
	  fields: {
	    id: (0, _utils.validateType)("Identifier"),
	    typeParameters: (0, _utils.validateOptionalType)("TypeParameterInstantiation")
	  }
	});
	defineInterfaceishType("InterfaceDeclaration");
	(0, _utils.default)("InterfaceTypeAnnotation", {
	  visitor: ["extends", "body"],
	  aliases: ["Flow", "FlowType"],
	  fields: {
	    extends: (0, _utils.validateOptional)((0, _utils.arrayOfType)("InterfaceExtends")),
	    body: (0, _utils.validateType)("ObjectTypeAnnotation")
	  }
	});
	(0, _utils.default)("IntersectionTypeAnnotation", {
	  visitor: ["types"],
	  aliases: ["Flow", "FlowType"],
	  fields: {
	    types: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
	  }
	});
	(0, _utils.default)("MixedTypeAnnotation", {
	  aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
	});
	(0, _utils.default)("EmptyTypeAnnotation", {
	  aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
	});
	(0, _utils.default)("NullableTypeAnnotation", {
	  visitor: ["typeAnnotation"],
	  aliases: ["Flow", "FlowType"],
	  fields: {
	    typeAnnotation: (0, _utils.validateType)("FlowType")
	  }
	});
	(0, _utils.default)("NumberLiteralTypeAnnotation", {
	  builder: ["value"],
	  aliases: ["Flow", "FlowType"],
	  fields: {
	    value: (0, _utils.validate)((0, _utils.assertValueType)("number"))
	  }
	});
	(0, _utils.default)("NumberTypeAnnotation", {
	  aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
	});
	(0, _utils.default)("ObjectTypeAnnotation", {
	  visitor: ["properties", "indexers", "callProperties", "internalSlots"],
	  aliases: ["Flow", "FlowType"],
	  builder: ["properties", "indexers", "callProperties", "internalSlots", "exact"],
	  fields: {
	    properties: (0, _utils.validate)((0, _utils.arrayOfType)(["ObjectTypeProperty", "ObjectTypeSpreadProperty"])),
	    indexers: (0, _utils.validateOptional)((0, _utils.arrayOfType)("ObjectTypeIndexer")),
	    callProperties: (0, _utils.validateOptional)((0, _utils.arrayOfType)("ObjectTypeCallProperty")),
	    internalSlots: (0, _utils.validateOptional)((0, _utils.arrayOfType)("ObjectTypeInternalSlot")),
	    exact: {
	      validate: (0, _utils.assertValueType)("boolean"),
	      default: false
	    }
	  }
	});
	(0, _utils.default)("ObjectTypeInternalSlot", {
	  visitor: ["id", "value", "optional", "static", "method"],
	  aliases: ["Flow", "UserWhitespacable"],
	  fields: {
	    id: (0, _utils.validateType)("Identifier"),
	    value: (0, _utils.validateType)("FlowType"),
	    optional: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
	    static: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
	    method: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
	  }
	});
	(0, _utils.default)("ObjectTypeCallProperty", {
	  visitor: ["value"],
	  aliases: ["Flow", "UserWhitespacable"],
	  fields: {
	    value: (0, _utils.validateType)("FlowType"),
	    static: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
	  }
	});
	(0, _utils.default)("ObjectTypeIndexer", {
	  visitor: ["id", "key", "value", "variance"],
	  aliases: ["Flow", "UserWhitespacable"],
	  fields: {
	    id: (0, _utils.validateOptionalType)("Identifier"),
	    key: (0, _utils.validateType)("FlowType"),
	    value: (0, _utils.validateType)("FlowType"),
	    static: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
	    variance: (0, _utils.validateOptionalType)("Variance")
	  }
	});
	(0, _utils.default)("ObjectTypeProperty", {
	  visitor: ["key", "value", "variance"],
	  aliases: ["Flow", "UserWhitespacable"],
	  fields: {
	    key: (0, _utils.validateType)(["Identifier", "StringLiteral"]),
	    value: (0, _utils.validateType)("FlowType"),
	    kind: (0, _utils.validate)((0, _utils.assertOneOf)("init", "get", "set")),
	    static: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
	    proto: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
	    optional: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
	    variance: (0, _utils.validateOptionalType)("Variance")
	  }
	});
	(0, _utils.default)("ObjectTypeSpreadProperty", {
	  visitor: ["argument"],
	  aliases: ["Flow", "UserWhitespacable"],
	  fields: {
	    argument: (0, _utils.validateType)("FlowType")
	  }
	});
	(0, _utils.default)("OpaqueType", {
	  visitor: ["id", "typeParameters", "supertype", "impltype"],
	  aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
	  fields: {
	    id: (0, _utils.validateType)("Identifier"),
	    typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
	    supertype: (0, _utils.validateOptionalType)("FlowType"),
	    impltype: (0, _utils.validateType)("FlowType")
	  }
	});
	(0, _utils.default)("QualifiedTypeIdentifier", {
	  visitor: ["id", "qualification"],
	  aliases: ["Flow"],
	  fields: {
	    id: (0, _utils.validateType)("Identifier"),
	    qualification: (0, _utils.validateType)(["Identifier", "QualifiedTypeIdentifier"])
	  }
	});
	(0, _utils.default)("StringLiteralTypeAnnotation", {
	  builder: ["value"],
	  aliases: ["Flow", "FlowType"],
	  fields: {
	    value: (0, _utils.validate)((0, _utils.assertValueType)("string"))
	  }
	});
	(0, _utils.default)("StringTypeAnnotation", {
	  aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
	});
	(0, _utils.default)("ThisTypeAnnotation", {
	  aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
	});
	(0, _utils.default)("TupleTypeAnnotation", {
	  visitor: ["types"],
	  aliases: ["Flow", "FlowType"],
	  fields: {
	    types: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
	  }
	});
	(0, _utils.default)("TypeofTypeAnnotation", {
	  visitor: ["argument"],
	  aliases: ["Flow", "FlowType"],
	  fields: {
	    argument: (0, _utils.validateType)("FlowType")
	  }
	});
	(0, _utils.default)("TypeAlias", {
	  visitor: ["id", "typeParameters", "right"],
	  aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
	  fields: {
	    id: (0, _utils.validateType)("Identifier"),
	    typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
	    right: (0, _utils.validateType)("FlowType")
	  }
	});
	(0, _utils.default)("TypeAnnotation", {
	  aliases: ["Flow"],
	  visitor: ["typeAnnotation"],
	  fields: {
	    typeAnnotation: (0, _utils.validateType)("FlowType")
	  }
	});
	(0, _utils.default)("TypeCastExpression", {
	  visitor: ["expression", "typeAnnotation"],
	  aliases: ["Flow", "ExpressionWrapper", "Expression"],
	  fields: {
	    expression: (0, _utils.validateType)("Expression"),
	    typeAnnotation: (0, _utils.validateType)("TypeAnnotation")
	  }
	});
	(0, _utils.default)("TypeParameter", {
	  aliases: ["Flow"],
	  visitor: ["bound", "default", "variance"],
	  fields: {
	    name: (0, _utils.validate)((0, _utils.assertValueType)("string")),
	    bound: (0, _utils.validateOptionalType)("TypeAnnotation"),
	    default: (0, _utils.validateOptionalType)("FlowType"),
	    variance: (0, _utils.validateOptionalType)("Variance")
	  }
	});
	(0, _utils.default)("TypeParameterDeclaration", {
	  aliases: ["Flow"],
	  visitor: ["params"],
	  fields: {
	    params: (0, _utils.validate)((0, _utils.arrayOfType)("TypeParameter"))
	  }
	});
	(0, _utils.default)("TypeParameterInstantiation", {
	  aliases: ["Flow"],
	  visitor: ["params"],
	  fields: {
	    params: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
	  }
	});
	(0, _utils.default)("UnionTypeAnnotation", {
	  visitor: ["types"],
	  aliases: ["Flow", "FlowType"],
	  fields: {
	    types: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
	  }
	});
	(0, _utils.default)("Variance", {
	  aliases: ["Flow"],
	  builder: ["kind"],
	  fields: {
	    kind: (0, _utils.validate)((0, _utils.assertOneOf)("minus", "plus"))
	  }
	});
	(0, _utils.default)("VoidTypeAnnotation", {
	  aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
	});

/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var _utils = _interopRequireWildcard(__webpack_require__(15));

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

	(0, _utils.default)("JSXAttribute", {
	  visitor: ["name", "value"],
	  aliases: ["JSX", "Immutable"],
	  fields: {
	    name: {
	      validate: (0, _utils.assertNodeType)("JSXIdentifier", "JSXNamespacedName")
	    },
	    value: {
	      optional: true,
	      validate: (0, _utils.assertNodeType)("JSXElement", "JSXFragment", "StringLiteral", "JSXExpressionContainer")
	    }
	  }
	});
	(0, _utils.default)("JSXClosingElement", {
	  visitor: ["name"],
	  aliases: ["JSX", "Immutable"],
	  fields: {
	    name: {
	      validate: (0, _utils.assertNodeType)("JSXIdentifier", "JSXMemberExpression")
	    }
	  }
	});
	(0, _utils.default)("JSXElement", {
	  builder: ["openingElement", "closingElement", "children", "selfClosing"],
	  visitor: ["openingElement", "children", "closingElement"],
	  aliases: ["JSX", "Immutable", "Expression"],
	  fields: {
	    openingElement: {
	      validate: (0, _utils.assertNodeType)("JSXOpeningElement")
	    },
	    closingElement: {
	      optional: true,
	      validate: (0, _utils.assertNodeType)("JSXClosingElement")
	    },
	    children: {
	      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment")))
	    }
	  }
	});
	(0, _utils.default)("JSXEmptyExpression", {
	  aliases: ["JSX"]
	});
	(0, _utils.default)("JSXExpressionContainer", {
	  visitor: ["expression"],
	  aliases: ["JSX", "Immutable"],
	  fields: {
	    expression: {
	      validate: (0, _utils.assertNodeType)("Expression")
	    }
	  }
	});
	(0, _utils.default)("JSXSpreadChild", {
	  visitor: ["expression"],
	  aliases: ["JSX", "Immutable"],
	  fields: {
	    expression: {
	      validate: (0, _utils.assertNodeType)("Expression")
	    }
	  }
	});
	(0, _utils.default)("JSXIdentifier", {
	  builder: ["name"],
	  aliases: ["JSX"],
	  fields: {
	    name: {
	      validate: (0, _utils.assertValueType)("string")
	    }
	  }
	});
	(0, _utils.default)("JSXMemberExpression", {
	  visitor: ["object", "property"],
	  aliases: ["JSX"],
	  fields: {
	    object: {
	      validate: (0, _utils.assertNodeType)("JSXMemberExpression", "JSXIdentifier")
	    },
	    property: {
	      validate: (0, _utils.assertNodeType)("JSXIdentifier")
	    }
	  }
	});
	(0, _utils.default)("JSXNamespacedName", {
	  visitor: ["namespace", "name"],
	  aliases: ["JSX"],
	  fields: {
	    namespace: {
	      validate: (0, _utils.assertNodeType)("JSXIdentifier")
	    },
	    name: {
	      validate: (0, _utils.assertNodeType)("JSXIdentifier")
	    }
	  }
	});
	(0, _utils.default)("JSXOpeningElement", {
	  builder: ["name", "attributes", "selfClosing"],
	  visitor: ["name", "attributes"],
	  aliases: ["JSX", "Immutable"],
	  fields: {
	    name: {
	      validate: (0, _utils.assertNodeType)("JSXIdentifier", "JSXMemberExpression")
	    },
	    selfClosing: {
	      default: false,
	      validate: (0, _utils.assertValueType)("boolean")
	    },
	    attributes: {
	      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("JSXAttribute", "JSXSpreadAttribute")))
	    },
	    typeParameters: {
	      validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
	      optional: true
	    }
	  }
	});
	(0, _utils.default)("JSXSpreadAttribute", {
	  visitor: ["argument"],
	  aliases: ["JSX"],
	  fields: {
	    argument: {
	      validate: (0, _utils.assertNodeType)("Expression")
	    }
	  }
	});
	(0, _utils.default)("JSXText", {
	  aliases: ["JSX", "Immutable"],
	  builder: ["value"],
	  fields: {
	    value: {
	      validate: (0, _utils.assertValueType)("string")
	    }
	  }
	});
	(0, _utils.default)("JSXFragment", {
	  builder: ["openingFragment", "closingFragment", "children"],
	  visitor: ["openingFragment", "children", "closingFragment"],
	  aliases: ["JSX", "Immutable", "Expression"],
	  fields: {
	    openingFragment: {
	      validate: (0, _utils.assertNodeType)("JSXOpeningFragment")
	    },
	    closingFragment: {
	      validate: (0, _utils.assertNodeType)("JSXClosingFragment")
	    },
	    children: {
	      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment")))
	    }
	  }
	});
	(0, _utils.default)("JSXOpeningFragment", {
	  aliases: ["JSX", "Immutable"]
	});
	(0, _utils.default)("JSXClosingFragment", {
	  aliases: ["JSX", "Immutable"]
	});

/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var _utils = _interopRequireWildcard(__webpack_require__(15));

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

	(0, _utils.default)("Noop", {
	  visitor: []
	});
	(0, _utils.default)("ParenthesizedExpression", {
	  visitor: ["expression"],
	  aliases: ["Expression", "ExpressionWrapper"],
	  fields: {
	    expression: {
	      validate: (0, _utils.assertNodeType)("Expression")
	    }
	  }
	});

/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var _utils = _interopRequireWildcard(__webpack_require__(15));

	var _core = __webpack_require__(27);

	var _es = __webpack_require__(28);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

	const bool = (0, _utils.assertValueType)("boolean");
	const tSFunctionTypeAnnotationCommon = {
	  returnType: {
	    validate: (0, _utils.assertNodeType)("TSTypeAnnotation", "Noop"),
	    optional: true
	  },
	  typeParameters: {
	    validate: (0, _utils.assertNodeType)("TSTypeParameterDeclaration", "Noop"),
	    optional: true
	  }
	};
	(0, _utils.default)("TSParameterProperty", {
	  aliases: ["LVal"],
	  visitor: ["parameter"],
	  fields: {
	    accessibility: {
	      validate: (0, _utils.assertOneOf)("public", "private", "protected"),
	      optional: true
	    },
	    readonly: {
	      validate: (0, _utils.assertValueType)("boolean"),
	      optional: true
	    },
	    parameter: {
	      validate: (0, _utils.assertNodeType)("Identifier", "AssignmentPattern")
	    }
	  }
	});
	(0, _utils.default)("TSDeclareFunction", {
	  aliases: ["Statement", "Declaration"],
	  visitor: ["id", "typeParameters", "params", "returnType"],
	  fields: Object.assign({}, _core.functionDeclarationCommon, tSFunctionTypeAnnotationCommon)
	});
	(0, _utils.default)("TSDeclareMethod", {
	  visitor: ["decorators", "key", "typeParameters", "params", "returnType"],
	  fields: Object.assign({}, _es.classMethodOrDeclareMethodCommon, tSFunctionTypeAnnotationCommon)
	});
	(0, _utils.default)("TSQualifiedName", {
	  aliases: ["TSEntityName"],
	  visitor: ["left", "right"],
	  fields: {
	    left: (0, _utils.validateType)("TSEntityName"),
	    right: (0, _utils.validateType)("Identifier")
	  }
	});
	const signatureDeclarationCommon = {
	  typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterDeclaration"),
	  parameters: (0, _utils.validateArrayOfType)(["Identifier", "RestElement"]),
	  typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation")
	};
	const callConstructSignatureDeclaration = {
	  aliases: ["TSTypeElement"],
	  visitor: ["typeParameters", "parameters", "typeAnnotation"],
	  fields: signatureDeclarationCommon
	};
	(0, _utils.default)("TSCallSignatureDeclaration", callConstructSignatureDeclaration);
	(0, _utils.default)("TSConstructSignatureDeclaration", callConstructSignatureDeclaration);
	const namedTypeElementCommon = {
	  key: (0, _utils.validateType)("Expression"),
	  computed: (0, _utils.validate)(bool),
	  optional: (0, _utils.validateOptional)(bool)
	};
	(0, _utils.default)("TSPropertySignature", {
	  aliases: ["TSTypeElement"],
	  visitor: ["key", "typeAnnotation", "initializer"],
	  fields: Object.assign({}, namedTypeElementCommon, {
	    readonly: (0, _utils.validateOptional)(bool),
	    typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation"),
	    initializer: (0, _utils.validateOptionalType)("Expression")
	  })
	});
	(0, _utils.default)("TSMethodSignature", {
	  aliases: ["TSTypeElement"],
	  visitor: ["key", "typeParameters", "parameters", "typeAnnotation"],
	  fields: Object.assign({}, signatureDeclarationCommon, namedTypeElementCommon)
	});
	(0, _utils.default)("TSIndexSignature", {
	  aliases: ["TSTypeElement"],
	  visitor: ["parameters", "typeAnnotation"],
	  fields: {
	    readonly: (0, _utils.validateOptional)(bool),
	    parameters: (0, _utils.validateArrayOfType)("Identifier"),
	    typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation")
	  }
	});
	const tsKeywordTypes = ["TSAnyKeyword", "TSNumberKeyword", "TSObjectKeyword", "TSBooleanKeyword", "TSStringKeyword", "TSSymbolKeyword", "TSVoidKeyword", "TSUndefinedKeyword", "TSNullKeyword", "TSNeverKeyword"];

	for (const type of tsKeywordTypes) {
	  (0, _utils.default)(type, {
	    aliases: ["TSType"],
	    visitor: [],
	    fields: {}
	  });
	}

	(0, _utils.default)("TSThisType", {
	  aliases: ["TSType"],
	  visitor: [],
	  fields: {}
	});
	const fnOrCtr = {
	  aliases: ["TSType"],
	  visitor: ["typeParameters", "typeAnnotation"],
	  fields: signatureDeclarationCommon
	};
	(0, _utils.default)("TSFunctionType", fnOrCtr);
	(0, _utils.default)("TSConstructorType", fnOrCtr);
	(0, _utils.default)("TSTypeReference", {
	  aliases: ["TSType"],
	  visitor: ["typeName", "typeParameters"],
	  fields: {
	    typeName: (0, _utils.validateType)("TSEntityName"),
	    typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")
	  }
	});
	(0, _utils.default)("TSTypePredicate", {
	  aliases: ["TSType"],
	  visitor: ["parameterName", "typeAnnotation"],
	  fields: {
	    parameterName: (0, _utils.validateType)(["Identifier", "TSThisType"]),
	    typeAnnotation: (0, _utils.validateType)("TSTypeAnnotation")
	  }
	});
	(0, _utils.default)("TSTypeQuery", {
	  aliases: ["TSType"],
	  visitor: ["exprName"],
	  fields: {
	    exprName: (0, _utils.validateType)("TSEntityName")
	  }
	});
	(0, _utils.default)("TSTypeLiteral", {
	  aliases: ["TSType"],
	  visitor: ["members"],
	  fields: {
	    members: (0, _utils.validateArrayOfType)("TSTypeElement")
	  }
	});
	(0, _utils.default)("TSArrayType", {
	  aliases: ["TSType"],
	  visitor: ["elementType"],
	  fields: {
	    elementType: (0, _utils.validateType)("TSType")
	  }
	});
	(0, _utils.default)("TSTupleType", {
	  aliases: ["TSType"],
	  visitor: ["elementTypes"],
	  fields: {
	    elementTypes: (0, _utils.validateArrayOfType)("TSType")
	  }
	});
	const unionOrIntersection = {
	  aliases: ["TSType"],
	  visitor: ["types"],
	  fields: {
	    types: (0, _utils.validateArrayOfType)("TSType")
	  }
	};
	(0, _utils.default)("TSUnionType", unionOrIntersection);
	(0, _utils.default)("TSIntersectionType", unionOrIntersection);
	(0, _utils.default)("TSConditionalType", {
	  aliases: ["TSType"],
	  visitor: ["checkType", "extendsType", "trueType", "falseType"],
	  fields: {
	    checkType: (0, _utils.validateType)("TSType"),
	    extendsType: (0, _utils.validateType)("TSType"),
	    trueType: (0, _utils.validateType)("TSType"),
	    falseType: (0, _utils.validateType)("TSType")
	  }
	});
	(0, _utils.default)("TSInferType", {
	  aliases: ["TSType"],
	  visitor: ["typeParameter"],
	  fields: {
	    typeParameter: (0, _utils.validateType)("TSTypeParameter")
	  }
	});
	(0, _utils.default)("TSParenthesizedType", {
	  aliases: ["TSType"],
	  visitor: ["typeAnnotation"],
	  fields: {
	    typeAnnotation: (0, _utils.validateType)("TSType")
	  }
	});
	(0, _utils.default)("TSTypeOperator", {
	  aliases: ["TSType"],
	  visitor: ["typeAnnotation"],
	  fields: {
	    operator: (0, _utils.validate)((0, _utils.assertValueType)("string")),
	    typeAnnotation: (0, _utils.validateType)("TSType")
	  }
	});
	(0, _utils.default)("TSIndexedAccessType", {
	  aliases: ["TSType"],
	  visitor: ["objectType", "indexType"],
	  fields: {
	    objectType: (0, _utils.validateType)("TSType"),
	    indexType: (0, _utils.validateType)("TSType")
	  }
	});
	(0, _utils.default)("TSMappedType", {
	  aliases: ["TSType"],
	  visitor: ["typeParameter", "typeAnnotation"],
	  fields: {
	    readonly: (0, _utils.validateOptional)(bool),
	    typeParameter: (0, _utils.validateType)("TSTypeParameter"),
	    optional: (0, _utils.validateOptional)(bool),
	    typeAnnotation: (0, _utils.validateOptionalType)("TSType")
	  }
	});
	(0, _utils.default)("TSLiteralType", {
	  aliases: ["TSType"],
	  visitor: ["literal"],
	  fields: {
	    literal: (0, _utils.validateType)(["NumericLiteral", "StringLiteral", "BooleanLiteral"])
	  }
	});
	(0, _utils.default)("TSExpressionWithTypeArguments", {
	  aliases: ["TSType"],
	  visitor: ["expression", "typeParameters"],
	  fields: {
	    expression: (0, _utils.validateType)("TSEntityName"),
	    typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")
	  }
	});
	(0, _utils.default)("TSInterfaceDeclaration", {
	  aliases: ["Statement", "Declaration"],
	  visitor: ["id", "typeParameters", "extends", "body"],
	  fields: {
	    declare: (0, _utils.validateOptional)(bool),
	    id: (0, _utils.validateType)("Identifier"),
	    typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterDeclaration"),
	    extends: (0, _utils.validateOptional)((0, _utils.arrayOfType)("TSExpressionWithTypeArguments")),
	    body: (0, _utils.validateType)("TSInterfaceBody")
	  }
	});
	(0, _utils.default)("TSInterfaceBody", {
	  visitor: ["body"],
	  fields: {
	    body: (0, _utils.validateArrayOfType)("TSTypeElement")
	  }
	});
	(0, _utils.default)("TSTypeAliasDeclaration", {
	  aliases: ["Statement", "Declaration"],
	  visitor: ["id", "typeParameters", "typeAnnotation"],
	  fields: {
	    declare: (0, _utils.validateOptional)(bool),
	    id: (0, _utils.validateType)("Identifier"),
	    typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterDeclaration"),
	    typeAnnotation: (0, _utils.validateType)("TSType")
	  }
	});
	(0, _utils.default)("TSAsExpression", {
	  aliases: ["Expression"],
	  visitor: ["expression", "typeAnnotation"],
	  fields: {
	    expression: (0, _utils.validateType)("Expression"),
	    typeAnnotation: (0, _utils.validateType)("TSType")
	  }
	});
	(0, _utils.default)("TSTypeAssertion", {
	  aliases: ["Expression"],
	  visitor: ["typeAnnotation", "expression"],
	  fields: {
	    typeAnnotation: (0, _utils.validateType)("TSType"),
	    expression: (0, _utils.validateType)("Expression")
	  }
	});
	(0, _utils.default)("TSEnumDeclaration", {
	  aliases: ["Statement", "Declaration"],
	  visitor: ["id", "members"],
	  fields: {
	    declare: (0, _utils.validateOptional)(bool),
	    const: (0, _utils.validateOptional)(bool),
	    id: (0, _utils.validateType)("Identifier"),
	    members: (0, _utils.validateArrayOfType)("TSEnumMember"),
	    initializer: (0, _utils.validateOptionalType)("Expression")
	  }
	});
	(0, _utils.default)("TSEnumMember", {
	  visitor: ["id", "initializer"],
	  fields: {
	    id: (0, _utils.validateType)(["Identifier", "StringLiteral"]),
	    initializer: (0, _utils.validateOptionalType)("Expression")
	  }
	});
	(0, _utils.default)("TSModuleDeclaration", {
	  aliases: ["Statement", "Declaration"],
	  visitor: ["id", "body"],
	  fields: {
	    declare: (0, _utils.validateOptional)(bool),
	    global: (0, _utils.validateOptional)(bool),
	    id: (0, _utils.validateType)(["Identifier", "StringLiteral"]),
	    body: (0, _utils.validateType)(["TSModuleBlock", "TSModuleDeclaration"])
	  }
	});
	(0, _utils.default)("TSModuleBlock", {
	  visitor: ["body"],
	  fields: {
	    body: (0, _utils.validateArrayOfType)("Statement")
	  }
	});
	(0, _utils.default)("TSImportEqualsDeclaration", {
	  aliases: ["Statement"],
	  visitor: ["id", "moduleReference"],
	  fields: {
	    isExport: (0, _utils.validate)(bool),
	    id: (0, _utils.validateType)("Identifier"),
	    moduleReference: (0, _utils.validateType)(["TSEntityName", "TSExternalModuleReference"])
	  }
	});
	(0, _utils.default)("TSExternalModuleReference", {
	  visitor: ["expression"],
	  fields: {
	    expression: (0, _utils.validateType)("StringLiteral")
	  }
	});
	(0, _utils.default)("TSNonNullExpression", {
	  aliases: ["Expression"],
	  visitor: ["expression"],
	  fields: {
	    expression: (0, _utils.validateType)("Expression")
	  }
	});
	(0, _utils.default)("TSExportAssignment", {
	  aliases: ["Statement"],
	  visitor: ["expression"],
	  fields: {
	    expression: (0, _utils.validateType)("Expression")
	  }
	});
	(0, _utils.default)("TSNamespaceExportDeclaration", {
	  aliases: ["Statement"],
	  visitor: ["id"],
	  fields: {
	    id: (0, _utils.validateType)("Identifier")
	  }
	});
	(0, _utils.default)("TSTypeAnnotation", {
	  visitor: ["typeAnnotation"],
	  fields: {
	    typeAnnotation: {
	      validate: (0, _utils.assertNodeType)("TSType")
	    }
	  }
	});
	(0, _utils.default)("TSTypeParameterInstantiation", {
	  visitor: ["params"],
	  fields: {
	    params: {
	      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("TSType")))
	    }
	  }
	});
	(0, _utils.default)("TSTypeParameterDeclaration", {
	  visitor: ["params"],
	  fields: {
	    params: {
	      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("TSTypeParameter")))
	    }
	  }
	});
	(0, _utils.default)("TSTypeParameter", {
	  visitor: ["constraint", "default"],
	  fields: {
	    name: {
	      validate: (0, _utils.assertValueType)("string")
	    },
	    constraint: {
	      validate: (0, _utils.assertNodeType)("TSType"),
	      optional: true
	    },
	    default: {
	      validate: (0, _utils.assertNodeType)("TSType"),
	      optional: true
	    }
	  }
	});

/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = appendToMemberExpression;

	var _generated = __webpack_require__(12);

	function appendToMemberExpression(member, append, computed = false) {
	  member.object = (0, _generated.memberExpression)(member.object, member.property, member.computed);
	  member.property = append;
	  member.computed = !!computed;
	  return member;
	}

/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = inherits;

	var _constants = __webpack_require__(16);

	var _inheritsComments = _interopRequireDefault(__webpack_require__(49));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function inherits(child, parent) {
	  if (!child || !parent) return child;

	  for (const key of _constants.INHERIT_KEYS.optional) {
	    if (child[key] == null) {
	      child[key] = parent[key];
	    }
	  }

	  for (const key in parent) {
	    if (key[0] === "_" && key !== "__clone") child[key] = parent[key];
	  }

	  for (const key of _constants.INHERIT_KEYS.force) {
	    child[key] = parent[key];
	  }

	  (0, _inheritsComments.default)(child, parent);
	  return child;
	}

/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = prependToMemberExpression;

	var _generated = __webpack_require__(12);

	function prependToMemberExpression(member, prepend) {
	  member.object = (0, _generated.memberExpression)(prepend, member.object);
	  return member;
	}

/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = getOuterBindingIdentifiers;

	var _getBindingIdentifiers = _interopRequireDefault(__webpack_require__(21));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function getOuterBindingIdentifiers(node, duplicates) {
	  return (0, _getBindingIdentifiers.default)(node, duplicates, true);
	}

/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = traverse;

	var _definitions = __webpack_require__(14);

	function traverse(node, handlers, state) {
	  if (typeof handlers === "function") {
	    handlers = {
	      enter: handlers
	    };
	  }

	  const {
	    enter,
	    exit
	  } = handlers;
	  traverseSimpleImpl(node, enter, exit, state, []);
	}

	function traverseSimpleImpl(node, enter, exit, state, ancestors) {
	  const keys = _definitions.VISITOR_KEYS[node.type];
	  if (!keys) return;
	  if (enter) enter(node, ancestors, state);

	  for (const key of keys) {
	    const subNode = node[key];

	    if (Array.isArray(subNode)) {
	      for (let i = 0; i < subNode.length; i++) {
	        const child = subNode[i];
	        if (!child) continue;
	        ancestors.push({
	          node,
	          key,
	          index: i
	        });
	        traverseSimpleImpl(child, enter, exit, state, ancestors);
	        ancestors.pop();
	      }
	    } else if (subNode) {
	      ancestors.push({
	        node,
	        key
	      });
	      traverseSimpleImpl(subNode, enter, exit, state, ancestors);
	      ancestors.pop();
	    }
	  }

	  if (exit) exit(node, ancestors, state);
	}

/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = cleanJSXElementLiteralChild;

	var _generated = __webpack_require__(12);

	function cleanJSXElementLiteralChild(child, args) {
	  const lines = child.value.split(/\r\n|\n|\r/);
	  let lastNonEmptyLine = 0;

	  for (let i = 0; i < lines.length; i++) {
	    if (lines[i].match(/[^ \t]/)) {
	      lastNonEmptyLine = i;
	    }
	  }

	  let str = "";

	  for (let i = 0; i < lines.length; i++) {
	    const line = lines[i];
	    const isFirstLine = i === 0;
	    const isLastLine = i === lines.length - 1;
	    const isLastNonEmptyLine = i === lastNonEmptyLine;
	    let trimmedLine = line.replace(/\t/g, " ");

	    if (!isFirstLine) {
	      trimmedLine = trimmedLine.replace(/^[ ]+/, "");
	    }

	    if (!isLastLine) {
	      trimmedLine = trimmedLine.replace(/[ ]+$/, "");
	    }

	    if (trimmedLine) {
	      if (!isLastNonEmptyLine) {
	        trimmedLine += " ";
	      }

	      str += trimmedLine;
	    }
	  }

	  if (str) args.push((0, _generated.stringLiteral)(str));
	}

/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = isBinding;

	var _getBindingIdentifiers = _interopRequireDefault(__webpack_require__(21));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function isBinding(node, parent) {
	  const keys = _getBindingIdentifiers.default.keys[parent.type];

	  if (keys) {
	    for (let i = 0; i < keys.length; i++) {
	      const key = keys[i];
	      const val = parent[key];

	      if (Array.isArray(val)) {
	        if (val.indexOf(node) >= 0) return true;
	      } else {
	        if (val === node) return true;
	      }
	    }
	  }

	  return false;
	}

/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = isBlockScoped;

	var _generated = __webpack_require__(8);

	var _isLet = _interopRequireDefault(__webpack_require__(57));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function isBlockScoped(node) {
	  return (0, _generated.isFunctionDeclaration)(node) || (0, _generated.isClassDeclaration)(node) || (0, _isLet.default)(node);
	}

/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = isImmutable;

	var _isType = _interopRequireDefault(__webpack_require__(32));

	var _generated = __webpack_require__(8);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function isImmutable(node) {
	  if ((0, _isType.default)(node.type, "Immutable")) return true;

	  if ((0, _generated.isIdentifier)(node)) {
	    if (node.name === "undefined") {
	      return true;
	    } else {
	      return false;
	    }
	  }

	  return false;
	}

/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = isNodesEquivalent;

	var _definitions = __webpack_require__(14);

	function isNodesEquivalent(a, b) {
	  if (typeof a !== "object" || typeof b !== "object" || a == null || b == null) {
	    return a === b;
	  }

	  if (a.type !== b.type) {
	    return false;
	  }

	  const fields = Object.keys(_definitions.NODE_FIELDS[a.type] || a.type);
	  const visitorKeys = _definitions.VISITOR_KEYS[a.type];

	  for (const field of fields) {
	    if (typeof a[field] !== typeof b[field]) {
	      return false;
	    }

	    if (Array.isArray(a[field])) {
	      if (!Array.isArray(b[field])) {
	        return false;
	      }

	      if (a[field].length !== b[field].length) {
	        return false;
	      }

	      for (let i = 0; i < a[field].length; i++) {
	        if (!isNodesEquivalent(a[field][i], b[field][i])) {
	          return false;
	        }
	      }

	      continue;
	    }

	    if (typeof a[field] === "object" && (!visitorKeys || !visitorKeys.includes(field))) {
	      for (const key in a[field]) {
	        if (a[field][key] !== b[field][key]) {
	          return false;
	        }
	      }

	      continue;
	    }

	    if (!isNodesEquivalent(a[field], b[field])) {
	      return false;
	    }
	  }

	  return true;
	}

/***/ }),
/* 136 */
/***/ (function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = isReferenced;

	function isReferenced(node, parent) {
	  switch (parent.type) {
	    case "MemberExpression":
	    case "JSXMemberExpression":
	    case "OptionalMemberExpression":
	      if (parent.property === node) {
	        return !!parent.computed;
	      }

	      return parent.object === node;

	    case "VariableDeclarator":
	      return parent.init === node;

	    case "ArrowFunctionExpression":
	      return parent.body === node;

	    case "ExportSpecifier":
	      if (parent.source) {
	        return false;
	      }

	      return parent.local === node;

	    case "ObjectProperty":
	    case "ClassProperty":
	    case "ClassPrivateProperty":
	    case "ClassMethod":
	    case "ObjectMethod":
	      if (parent.key === node) {
	        return !!parent.computed;
	      }

	      return parent.value === node;

	    case "ClassDeclaration":
	    case "ClassExpression":
	      return parent.superClass === node;

	    case "AssignmentExpression":
	      return parent.right === node;

	    case "AssignmentPattern":
	      return parent.right === node;

	    case "LabeledStatement":
	      return false;

	    case "CatchClause":
	      return false;

	    case "RestElement":
	      return false;

	    case "FunctionDeclaration":
	    case "FunctionExpression":
	      return false;

	    case "ExportNamespaceSpecifier":
	    case "ExportDefaultSpecifier":
	      return false;

	    case "ImportDefaultSpecifier":
	    case "ImportNamespaceSpecifier":
	    case "ImportSpecifier":
	      return false;

	    case "JSXAttribute":
	      return false;

	    case "ObjectPattern":
	    case "ArrayPattern":
	      return false;

	    case "MetaProperty":
	      return false;

	    case "ObjectTypeProperty":
	      return parent.key !== node;
	  }

	  return true;
	}

/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = isScope;

	var _generated = __webpack_require__(8);

	function isScope(node, parent) {
	  if ((0, _generated.isBlockStatement)(node) && (0, _generated.isFunction)(parent, {
	    body: node
	  })) {
	    return false;
	  }

	  if ((0, _generated.isBlockStatement)(node) && (0, _generated.isCatchClause)(parent, {
	    body: node
	  })) {
	    return false;
	  }

	  return (0, _generated.isScopable)(node);
	}

/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = isSpecifierDefault;

	var _generated = __webpack_require__(8);

	function isSpecifierDefault(specifier) {
	  return (0, _generated.isImportDefaultSpecifier)(specifier) || (0, _generated.isIdentifier)(specifier.imported || specifier.exported, {
	    name: "default"
	  });
	}

/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = isValidES3Identifier;

	var _isValidIdentifier = _interopRequireDefault(__webpack_require__(20));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	const RESERVED_WORDS_ES3_ONLY = new Set(["abstract", "boolean", "byte", "char", "double", "enum", "final", "float", "goto", "implements", "int", "interface", "long", "native", "package", "private", "protected", "public", "short", "static", "synchronized", "throws", "transient", "volatile"]);

	function isValidES3Identifier(name) {
	  return (0, _isValidIdentifier.default)(name) && !RESERVED_WORDS_ES3_ONLY.has(name);
	}

/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = isVar;

	var _generated = __webpack_require__(8);

	var _constants = __webpack_require__(16);

	function isVar(node) {
	  return (0, _generated.isVariableDeclaration)(node, {
	    kind: "var"
	  }) && !node[_constants.BLOCK_SCOPED_SYMBOL];
	}

/***/ }),
/* 141 */
/***/ (function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = isCompatTag;

	function isCompatTag(tagName) {
	  return !!tagName && /^[a-z]/.test(tagName);
	}

/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;

	var _buildMatchMemberExpression = _interopRequireDefault(__webpack_require__(56));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	const isReactComponent = (0, _buildMatchMemberExpression.default)("React.Component");
	var _default = isReactComponent;
	exports.default = _default;

/***/ }),
/* 143 */
/***/ (function(module, exports) {

	module.exports = require("babel-polyfill");

/***/ }),
/* 144 */
/***/ (function(module, exports) {

	module.exports = require("babel-runtime/helpers/defineProperty");

/***/ }),
/* 145 */
/***/ (function(module, exports) {

	module.exports = require("babel-runtime/helpers/inherits");

/***/ }),
/* 146 */
/***/ (function(module, exports) {

	module.exports = require("babel-runtime/helpers/possibleConstructorReturn");

/***/ }),
/* 147 */
/***/ (function(module, exports) {

	module.exports = require("esutils");

/***/ }),
/* 148 */
/***/ (function(module, exports) {

	module.exports = require("fast-glob");

/***/ }),
/* 149 */
/***/ (function(module, exports) {

	module.exports = require("immutable");

/***/ }),
/* 150 */
/***/ (function(module, exports) {

	module.exports = require("jsesc");

/***/ }),
/* 151 */
/***/ (function(module, exports) {

	module.exports = require("lodash/clone");

/***/ }),
/* 152 */
/***/ (function(module, exports) {

	module.exports = require("lodash/isInteger");

/***/ }),
/* 153 */
/***/ (function(module, exports) {

	module.exports = require("lodash/isPlainObject");

/***/ }),
/* 154 */
/***/ (function(module, exports) {

	module.exports = require("lodash/isRegExp");

/***/ }),
/* 155 */
/***/ (function(module, exports) {

	module.exports = require("lodash/repeat");

/***/ }),
/* 156 */
/***/ (function(module, exports) {

	module.exports = require("lodash/uniq");

/***/ }),
/* 157 */
/***/ (function(module, exports) {

	module.exports = require("source-map");

/***/ }),
/* 158 */
/***/ (function(module, exports) {

	module.exports = require("to-fast-properties");

/***/ }),
/* 159 */
/***/ (function(module, exports) {

	module.exports = require("trim-right");

/***/ }),
/* 160 */
/***/ (function(module, exports) {

	module.exports = require("yargs");

/***/ })
/******/ ]);