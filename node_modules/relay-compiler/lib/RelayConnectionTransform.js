/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */

'use strict';

var _extends3 = _interopRequireDefault(require('babel-runtime/helpers/extends'));

var _toConsumableArray3 = _interopRequireDefault(require('babel-runtime/helpers/toConsumableArray'));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var CONNECTION = 'connection';

/**
 * @public
 *
 * Transforms fields with the `@connection` directive:
 * - Verifies that the field type is connection-like.
 * - Adds a `handle` property to the field, either the user-provided `handle`
 *   argument or the default value "connection".
 * - Inserts a sub-fragment on the field to ensure that standard connection
 *   fields are fetched (e.g. cursors, node ids, page info).
 */
function relayConnectionTransform(context) {
  return require('graphql-compiler').IRTransformer.transform(context, {
    Fragment: visitFragmentOrRoot,
    LinkedField: visitLinkedField,
    Root: visitFragmentOrRoot
  }, function (node) {
    return {
      path: [],
      connectionMetadata: [],
      definitionName: node.name
    };
  });
}

var SCHEMA_EXTENSION = 'directive @connection(key: String!, filters: [String]) on FIELD';

/**
 * @internal
 */
function visitFragmentOrRoot(node, options) {
  var transformedNode = this.traverse(node, options);
  var connectionMetadata = options.connectionMetadata;
  if (connectionMetadata.length) {
    return (0, _extends3['default'])({}, transformedNode, {
      metadata: (0, _extends3['default'])({}, transformedNode.metadata, {
        connection: connectionMetadata
      })
    });
  }
  return transformedNode;
}

/**
 * @internal
 */
function visitLinkedField(field, options) {
  var isPlural = require('graphql-compiler').SchemaUtils.getNullableType(field.type) instanceof require('graphql').GraphQLList;
  options.path.push(isPlural ? null : field.alias || field.name);
  var transformedField = this.traverse(field, options);
  var connectionDirective = field.directives.find(function (directive) {
    return directive.name === CONNECTION;
  });
  if (!connectionDirective) {
    options.path.pop();
    return transformedField;
  }
  var definitionName = options.definitionName;

  validateConnectionSelection(definitionName, transformedField);
  validateConnectionType(definitionName, transformedField.type);

  var pathHasPlural = options.path.includes(null);
  var firstArg = findArg(transformedField, require('./RelayConnectionConstants').FIRST);
  var lastArg = findArg(transformedField, require('./RelayConnectionConstants').LAST);
  var direction = null;
  var countArg = null;
  var cursorArg = null;
  if (firstArg && !lastArg) {
    direction = 'forward';
    countArg = firstArg;
    cursorArg = findArg(transformedField, require('./RelayConnectionConstants').AFTER);
  } else if (lastArg && !firstArg) {
    direction = 'backward';
    countArg = lastArg;
    cursorArg = findArg(transformedField, require('./RelayConnectionConstants').BEFORE);
  } else if (lastArg && firstArg) {
    direction = 'bidirectional';
    // TODO(T26511885) Maybe add connection metadata to this case
  }
  var countVariable = countArg && countArg.value.kind === 'Variable' ? countArg.value.variableName : null;
  var cursorVariable = cursorArg && cursorArg.value.kind === 'Variable' ? cursorArg.value.variableName : null;
  options.connectionMetadata.push({
    count: countVariable,
    cursor: cursorVariable,
    direction: direction,
    path: pathHasPlural ? null : [].concat((0, _toConsumableArray3['default'])(options.path))
  });
  options.path.pop();

  var _getLiteralArgumentVa = require('graphql-compiler').getLiteralArgumentValues(connectionDirective.args),
      key = _getLiteralArgumentVa.key,
      filters = _getLiteralArgumentVa.filters;

  !(typeof key === 'string') ? process.env.NODE_ENV !== 'production' ? require('fbjs/lib/invariant')(false, 'RelayConnectionTransform: Expected the %s argument to @%s to ' + 'be a string literal for field %s', require('./RelayConnectionConstants').KEY, CONNECTION, field.name) : require('fbjs/lib/invariant')(false) : void 0;
  var postfix = '' + (field.alias || field.name);
  !key.endsWith('_' + postfix) ? process.env.NODE_ENV !== 'production' ? require('fbjs/lib/invariant')(false, 'RelayConnectionTransform: Expected the %s argument to @%s to ' + 'be of form <SomeName>_%s, but get %s. For detailed explanation, check out the dex page ' + 'https://facebook.github.io/relay/docs/pagination-container.html#connection-directive', require('./RelayConnectionConstants').KEY, CONNECTION, postfix, key) : require('fbjs/lib/invariant')(false) : void 0;

  var generateFilters = function generateFilters() {
    var filteredVariableArgs = field.args.filter(function (arg) {
      return !require('relay-runtime').ConnectionInterface.isConnectionCall({
        name: arg.name,
        value: null
      });
    }).map(function (arg) {
      return arg.name;
    });
    return filteredVariableArgs.length === 0 ? null : filteredVariableArgs;
  };

  var handle = {
    name: CONNECTION,
    key: key,
    filters: filters || generateFilters()
  };

  if (direction !== null) {
    var fragment = generateConnectionFragment(this.getContext(), transformedField.type, direction);
    transformedField = (0, _extends3['default'])({}, transformedField, {
      selections: transformedField.selections.concat(fragment)
    });
  }
  return (0, _extends3['default'])({}, transformedField, {
    directives: transformedField.directives.filter(function (directive) {
      return directive.name !== CONNECTION;
    }),
    handles: transformedField.handles ? [].concat((0, _toConsumableArray3['default'])(transformedField.handles), [handle]) : [handle]
  });
}

/**
 * @internal
 *
 * Generates a fragment on the given type that fetches the minimal connection
 * fields in order to merge different pagination results together at runtime.
 */
function generateConnectionFragment(context, type, direction) {
  var _ConnectionInterface$ = require('relay-runtime').ConnectionInterface.get(),
      CURSOR = _ConnectionInterface$.CURSOR,
      EDGES = _ConnectionInterface$.EDGES,
      END_CURSOR = _ConnectionInterface$.END_CURSOR,
      HAS_NEXT_PAGE = _ConnectionInterface$.HAS_NEXT_PAGE,
      HAS_PREV_PAGE = _ConnectionInterface$.HAS_PREV_PAGE,
      NODE = _ConnectionInterface$.NODE,
      PAGE_INFO = _ConnectionInterface$.PAGE_INFO,
      START_CURSOR = _ConnectionInterface$.START_CURSOR;

  var compositeType = require('graphql').assertCompositeType(require('graphql-compiler').SchemaUtils.getNullableType(type));

  var pageInfo = PAGE_INFO;
  if (direction === 'forward') {
    pageInfo += '{\n      ' + END_CURSOR + '\n      ' + HAS_NEXT_PAGE + '\n    }';
  } else if (direction === 'backward') {
    pageInfo += '{\n      ' + HAS_PREV_PAGE + '\n      ' + START_CURSOR + '\n    }';
  } else {
    pageInfo += '{\n      ' + END_CURSOR + '\n      ' + HAS_NEXT_PAGE + '\n      ' + HAS_PREV_PAGE + '\n      ' + START_CURSOR + '\n    }';
  }

  var fragmentString = 'fragment ConnectionFragment on ' + String(compositeType) + ' {\n      ' + EDGES + ' {\n        ' + CURSOR + '\n        ' + NODE + ' {\n          __typename # rely on GenerateRequisiteFieldTransform to add "id"\n        }\n      }\n      ' + pageInfo + '\n    }';

  var ast = require('graphql').parse(fragmentString);
  var fragmentAST = ast.definitions[0];
  !(fragmentAST && fragmentAST.kind === 'FragmentDefinition') ? process.env.NODE_ENV !== 'production' ? require('fbjs/lib/invariant')(false, 'RelayConnectionTransform: Expected a fragment definition AST.') : require('fbjs/lib/invariant')(false) : void 0;
  var fragment = require('./RelayParser').transform(context.clientSchema, fragmentAST);
  !(fragment && fragment.kind === 'Fragment') ? process.env.NODE_ENV !== 'production' ? require('fbjs/lib/invariant')(false, 'RelayConnectionTransform: Expected a connection fragment.') : require('fbjs/lib/invariant')(false) : void 0;
  return {
    directives: [],
    kind: 'InlineFragment',
    metadata: null,
    selections: fragment.selections,
    typeCondition: compositeType
  };
}

function findArg(field, argName) {
  return field.args && field.args.find(function (arg) {
    return arg.name === argName;
  });
}

/**
 * @internal
 *
 * Validates that the selection is a valid connection:
 * - Specifies a first or last argument to prevent accidental, unconstrained
 *   data access.
 * - Has an `edges` selection, otherwise there is nothing to paginate.
 *
 * TODO: This implementation requires the edges field to be a direct selection
 * and not contained within an inline fragment or fragment spread. It's
 * technically possible to remove this restriction if this pattern becomes
 * common/necessary.
 */
function validateConnectionSelection(definitionName, field) {
  var _ConnectionInterface$2 = require('relay-runtime').ConnectionInterface.get(),
      EDGES = _ConnectionInterface$2.EDGES;

  if (!findArg(field, require('./RelayConnectionConstants').FIRST) && !findArg(field, require('./RelayConnectionConstants').LAST)) {
    throw new Error('RelayConnectionTransform: Expected field `' + field.name + ': ' + (String(field.type) + '` to have a ' + require('./RelayConnectionConstants').FIRST + ' or ' + require('./RelayConnectionConstants').LAST + ' argument in ') + ('document `' + definitionName + '`.'));
  }
  if (!field.selections.some(function (selection) {
    return selection.kind === 'LinkedField' && selection.name === EDGES;
  })) {
    throw new Error('RelayConnectionTransform: Expected field `' + field.name + ': ' + (String(field.type) + '` to have a ' + EDGES + ' selection in document ') + ('`' + definitionName + '`.'));
  }
}

/**
 * @internal
 *
 * Validates that the type satisfies the Connection specification:
 * - The type has an edges field, and edges have scalar `cursor` and object
 *   `node` fields.
 * - The type has a page info field which is an object with the correct
 *   subfields.
 */
function validateConnectionType(definitionName, type) {
  var _ConnectionInterface$3 = require('relay-runtime').ConnectionInterface.get(),
      CURSOR = _ConnectionInterface$3.CURSOR,
      EDGES = _ConnectionInterface$3.EDGES,
      END_CURSOR = _ConnectionInterface$3.END_CURSOR,
      HAS_NEXT_PAGE = _ConnectionInterface$3.HAS_NEXT_PAGE,
      HAS_PREV_PAGE = _ConnectionInterface$3.HAS_PREV_PAGE,
      NODE = _ConnectionInterface$3.NODE,
      PAGE_INFO = _ConnectionInterface$3.PAGE_INFO,
      START_CURSOR = _ConnectionInterface$3.START_CURSOR;

  var typeWithFields = require('graphql-compiler').SchemaUtils.assertTypeWithFields(require('graphql-compiler').SchemaUtils.getNullableType(type));
  var typeFields = typeWithFields.getFields();
  var edges = typeFields[EDGES];

  !edges ? process.env.NODE_ENV !== 'production' ? require('fbjs/lib/invariant')(false, 'RelayConnectionTransform: Expected type `%s` to have an %s field in ' + 'document `%s`.', type, EDGES, definitionName) : require('fbjs/lib/invariant')(false) : void 0;

  var edgesType = require('graphql-compiler').SchemaUtils.getNullableType(edges.type);
  !(edgesType instanceof require('graphql').GraphQLList) ? process.env.NODE_ENV !== 'production' ? require('fbjs/lib/invariant')(false, 'RelayConnectionTransform: Expected `%s` field on type `%s` to be a ' + 'list type in document `%s`.', EDGES, type, definitionName) : require('fbjs/lib/invariant')(false) : void 0;
  var edgeType = require('graphql-compiler').SchemaUtils.getNullableType(edgesType.ofType);
  !(edgeType instanceof require('graphql').GraphQLObjectType) ? process.env.NODE_ENV !== 'production' ? require('fbjs/lib/invariant')(false, 'RelayConnectionTransform: Expected %s field on type `%s` to be a list ' + 'of objects in document `%s`.', EDGES, type, definitionName) : require('fbjs/lib/invariant')(false) : void 0;

  var node = edgeType.getFields()[NODE];
  !node ? process.env.NODE_ENV !== 'production' ? require('fbjs/lib/invariant')(false, 'RelayConnectionTransform: Expected type `%s` to have an %s.%s field in ' + 'document `%s`.', type, EDGES, NODE, definitionName) : require('fbjs/lib/invariant')(false) : void 0;
  var nodeType = require('graphql-compiler').SchemaUtils.getNullableType(node.type);
  !(nodeType instanceof require('graphql').GraphQLInterfaceType || nodeType instanceof require('graphql').GraphQLUnionType || nodeType instanceof require('graphql').GraphQLObjectType) ? process.env.NODE_ENV !== 'production' ? require('fbjs/lib/invariant')(false, 'RelayConnectionTransform: Expected type `%s` to have an %s.%s field' + 'for which the type is an interface, object, or union in document `%s`.', type, EDGES, NODE, definitionName) : require('fbjs/lib/invariant')(false) : void 0;

  var cursor = edgeType.getFields()[CURSOR];
  !(cursor && require('graphql-compiler').SchemaUtils.getNullableType(cursor.type) instanceof require('graphql').GraphQLScalarType) ? process.env.NODE_ENV !== 'production' ? require('fbjs/lib/invariant')(false, 'RelayConnectionTransform: Expected type `%s` to have an ' + '%s.%s field for which the type is a scalar in document `%s`.', type, EDGES, CURSOR, definitionName) : require('fbjs/lib/invariant')(false) : void 0;

  var pageInfo = typeFields[PAGE_INFO];
  !pageInfo ? process.env.NODE_ENV !== 'production' ? require('fbjs/lib/invariant')(false, 'RelayConnectionTransform: Expected type `%s` to have a %s field ' + 'in document `%s`.', type, PAGE_INFO, definitionName) : require('fbjs/lib/invariant')(false) : void 0;
  var pageInfoType = require('graphql-compiler').SchemaUtils.getNullableType(pageInfo.type);
  !(pageInfoType instanceof require('graphql').GraphQLObjectType) ? process.env.NODE_ENV !== 'production' ? require('fbjs/lib/invariant')(false, 'RelayConnectionTransform: Expected type `%s` to have a %s field for ' + 'which the type is an object in document `%s`.', type, PAGE_INFO, definitionName) : require('fbjs/lib/invariant')(false) : void 0;

  [END_CURSOR, HAS_NEXT_PAGE, HAS_PREV_PAGE, START_CURSOR].forEach(function (fieldName) {
    var pageInfoField = pageInfoType.getFields()[fieldName];
    !(pageInfoField && require('graphql-compiler').SchemaUtils.getNullableType(pageInfoField.type) instanceof require('graphql').GraphQLScalarType) ? process.env.NODE_ENV !== 'production' ? require('fbjs/lib/invariant')(false, 'RelayConnectionTransform: Expected type `%s` to have an ' + '%s field for which the type is an scalar in document `%s`.', pageInfo.type, fieldName, definitionName) : require('fbjs/lib/invariant')(false) : void 0;
  });
}

module.exports = {
  CONNECTION: CONNECTION,
  SCHEMA_EXTENSION: SCHEMA_EXTENSION,
  transform: relayConnectionTransform
};